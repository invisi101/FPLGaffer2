<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@600;800&display=swap" rel="stylesheet">
<title>FPL Gaffer - the brAIn</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #181a24;
    --surface2: #1f2231;
    --border: #2a2d3e;
    --text: #e0e0e8;
    --text2: #8e91a4;
    --accent: #6c63ff;
    --accent2: #8b83ff;
    --green: #2dd4a0;
    --red: #f87171;
    --yellow: #fbbf24;
    --orange: #fb923c;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.5;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 24px;
    background: linear-gradient(135deg, var(--surface) 0%, #1a1d2e 100%);
    border-bottom: 1px solid var(--border);
  }
  .header-brand {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .header-icon {
    width: 32px;
    height: 32px;
    filter: drop-shadow(0 0 6px rgba(108, 99, 255, 0.5));
  }
  .header h1 {
    font-family: 'Outfit', sans-serif;
    font-size: 24px;
    font-weight: 800;
    letter-spacing: -0.5px;
    background: linear-gradient(135deg, #fff 0%, var(--accent2) 50%, var(--green) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .header h1 span {
    font-weight: 600;
    font-size: 14px;
    background: linear-gradient(135deg, var(--text2) 0%, var(--accent) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-left: 2px;
  }
  .cache-badge {
    font-size: 12px;
    padding: 4px 10px;
    border-radius: 12px;
    background: var(--surface2);
    color: var(--text2);
  }
  .cache-badge.fresh { color: var(--green); }
  .cache-badge.stale { color: var(--yellow); }

  .bar-icon {
    display: flex;
    align-items: center;
    padding: 4px;
    opacity: 0.9;
    filter: drop-shadow(0 0 4px rgba(255,255,255,0.15));
    transition: transform 0.3s, filter 0.3s;
    cursor: default;
  }
  .bar-icon:hover {
    transform: scale(1.15) rotate(8deg);
    filter: drop-shadow(0 0 8px rgba(255,255,255,0.3));
  }
  .action-bar {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 24px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
  }

  .btn {
    padding: 8px 16px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    color: var(--text);
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
  }
  .btn:hover { background: var(--accent); border-color: var(--accent); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn:disabled:hover { background: var(--surface2); border-color: var(--border); }
  .btn-primary { background: var(--accent); border-color: var(--accent); }
  .btn-primary:hover { background: var(--accent2); }

  .status-area {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: var(--text2);
    max-width: 50%;
  }
  .status-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--text2);
    flex-shrink: 0;
  }
  .status-dot.running {
    background: var(--green);
    animation: pulse 1.2s infinite;
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }
  .status-text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .tabs {
    display: flex;
    padding: 0 24px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
  }
  .tab {
    padding: 10px 20px;
    font-size: 13px;
    font-weight: 500;
    color: var(--text2);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.15s;
  }
  .tab:hover { color: var(--text); }
  .tab.active { color: var(--accent); border-bottom-color: var(--accent); }

  .content { padding: 16px 24px; }

  /* Predictions panel */
  .controls-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }
  .pos-filters { display: flex; gap: 4px; }
  .pos-btn {
    padding: 5px 12px;
    border-radius: 4px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text2);
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
  }
  .pos-btn:hover { border-color: var(--accent); color: var(--text); }
  .pos-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  .search-box {
    padding: 6px 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    color: var(--text);
    font-size: 13px;
    width: 220px;
    outline: none;
    transition: border-color 0.15s;
  }
  .search-box:focus { border-color: var(--accent); }
  .search-box::placeholder { color: var(--text2); }

  .player-count {
    font-size: 12px;
    color: var(--text2);
    margin-left: auto;
  }

  .table-wrap {
    overflow-x: auto;
    border: 1px solid var(--border);
    border-radius: 8px;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
  }
  thead th {
    position: sticky;
    top: 0;
    background: var(--surface2);
    padding: 10px 12px;
    text-align: left;
    font-weight: 600;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    color: var(--text2);
    cursor: pointer;
    white-space: nowrap;
    border-bottom: 1px solid var(--border);
    user-select: none;
  }
  thead th:hover { color: var(--text); }
  thead th.sorted { color: var(--accent); }
  thead th .sort-arrow { font-size: 10px; margin-left: 4px; }
  tbody td {
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
    white-space: nowrap;
  }
  tbody tr:nth-child(even) { background: var(--surface); }
  tbody tr:hover { background: var(--surface2); }

  /* FDR colour coding */
  .fdr-1 { background: #166534; color: #fff; }
  .fdr-2 { background: #15803d; color: #fff; }
  .fdr-3 { background: #a16207; color: #fff; }
  .fdr-4 { background: #c2410c; color: #fff; }
  .fdr-5 { background: #991b1b; color: #fff; }
  .fdr-cell {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-weight: 600;
    font-size: 12px;
    min-width: 28px;
    text-align: center;
  }

  .home-badge {
    display: inline-block;
    padding: 1px 6px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: 600;
  }
  .home-badge.home { background: #166534; color: #4ade80; }
  .home-badge.away { background: #1e293b; color: var(--text2); }

  .pos-tag {
    display: inline-block;
    padding: 1px 6px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: 600;
    background: var(--surface2);
  }
  .pos-tag.GKP { color: #f59e0b; }
  .pos-tag.DEF { color: #22d3ee; }
  .pos-tag.MID { color: #a78bfa; }
  .pos-tag.FWD { color: #f87171; }

  .progress-container {
    display: none;
    margin: 0 24px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  .progress-container.visible { display: block; }

  .progress-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 14px;
    cursor: pointer;
    user-select: none;
  }
  .progress-header:hover { background: var(--surface2); }
  .progress-header-left {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: var(--text2);
    min-width: 0;
  }
  .progress-spinner {
    width: 14px; height: 14px;
    border: 2px solid var(--surface2);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    flex-shrink: 0;
  }
  .progress-spinner.done { animation: none; border-color: var(--green); border-top-color: var(--green); }
  .progress-spinner.error { animation: none; border-color: var(--red); border-top-color: var(--red); }
  @keyframes spin { to { transform: rotate(360deg); } }
  .progress-msg {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .progress-chevron {
    font-size: 10px;
    color: var(--text2);
    flex-shrink: 0;
    transition: transform 0.2s;
  }
  .progress-container.expanded .progress-chevron { transform: rotate(180deg); }

  .progress-log {
    display: none;
    border-top: 1px solid var(--border);
    padding: 10px 14px;
    max-height: 200px;
    overflow-y: auto;
    font-family: 'SF Mono', Consolas, monospace;
    font-size: 11px;
    color: var(--text2);
    line-height: 1.7;
    background: var(--bg);
  }
  .progress-container.expanded .progress-log { display: block; }

  .empty-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text2);
  }
  .empty-state h3 { font-size: 18px; margin-bottom: 8px; color: var(--text); }
  .empty-state p { font-size: 14px; }

  /* Best Team panel */
  .team-panel { display: none; }
  .team-panel.visible { display: block; }

  .team-controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    flex-wrap: wrap;
  }
  .team-controls label { font-size: 13px; color: var(--text2); }
  .budget-input {
    width: 90px;
    padding: 6px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    color: var(--text);
    font-size: 14px;
    font-weight: 600;
    outline: none;
    text-align: center;
  }
  .budget-input:focus { border-color: var(--accent); }
  .target-select {
    padding: 6px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    color: var(--text);
    font-size: 13px;
    outline: none;
  }

  .team-summary {
    display: flex;
    gap: 16px;
    margin-bottom: 16px;
    flex-wrap: wrap;
  }
  .summary-stat {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px 20px;
    text-align: center;
  }
  .summary-stat .label { font-size: 11px; color: var(--text2); text-transform: uppercase; letter-spacing: 0.5px; }
  .summary-stat .value { font-size: 22px; font-weight: 700; color: var(--accent); margin-top: 2px; }
  .summary-stat .value.green { color: var(--green); }
  .summary-stat .value.model { color: var(--accent); }
  .summary-stat .value.ep { color: var(--orange); }
  .summary-stat .value.form { color: var(--text2); }
  .summary-stat .value.best { color: var(--green); }

  /* Pitch */
  .pitch {
    position: relative;
    width: 100%;
    max-width: 720px;
    height: 700px;
    margin: 0 auto;
    background: linear-gradient(180deg, #1a6e2e 0%, #1d7a33 10%, #1a6e2e 20%, #1d7a33 30%, #1a6e2e 40%, #1d7a33 50%, #1a6e2e 60%, #1d7a33 70%, #1a6e2e 80%, #1d7a33 90%, #1a6e2e 100%);
    border-radius: 12px;
    overflow: hidden;
    border: 3px solid rgba(255,255,255,0.15);
  }
  /* Field markings */
  .pitch::before {
    content: '';
    position: absolute;
    inset: 0;
    background:
      /* halfway line */
      linear-gradient(0deg, transparent calc(50% - 1px), rgba(255,255,255,0.2) calc(50% - 1px), rgba(255,255,255,0.2) calc(50% + 1px), transparent calc(50% + 1px)),
      /* center circle */
      radial-gradient(circle at 50% 50%, transparent 58px, rgba(255,255,255,0.2) 58px, rgba(255,255,255,0.2) 60px, transparent 60px),
      /* top penalty box */
      linear-gradient(0deg, transparent 0%, transparent 18%, rgba(255,255,255,0.0) 18%) no-repeat,
      /* bottom penalty box */
      linear-gradient(0deg, transparent 82%, rgba(255,255,255,0.0) 82%);
    pointer-events: none;
  }
  .pitch::after {
    content: '';
    position: absolute;
    /* top penalty area */
    top: 0; left: 20%; width: 60%; height: 20%;
    border: 2px solid rgba(255,255,255,0.15);
    border-top: none;
    pointer-events: none;
  }
  .pitch-bottom-box {
    position: absolute;
    bottom: 0; left: 20%; width: 60%; height: 20%;
    border: 2px solid rgba(255,255,255,0.15);
    border-bottom: none;
    pointer-events: none;
  }

  .pitch-row {
    position: absolute;
    left: 0; right: 0;
    display: flex;
    justify-content: center;
    gap: 8px;
    padding: 0 12px;
  }
  .pitch-row.fwd { top: 10px; }
  .pitch-row.mid { top: 188px; }
  .pitch-row.def { top: 366px; }
  .pitch-row.gkp { top: 544px; }

  .pitch-card {
    background: rgba(15, 17, 23, 0.88);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    padding: 8px 10px;
    text-align: center;
    min-width: 90px;
    max-width: 120px;
    backdrop-filter: blur(4px);
  }
  .pitch-card .p-name {
    font-size: 12px;
    font-weight: 700;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 2px;
  }
  .pitch-card .p-team {
    font-size: 10px;
    color: var(--text2);
  }
  .pitch-card .p-pts {
    font-size: 16px;
    font-weight: 700;
    color: var(--green);
    margin-top: 2px;
  }
  .pitch-card .p-cost {
    font-size: 10px;
    color: var(--text2);
  }
  .pitch-card .p-fdr {
    display: inline-block;
    padding: 0 5px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: 600;
    margin-top: 2px;
  }

  .bench-area {
    max-width: 720px;
    margin: 16px auto 0;
  }
  .bench-label {
    font-size: 12px;
    font-weight: 600;
    color: var(--text2);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
  }
  .bench-row {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
  }
  .bench-card {
    background: var(--surface);
    border: 1px dashed var(--border);
    border-radius: 8px;
    padding: 8px 14px;
    text-align: center;
    opacity: 0.6;
    min-width: 100px;
  }
  .bench-card .p-name { font-size: 12px; font-weight: 600; }
  .bench-card .p-team { font-size: 10px; color: var(--text2); }
  .bench-card .p-pts { font-size: 14px; font-weight: 700; color: var(--accent); margin-top: 2px; }
  .bench-card .p-cost { font-size: 10px; color: var(--text2); }

  /* GW Compare panel */
  .compare-panel { display: none; }
  .compare-panel.visible { display: block; }

  .compare-controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    flex-wrap: wrap;
  }
  .compare-controls label { font-size: 13px; color: var(--text2); }
  .compare-controls .bt-input { width: 70px; }

  .compare-summary {
    display: flex;
    gap: 12px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }

  .compare-pitches {
    display: flex;
    gap: 24px;
    margin-top: 16px;
  }
  .compare-side {
    flex: 1;
    min-width: 0;
  }
  .compare-side h3 {
    font-size: 15px;
    font-weight: 600;
    margin-bottom: 10px;
    text-align: center;
  }
  .compare-side .pitch {
    max-width: 100%;
    height: 540px;
  }
  .compare-side .pitch-card {
    min-width: 70px;
    max-width: 100px;
    padding: 6px 6px;
  }
  .compare-side .pitch-card .p-name { font-size: 11px; }
  .compare-side .pitch-card .p-team { font-size: 9px; }
  .compare-side .pitch-card .p-pts { font-size: 14px; }
  .compare-side .pitch-card .p-cost { font-size: 9px; }
  .compare-side .pitch-card .p-pred { font-size: 9px; color: var(--text2); }
  .compare-side .pitch-row.fwd { top: 8px; }
  .compare-side .pitch-row.mid { top: 142px; }
  .compare-side .pitch-row.def { top: 280px; }
  .compare-side .pitch-row.gkp { top: 420px; }

  .pitch-card.injured { border-color: var(--red); opacity: 0.7; }
  .pitch-card.doubtful { border-color: var(--yellow); }
  .p-news { font-size: 9px; color: var(--red); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 110px; }
  .p-avail { font-size: 9px; }
  .p-avail.available { color: var(--green); }
  .p-avail.doubtful { color: var(--yellow); }
  .p-avail.injured { color: var(--red); }
  .captain-badge { color: #ef4444; font-weight: 700; font-size: 10px; }
  .vc-badge { color: var(--yellow); font-weight: 700; font-size: 10px; }

  .pitch-card.overlap {
    border: 2px solid var(--yellow) !important;
    box-shadow: 0 0 10px rgba(251, 191, 36, 0.4);
  }

  /* Transfer recommendations */
  .transfer-controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-top: 24px;
    margin-bottom: 16px;
    flex-wrap: wrap;
    padding-top: 16px;
    border-top: 1px solid var(--border);
  }
  .transfer-controls label { font-size: 13px; color: var(--text2); }
  .transfer-controls .budget-input { width: 60px; }

  .transfer-cards { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; max-width: 720px; margin-left: auto; margin-right: auto; }
  .transfer-card {
    display: flex;
    align-items: center;
    gap: 12px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 16px;
  }
  .transfer-side {
    flex: 1;
    min-width: 0;
  }
  .transfer-side .ts-name { font-size: 14px; font-weight: 600; }
  .transfer-side .ts-meta { font-size: 11px; color: var(--text2); }
  .transfer-side .ts-pts { font-size: 16px; font-weight: 700; margin-top: 2px; }
  .transfer-out .ts-name { color: var(--red); }
  .transfer-out .ts-pts { color: var(--red); }
  .transfer-in .ts-name { color: var(--green); }
  .transfer-in .ts-pts { color: var(--green); }
  .transfer-arrow { font-size: 22px; color: var(--text2); flex-shrink: 0; }
  .transfer-delta {
    text-align: right;
    flex-shrink: 0;
    min-width: 70px;
  }
  .transfer-delta .td-pts { font-size: 14px; font-weight: 700; }
  .transfer-delta .td-cost { font-size: 11px; color: var(--text2); }

  .pitch-card.new-signing {
    border: 2px solid var(--green) !important;
    box-shadow: 0 0 8px rgba(45, 212, 160, 0.4);
  }

  @media (max-width: 900px) {
    .compare-pitches { flex-direction: column; }
  }

  /* PL Table panel */
  .pltable-panel { display: none; }
  .pltable-panel.visible { display: block; }

  .pl-table { width: 100%; border-collapse: collapse; font-size: 13px; }
  .pl-table th {
    padding: 8px 10px;
    text-align: left;
    font-weight: 600;
    color: var(--text2);
    border-bottom: 2px solid var(--border);
    position: sticky;
    top: 0;
    background: var(--bg);
    z-index: 1;
  }
  .pl-table th.num, .pl-table td.num { text-align: center; }
  .pl-table td {
    padding: 7px 10px;
    border-bottom: 1px solid var(--border);
    white-space: nowrap;
  }
  .pl-table tr:hover td { background: var(--surface2); }
  .pl-table .team-name { font-weight: 600; }
  .pl-table .pos-cl { border-left: 3px solid #3b82f6; }
  .pl-table .pos-el { border-left: 3px solid #f97316; }
  .pl-table .pos-rel { border-left: 3px solid var(--red); }
  .form-dots { display: flex; gap: 3px; }
  .form-dot {
    width: 18px; height: 18px; border-radius: 3px;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; font-weight: 700; color: #fff;
  }
  .form-w { background: #22c55e; }
  .form-d { background: #6b7280; }
  .form-l { background: var(--red); }

  /* Team Form panel */
  .teamform-panel { display: none; }
  .teamform-panel.visible { display: block; }

  .form-table { width: 100%; border-collapse: collapse; font-size: 13px; }
  .form-table th {
    padding: 8px 6px; text-align: center; font-weight: 600; color: var(--text2);
    border-bottom: 2px solid var(--border); position: sticky; top: 0;
    background: var(--bg); z-index: 1; cursor: pointer; user-select: none;
    white-space: nowrap;
  }
  .form-table th:first-child, .form-table th:nth-child(2) { text-align: left; }
  .form-table th .sort-arrow { font-size: 10px; margin-left: 2px; opacity: 0.5; }
  .form-table th.sorted .sort-arrow { opacity: 1; color: var(--accent); }
  .form-table td {
    padding: 5px 6px; border-bottom: 1px solid var(--border); text-align: center;
    vertical-align: middle;
  }
  .form-table td:first-child { text-align: left; font-weight: 600; }
  .form-table td:nth-child(2) { text-align: center; }
  .form-table tr:hover td { background: var(--surface2); }

  .result-badge {
    display: inline-flex; align-items: center; justify-content: center;
    padding: 3px 6px; border-radius: 4px; font-size: 11px; font-weight: 600;
    cursor: pointer; transition: filter 0.15s; line-height: 1.2;
    min-width: 56px; color: #fff;
  }
  .result-badge:hover { filter: brightness(1.2); }
  .result-badge.win { background: #22c55e; }
  .result-badge.draw { background: #6b7280; }
  .result-badge.loss { background: var(--red); }
  .result-badge .opp { font-size: 10px; opacity: 0.85; margin-left: 4px; text-transform: lowercase; }

  .dgw-cell { display: flex; flex-direction: column; gap: 3px; align-items: center; }
  .bgw-marker { color: var(--text2); font-size: 11px; }

  .match-modal-overlay {
    display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.65);
    z-index: 1000; align-items: center; justify-content: center;
  }
  .match-modal-overlay.visible { display: flex; }
  .match-modal-content {
    background: var(--bg); border: 1px solid var(--border); border-radius: 12px;
    padding: 0; max-width: 420px; width: 90%; max-height: 80vh; overflow-y: auto;
    box-shadow: 0 16px 48px rgba(0,0,0,0.4);
  }
  .match-modal-close {
    position: sticky; top: 0; text-align: right; padding: 8px 12px;
    background: var(--bg); z-index: 1;
  }
  .match-modal-close button {
    background: none; border: none; color: var(--text2); font-size: 20px;
    cursor: pointer; padding: 4px 8px;
  }
  .match-modal-close button:hover { color: var(--text); }

  /* Players panel */
  .players-panel { display: none; }
  .players-panel.visible { display: block; }

  .players-breadcrumb {
    display: flex; align-items: center; gap: 6px; margin-bottom: 16px;
    font-size: 13px; color: var(--text2);
  }
  .players-breadcrumb a {
    color: var(--accent); cursor: pointer; text-decoration: none;
  }
  .players-breadcrumb a:hover { text-decoration: underline; }
  .players-breadcrumb .sep { opacity: 0.5; }
  .players-breadcrumb .current { color: var(--text); font-weight: 600; }

  .players-team-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
    gap: 12px;
  }
  .players-team-card {
    background: var(--surface); border: 1px solid var(--border); border-radius: 10px;
    padding: 16px; text-align: center; cursor: pointer; transition: all 0.15s;
  }
  .players-team-card:hover {
    border-color: var(--accent); transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.2);
  }
  .players-team-card img { width: 48px; height: 48px; margin-bottom: 8px; }
  .players-team-card .team-name { font-weight: 600; font-size: 14px; }
  .players-team-card .player-count { font-size: 12px; color: var(--text2); margin-top: 2px; }

  .roster-section { margin-bottom: 20px; }
  .roster-section h3 {
    font-size: 14px; font-weight: 700; margin-bottom: 10px;
    padding-bottom: 6px; border-bottom: 2px solid var(--border);
  }
  .roster-section h3.pos-GKP { color: #f59e0b; border-color: #f59e0b; }
  .roster-section h3.pos-DEF { color: #22d3ee; border-color: #22d3ee; }
  .roster-section h3.pos-MID { color: #a78bfa; border-color: #a78bfa; }
  .roster-section h3.pos-FWD { color: #f87171; border-color: #f87171; }

  .roster-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 10px;
  }
  .roster-player {
    background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
    padding: 10px 12px; display: flex; align-items: center; gap: 10px;
    cursor: pointer; transition: all 0.15s;
  }
  .roster-player:hover {
    border-color: var(--accent); background: var(--surface2);
  }
  .roster-player img {
    width: 40px; height: 50px; border-radius: 4px; object-fit: cover;
    background: var(--surface2);
  }
  .roster-player .rp-info { flex: 1; min-width: 0; }
  .roster-player .rp-name { font-weight: 600; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .roster-player .rp-meta { font-size: 11px; color: var(--text2); display: flex; gap: 8px; margin-top: 2px; }
  .roster-player .rp-pts { font-weight: 700; font-size: 15px; color: var(--accent); text-align: right; min-width: 32px; }
  .roster-player.status-i { opacity: 0.5; }

  /* "but, how?" explainer panel */
  .wtf-panel { display: none; }
  .wtf-panel.visible { display: block; }
  .wtf-breadcrumb {
    display: flex; align-items: center; gap: 6px; margin-bottom: 16px;
    font-size: 13px; color: var(--text2);
  }
  .wtf-breadcrumb a { color: var(--accent); cursor: pointer; text-decoration: none; }
  .wtf-breadcrumb a:hover { text-decoration: underline; }
  .wtf-breadcrumb .sep { opacity: 0.5; }
  .wtf-breadcrumb .current { color: var(--text); font-weight: 600; }
  .wtf-intro {
    background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
    padding: 20px 24px; margin-bottom: 20px; line-height: 1.6; color: var(--text2);
    font-size: 14px;
  }
  .wtf-intro strong { color: var(--text); }

  /* Verdict header */
  .wtf-verdict {
    display: flex; align-items: center; gap: 20px; margin-bottom: 24px;
    background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
    padding: 20px 24px;
  }
  .wtf-verdict-photo {
    width: 80px; height: 100px; border-radius: 8px; object-fit: cover;
    background: var(--surface2); flex-shrink: 0;
  }
  .wtf-verdict-info { flex: 1; }
  .wtf-verdict-info h2 { margin: 0 0 4px; font-size: 20px; }
  .wtf-verdict-meta { font-size: 13px; color: var(--text2); display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
  .wtf-verdict-meta img { width: 18px; height: 18px; }
  .wtf-verdict-number {
    text-align: right; flex-shrink: 0;
  }
  .wtf-verdict-pts {
    font-size: 42px; font-weight: 800; color: var(--accent);
    line-height: 1;
  }
  .wtf-verdict-label { font-size: 12px; color: var(--text2); margin-top: 2px; }
  .wtf-confidence-range { font-size: 12px; color: var(--text2); margin-top: 4px; }

  /* Model cards row */
  .wtf-model-row {
    display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px;
    align-items: stretch; margin-bottom: 24px;
  }
  .wtf-model-card {
    background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
    padding: 20px;
  }
  .wtf-model-card h3 { margin: 0 0 8px; font-size: 15px; }
  .wtf-model-card .wtf-model-pred {
    font-size: 28px; font-weight: 700; color: var(--accent); margin: 8px 0;
  }
  .wtf-model-card .wtf-model-weight {
    display: inline-block; background: var(--accent); color: #000; border-radius: 12px;
    padding: 2px 10px; font-size: 12px; font-weight: 700;
  }
  .wtf-model-card .wtf-model-desc { font-size: 12px; color: var(--text2); margin-top: 8px; line-height: 1.5; }
  .wtf-formula-arrow {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    color: var(--text2); font-size: 13px; gap: 4px; padding: 0 8px;
  }
  .wtf-formula-arrow .formula { font-family: monospace; font-size: 11px; color: var(--text2); text-align: center; }
  .wtf-formula-arrow .equals { font-size: 22px; font-weight: 700; color: var(--accent); }

  /* Component breakdown */
  .wtf-section { margin-bottom: 24px; }
  .wtf-section h3 { font-size: 16px; font-weight: 700; margin: 0 0 12px; }
  .wtf-component-bar-container {
    background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
    padding: 20px;
  }
  .wtf-stacked-bar {
    display: flex; height: 36px; border-radius: 8px; overflow: hidden;
    margin-bottom: 16px; background: var(--surface2);
  }
  .wtf-bar-seg {
    display: flex; align-items: center; justify-content: center;
    font-size: 11px; font-weight: 600; color: #000;
    transition: flex 0.3s ease; min-width: 0; overflow: hidden;
    white-space: nowrap; padding: 0 4px;
  }
  .wtf-component-detail {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 10px;
  }
  .wtf-comp-item {
    background: var(--surface2); border-radius: 8px; padding: 10px 12px;
    text-align: center;
  }
  .wtf-comp-item .comp-pts { font-size: 20px; font-weight: 700; color: var(--accent); }
  .wtf-comp-item .comp-label { font-size: 12px; color: var(--text2); margin-top: 2px; }
  .wtf-comp-item .comp-raw { font-size: 11px; color: var(--text2); margin-top: 4px; font-style: italic; }

  /* Probability badges */
  .wtf-prob-row {
    display: flex; gap: 12px; margin-bottom: 16px;
  }
  .wtf-prob-badge {
    background: var(--surface2); border-radius: 8px; padding: 8px 16px;
    display: flex; align-items: center; gap: 8px;
  }
  .wtf-prob-badge .prob-val { font-size: 18px; font-weight: 700; color: var(--accent); }
  .wtf-prob-badge .prob-label { font-size: 12px; color: var(--text2); }

  /* Captain box */
  .wtf-captain-box {
    background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
    padding: 20px;
  }
  .wtf-captain-score { font-size: 28px; font-weight: 700; color: var(--accent); margin: 4px 0; }
  .wtf-captain-formula { font-family: monospace; font-size: 13px; color: var(--text2); margin-top: 6px; }
  .wtf-captain-explain { font-size: 12px; color: var(--text2); margin-top: 8px; line-height: 1.5; }

  /* Feature importance bars */
  .wtf-feature-list {
    background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
    padding: 20px;
  }
  .wtf-feature-row {
    display: flex; align-items: center; gap: 12px; margin-bottom: 8px;
  }
  .wtf-feature-row:last-child { margin-bottom: 0; }
  .wtf-feature-label {
    width: 200px; flex-shrink: 0; font-size: 12px; text-align: right;
    color: var(--text2); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .wtf-feature-bar-bg {
    flex: 1; height: 20px; background: var(--surface2); border-radius: 4px;
    overflow: hidden; position: relative;
  }
  .wtf-feature-bar {
    height: 100%; border-radius: 4px; background: var(--accent);
    transition: width 0.4s ease;
  }
  .wtf-feature-value {
    width: 60px; flex-shrink: 0; font-size: 12px; color: var(--text2); text-align: left;
  }
  @media (max-width: 700px) {
    .wtf-model-row { grid-template-columns: 1fr; }
    .wtf-formula-arrow { flex-direction: row; padding: 8px 0; }
    .wtf-feature-label { width: 120px; }
  }

  .player-detail-header {
    display: flex; align-items: flex-start; gap: 20px; margin-bottom: 20px;
    background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
    padding: 20px;
  }
  .player-photo-lg {
    width: 110px; height: 140px; border-radius: 8px; object-fit: cover;
    background: var(--surface2); flex-shrink: 0;
  }
  .player-header-info { flex: 1; }
  .player-header-info h2 { font-size: 22px; margin: 0 0 4px; }
  .player-header-info .player-team-line {
    display: flex; align-items: center; gap: 6px; font-size: 14px;
    color: var(--text2); margin-bottom: 10px;
  }
  .player-header-info .player-team-line img { width: 20px; height: 20px; }
  .player-header-meta { display: flex; flex-wrap: wrap; gap: 8px; }
  .meta-pill {
    background: var(--surface2); border: 1px solid var(--border); border-radius: 20px;
    padding: 4px 12px; font-size: 12px; display: flex; align-items: center; gap: 4px;
  }
  .meta-pill .label { color: var(--text2); }
  .meta-pill .value { font-weight: 600; }
  .meta-pill.status-a .value { color: var(--accent); }
  .meta-pill.status-d .value { color: #f59e0b; }
  .meta-pill.status-i .value, .meta-pill.status-s .value, .meta-pill.status-u .value { color: var(--red); }

  .player-stats-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
    gap: 10px; margin-bottom: 20px;
  }
  .player-stat-card {
    background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
    padding: 10px 12px; text-align: center;
  }
  .player-stat-card .stat-val { font-size: 20px; font-weight: 700; color: var(--text); }
  .player-stat-card .stat-label { font-size: 11px; color: var(--text2); margin-top: 2px; }

  .player-section-title {
    font-size: 14px; font-weight: 700; margin: 20px 0 10px;
    padding-bottom: 6px; border-bottom: 1px solid var(--border);
  }

  .fixture-chips { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
  .fixture-chip {
    display: flex; flex-direction: column; align-items: center;
    border-radius: 8px; padding: 8px 14px; font-size: 12px; font-weight: 600;
    min-width: 65px;
  }
  .fixture-chip .fc-gw { font-size: 10px; opacity: 0.8; margin-bottom: 2px; }
  .fixture-chip .fc-opp { font-size: 13px; }
  .fixture-chip .fc-ha { font-size: 10px; opacity: 0.7; }

  .player-gw-table { width: 100%; border-collapse: collapse; font-size: 12px; }
  .player-gw-table th {
    padding: 6px 8px; text-align: center; font-weight: 600; color: var(--text2);
    border-bottom: 2px solid var(--border); position: sticky; top: 0;
    background: var(--bg); cursor: pointer; user-select: none; white-space: nowrap;
  }
  .player-gw-table td {
    padding: 5px 8px; border-bottom: 1px solid var(--border); text-align: center;
  }
  .player-gw-table tr:hover td { background: var(--surface2); }
  .player-gw-table .pts-high { color: var(--accent); font-weight: 700; }
  .player-gw-table .pts-mid { color: var(--text); }
  .player-gw-table .pts-low { color: var(--red); }

  /* GW Scores panel */
  .gwscores-panel { display: none; }
  .gwscores-panel.visible { display: block; }

  .scores-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
    gap: 12px;
    margin-top: 12px;
  }
  .match-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    overflow: hidden;
  }
  .match-card-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 14px 16px;
    background: var(--surface2);
    font-size: 15px;
    font-weight: 600;
  }
  .match-card-header .score {
    font-size: 22px;
    font-weight: 800;
    min-width: 60px;
    text-align: center;
    letter-spacing: 2px;
  }
  .match-card-header .team-short {
    min-width: 36px;
    text-align: center;
    color: var(--text);
  }
  .match-card-header .vs { color: var(--text2); font-weight: 400; font-size: 14px; }
  .match-card-body { padding: 10px 16px; font-size: 12px; }
  .match-card-body .kickoff-time { color: var(--text2); margin-bottom: 6px; }
  .match-events { display: flex; flex-direction: column; gap: 4px; }
  .match-event {
    display: flex;
    align-items: center;
    gap: 6px;
    color: var(--text);
  }
  .match-event .ev-icon { flex-shrink: 0; width: 16px; text-align: center; font-size: 11px; }
  .match-event .ev-side { color: var(--text2); font-size: 11px; min-width: 28px; }
  .bonus-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: var(--accent);
    color: #fff;
    border-radius: 3px;
    font-size: 10px;
    font-weight: 700;
    padding: 1px 5px;
    margin-right: 4px;
  }

  /* Monsters panel */
  .monsters-panel { display: none; }
  .monsters-panel.visible { display: block; }

  .monsters-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
    gap: 20px;
  }

  .monster-category {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
  }

  .monster-category-header {
    padding: 14px 18px;
    display: flex;
    align-items: center;
    gap: 10px;
    border-bottom: 1px solid var(--border);
    background: var(--surface2);
  }

  .monster-category-header .cat-emoji {
    font-size: 24px;
  }

  .monster-category-header .cat-title {
    font-size: 15px;
    font-weight: 700;
    color: var(--text);
  }

  .monster-category-header .cat-subtitle {
    font-size: 11px;
    color: var(--text2);
    margin-left: auto;
    font-style: italic;
  }

  .monster-podium {
    display: flex;
    gap: 6px;
    padding: 14px;
    justify-content: center;
    align-items: flex-end;
  }

  .monster-card {
    flex: 1;
    max-width: 140px;
    text-align: center;
    background: var(--bg);
    border-radius: 10px;
    padding: 10px 6px 12px;
    position: relative;
    transition: transform 0.2s, box-shadow 0.2s;
    border: 1px solid transparent;
  }

  .monster-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  }

  .monster-card.rank-1 {
    border-color: #fbbf24;
    box-shadow: 0 0 16px rgba(251,191,36,0.15);
    order: 2;
    transform: translateY(-8px);
  }
  .monster-card.rank-1:hover { transform: translateY(-12px); }
  .monster-card.rank-2 { order: 1; }
  .monster-card.rank-3 { order: 3; }

  .monster-rank-badge {
    position: absolute;
    top: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 22px;
    height: 22px;
    border-radius: 50%;
    font-size: 11px;
    font-weight: 800;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
  }

  .rank-1 .monster-rank-badge { background: #fbbf24; color: #1a1a1a; }
  .rank-2 .monster-rank-badge { background: #94a3b8; color: #1a1a1a; }
  .rank-3 .monster-rank-badge { background: #cd7f32; color: #1a1a1a; }

  .monster-photo {
    width: 72px;
    height: 90px;
    object-fit: cover;
    object-position: top;
    border-radius: 6px;
    margin: 8px auto 6px;
    display: block;
    background: var(--surface2);
  }

  .monster-name {
    font-size: 12px;
    font-weight: 700;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .monster-team-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    margin: 2px 0;
  }

  .monster-team-badge {
    width: 14px;
    height: 14px;
  }

  .monster-team-name {
    font-size: 10px;
    color: var(--text2);
  }

  .monster-pos-tag {
    display: inline-block;
    font-size: 9px;
    font-weight: 700;
    padding: 1px 6px;
    border-radius: 3px;
    margin: 3px 0;
  }
  .monster-pos-tag.GKP { background: #f59e0b33; color: #f59e0b; }
  .monster-pos-tag.DEF { background: #22c55e33; color: #22c55e; }
  .monster-pos-tag.MID { background: #3b82f633; color: #3b82f6; }
  .monster-pos-tag.FWD { background: #ef444433; color: #ef4444; }

  .monster-stat {
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid var(--border);
  }

  .monster-stat-value {
    font-size: 18px;
    font-weight: 800;
    color: var(--green);
  }

  .monster-stat-label {
    font-size: 9px;
    color: var(--text2);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .monster-pts {
    font-size: 10px;
    color: var(--accent2);
    margin-top: 2px;
  }

  /* Season panel */
  .season-panel { display: none; }
  .season-panel.visible { display: block; }

  .season-sub-tabs {
    display: flex;
    gap: 4px;
    margin-bottom: 16px;
    flex-wrap: wrap;
  }
  .season-sub-tab {
    padding: 6px 14px;
    border-radius: 6px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text2);
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
  }
  .season-sub-tab:hover { border-color: var(--accent); color: var(--text); }
  .season-sub-tab.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  .season-section { display: none; }
  .season-section.visible { display: block; }

  .season-init-form {
    max-width: 400px;
    margin: 40px auto;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 32px;
    text-align: center;
  }
  .season-init-form h3 { margin-bottom: 16px; font-size: 18px; }
  .season-init-form p { color: var(--text2); margin-bottom: 20px; font-size: 13px; }
  .season-init-form input {
    padding: 8px 14px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    color: var(--text);
    font-size: 14px;
    width: 100%;
    margin-bottom: 12px;
    outline: none;
  }
  .season-init-form input:focus { border-color: var(--accent); }

  .summary-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 12px;
    margin-bottom: 20px;
  }
  .summary-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px;
    text-align: center;
  }
  .summary-card .sc-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text2);
    margin-bottom: 4px;
  }
  .summary-card .sc-value {
    font-size: 22px;
    font-weight: 700;
    color: var(--text);
  }
  .summary-card .sc-value.green { color: var(--green); }
  .summary-card .sc-value.accent { color: var(--accent); }

  .season-chart-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 16px;
    margin-bottom: 20px;
  }
  .season-chart-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px;
  }
  .season-chart-box h4 {
    font-size: 13px;
    color: var(--text2);
    margin-bottom: 8px;
  }

  .wf-step {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 14px;
    border-radius: 8px;
    background: var(--surface2);
    border: 1px solid var(--border);
    font-size: 12px;
    color: var(--text2);
    transition: all 0.2s;
  }
  .wf-step.done {
    border-color: var(--green);
    color: var(--green);
  }
  .wf-step.done .wf-step-num {
    background: var(--green);
    color: var(--bg);
  }
  .wf-step.current {
    border-color: var(--accent);
    color: var(--text);
    background: rgba(108, 99, 255, 0.1);
  }
  .wf-step.current .wf-step-num {
    background: var(--accent);
    color: #fff;
    animation: pulse 1.5s infinite;
  }
  .wf-step-num {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: var(--surface);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 11px;
    flex-shrink: 0;
  }
  .wf-step-label {
    font-weight: 500;
    white-space: nowrap;
  }
  .wf-step-arrow {
    color: var(--text2);
    font-size: 14px;
    padding: 0 6px;
  }

  .action-plan-card {
    background: var(--surface);
    border: 1px solid var(--accent);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
  }
  .action-plan-card h4 {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .action-step {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    padding: 8px 0;
    border-bottom: 1px solid var(--border);
    font-size: 13px;
  }
  .action-step:last-child { border-bottom: none; }
  .action-step-icon {
    font-size: 14px;
    flex-shrink: 0;
    width: 20px;
    text-align: center;
  }
  .action-step-check {
    width: 18px;
    height: 18px;
    border: 2px solid var(--border);
    border-radius: 4px;
    flex-shrink: 0;
    cursor: pointer;
    position: relative;
    margin-top: 1px;
  }
  .action-step-check:hover { border-color: var(--green); }
  .action-step-check.checked {
    background: var(--green);
    border-color: var(--green);
  }
  .action-step-check.checked::after {
    content: '\2713';
    position: absolute;
    top: -1px;
    left: 2px;
    font-size: 13px;
    color: #000;
    font-weight: 700;
  }

  .outcome-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    margin-top: 16px;
  }
  .outcome-card h4 {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 12px;
  }
  .outcome-row {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 1px solid var(--border);
    font-size: 13px;
  }
  .outcome-row:last-child { border-bottom: none; }

  .workflow-actions {
    display: flex;
    gap: 12px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }

  .rec-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 12px;
  }
  .rec-card h4 {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 8px;
  }
  .rec-transfers {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }
  .rec-transfer-pair {
    background: var(--surface2);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .rec-out { color: var(--red); }
  .rec-in { color: var(--green); }

  .fixture-grid-wrap {
    overflow-x: auto;
    border: 1px solid var(--border);
    border-radius: 8px;
  }
  .fixture-grid {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
  }
  .fixture-grid th {
    position: sticky;
    top: 0;
    background: var(--surface2);
    padding: 6px 8px;
    text-align: center;
    font-size: 11px;
    color: var(--text2);
    border-bottom: 1px solid var(--border);
    white-space: nowrap;
    min-width: 70px;
  }
  .fixture-grid th:first-child {
    position: sticky;
    left: 0;
    z-index: 2;
    text-align: left;
  }
  .fixture-grid td {
    padding: 4px 6px;
    border-bottom: 1px solid var(--border);
    text-align: center;
    white-space: nowrap;
  }
  .fixture-grid td:first-child {
    position: sticky;
    left: 0;
    background: var(--surface2);
    font-weight: 600;
    text-align: left;
    z-index: 1;
  }
  .fixture-grid tr:nth-child(even) td:first-child { background: var(--surface); }
  .fixture-grid tr:hover td { background: var(--surface2); }
  .fx-dgw { background: rgba(45, 212, 160, 0.15) !important; }
  .fx-bgw { background: rgba(255, 255, 255, 0.05) !important; color: var(--text2); }
  .fx-fdr-1 { background: rgba(22, 101, 52, 0.5); }
  .fx-fdr-2 { background: rgba(21, 128, 61, 0.4); }
  .fx-fdr-3 { background: rgba(161, 98, 7, 0.3); }
  .fx-fdr-4 { background: rgba(194, 65, 12, 0.4); }
  .fx-fdr-5 { background: rgba(153, 27, 27, 0.5); }

  .chip-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 12px;
    margin-bottom: 20px;
  }
  .chip-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    text-align: center;
  }
  .chip-card.used { opacity: 0.5; }
  .chip-card .chip-name { font-size: 14px; font-weight: 600; margin-bottom: 4px; }
  .chip-card .chip-status { font-size: 12px; color: var(--text2); }
  .chip-card .chip-status.available { color: var(--green); }
  .chip-card .chip-value { font-size: 18px; font-weight: 700; color: var(--accent); margin-top: 8px; }

  .price-alerts {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 10px;
    margin-bottom: 16px;
  }
  .price-alert {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 14px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
  }
  .price-alert .pa-dir { font-weight: 700; }
  .price-alert .pa-dir.rise { color: var(--green); }
  .price-alert .pa-dir.fall { color: var(--red); }

  .accuracy-stats {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 12px;
    margin-bottom: 20px;
  }

  /* Phase-aware Season V2 styles */
  .gw-header {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 16px 20px;
    background: linear-gradient(135deg, var(--surface) 0%, #1a1d2e 100%);
    border: 1px solid var(--border);
    border-radius: 12px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  .gw-header-title {
    font-size: 22px;
    font-weight: 700;
    letter-spacing: -0.3px;
  }
  .phase-badge {
    display: inline-block;
    padding: 3px 12px;
    border-radius: 20px;
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .phase-badge.planning { background: rgba(251, 191, 36, 0.15); color: var(--yellow); border: 1px solid rgba(251, 191, 36, 0.3); }
  .phase-badge.ready { background: rgba(45, 212, 160, 0.15); color: var(--green); border: 1px solid rgba(45, 212, 160, 0.3); }
  .phase-badge.live { background: rgba(108, 99, 255, 0.15); color: var(--accent); border: 1px solid rgba(108, 99, 255, 0.3); }
  .phase-badge.complete { background: rgba(251, 146, 60, 0.15); color: var(--orange); border: 1px solid rgba(251, 146, 60, 0.3); }
  .phase-badge.season_over { background: rgba(142, 145, 164, 0.15); color: var(--text2); border: 1px solid rgba(142, 145, 164, 0.3); }
  .gw-deadline {
    margin-left: auto;
    font-size: 12px;
    color: var(--text2);
  }
  .gw-deadline strong {
    color: var(--yellow);
  }

  .phase-spinner {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 48px 24px;
    text-align: center;
  }
  .phase-spinner .spinner-ring {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 16px;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  .phase-spinner .spinner-text {
    font-size: 14px;
    color: var(--text2);
  }
  .phase-spinner .spinner-sub {
    font-size: 12px;
    color: var(--text2);
    margin-top: 4px;
    opacity: 0.7;
  }

  .transfer-cards {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 20px;
  }
  .transfer-card {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
  }
  .transfer-player {
    background: var(--surface);
    border-radius: 8px;
    padding: 10px 14px;
    min-width: 170px;
    flex: 1;
  }
  .transfer-player.out { border: 2px solid var(--red); }
  .transfer-player.in { border: 2px solid var(--green); }
  .transfer-player .tp-name {
    font-weight: 700;
    font-size: 14px;
    margin-bottom: 2px;
  }
  .transfer-player .tp-meta {
    font-size: 11px;
    color: var(--text2);
    margin-bottom: 4px;
  }
  .transfer-player .tp-pred {
    font-size: 13px;
    font-weight: 600;
  }
  .transfer-player.out .tp-pred { color: var(--red); }
  .transfer-player.in .tp-pred { color: var(--green); }
  .transfer-arrow {
    font-size: 22px;
    color: var(--text2);
    flex-shrink: 0;
  }

  .ready-section {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
  }
  .ready-section h4 {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .ready-section h4 .section-icon {
    font-size: 16px;
  }

  .squad-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 8px;
  }
  .squad-player {
    background: var(--surface2);
    border-radius: 6px;
    padding: 8px 10px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
    border-left: 3px solid var(--border);
  }
  .squad-player:hover { border-left-color: var(--accent); background: rgba(108, 99, 255, 0.08); }
  .squad-player.captain { border-left-color: #ef4444; }
  .squad-player.vice-captain { border-left-color: var(--yellow); }
  .squad-player .sp-name { font-weight: 600; }
  .squad-player .sp-meta { font-size: 11px; color: var(--text2); }
  .squad-player .sp-pts { font-weight: 600; color: var(--green); font-size: 12px; }

  .chip-toggles {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .chip-toggle {
    padding: 8px 16px;
    border-radius: 6px;
    border: 1px solid var(--border);
    background: var(--surface2);
    color: var(--text2);
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }
  .chip-toggle:hover:not(.used) { border-color: var(--accent); color: var(--text); }
  .chip-toggle.active { background: var(--green); border-color: var(--green); color: #000; }
  .chip-toggle.used { opacity: 0.35; cursor: not-allowed; text-decoration: line-through; }

  .points-summary {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-top: 16px;
  }
  .points-box {
    padding: 10px 14px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    text-align: center;
    min-width: 110px;
  }
  .points-box .pb-label {
    font-size: 11px;
    color: var(--text2);
    margin-bottom: 2px;
  }
  .points-box .pb-value {
    font-size: 22px;
    font-weight: 700;
  }
  .points-box.highlight { border-color: var(--green); }
  .points-box.highlight .pb-value { color: var(--green); }

  .source-badge {
    display: inline-block;
    padding: 2px 10px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
  }
  .source-badge.recommended { background: rgba(45, 212, 160, 0.15); color: var(--green); }
  .source-badge.user_override { background: rgba(108, 99, 255, 0.15); color: var(--accent); }

  .no-transfer-msg {
    padding: 12px 16px;
    background: var(--surface2);
    border-radius: 8px;
    color: var(--text2);
    font-size: 13px;
    border-left: 3px solid var(--green);
  }

  .transfer-cost-info {
    font-size: 12px;
    padding: 6px 10px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    display: inline-block;
    margin-bottom: 12px;
  }

  .action-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 16px;
  }

  /* Transfer override modal */
  .transfer-modal-overlay {
    position: fixed;
    inset: 0;
    z-index: 9999;
    background: rgba(0, 0, 0, 0.75);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 24px;
  }
  .transfer-modal {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    max-width: 700px;
    width: 100%;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
  }
  .transfer-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
  }
  .transfer-modal-header h3 {
    font-size: 16px;
    font-weight: 600;
  }
  .transfer-modal-close {
    background: none;
    border: none;
    color: var(--text2);
    font-size: 20px;
    cursor: pointer;
  }
  .transfer-modal-close:hover { color: var(--text); }
  .transfer-modal-body {
    padding: 16px 20px;
    overflow-y: auto;
    flex: 1;
  }
  .transfer-modal-step {
    margin-bottom: 16px;
  }
  .transfer-modal-step h4 {
    font-size: 13px;
    color: var(--text2);
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .available-player-list {
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-height: 300px;
    overflow-y: auto;
  }
  .available-player-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: var(--surface2);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s;
    font-size: 13px;
  }
  .available-player-row:hover { background: rgba(108, 99, 255, 0.1); }
  .available-player-row.selected { background: rgba(45, 212, 160, 0.15); border: 1px solid var(--green); }
  .available-player-row .apr-name { font-weight: 600; }
  .available-player-row .apr-meta { font-size: 11px; color: var(--text2); }
  .available-player-row .apr-pts { font-weight: 600; color: var(--green); }
  .modal-squad-player {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: var(--surface2);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s;
    font-size: 13px;
    margin-bottom: 4px;
  }
  .modal-squad-player:hover { background: rgba(248, 113, 113, 0.1); }
  .modal-squad-player.selected { background: rgba(248, 113, 113, 0.15); border: 1px solid var(--red); }
  .modal-squad-player.selected-out { background: rgba(248, 113, 113, 0.15); border: 1px solid var(--red); }

  /* Multi-transfer modal */
  .mt-steps { display: flex; gap: 4px; margin-bottom: 14px; }
  .mt-step {
    flex: 1; text-align: center; padding: 6px 0; font-size: 11px; font-weight: 600;
    letter-spacing: 0.5px; border-radius: 6px; background: var(--surface2); color: var(--text2);
  }
  .mt-step.active { background: var(--accent); color: #fff; }
  .mt-step.done { background: var(--green); color: #fff; }
  .mt-budget-bar {
    display: flex; justify-content: space-between; align-items: center;
    padding: 8px 12px; background: var(--surface2); border-radius: 6px;
    font-size: 13px; margin-bottom: 10px;
  }
  .mt-chips { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 10px; }
  .mt-chip {
    padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; cursor: pointer;
  }
  .mt-chip.out { background: rgba(248, 113, 113, 0.15); color: var(--red); border: 1px solid var(--red); }
  .mt-chip.in { background: rgba(45, 212, 160, 0.15); color: var(--green); border: 1px solid var(--green); }
  .mt-player-list { display: flex; flex-direction: column; gap: 4px; max-height: 300px; overflow-y: auto; }
  .mt-pos-pills { display: flex; gap: 6px; margin-bottom: 10px; }
  .mt-pos-pill {
    padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600;
    background: var(--surface2); color: var(--text2); border: 1px solid var(--border);
    cursor: pointer;
  }
  .mt-pos-pill.active { background: var(--accent); color: #fff; border-color: var(--accent); }
  .mt-confirm-list { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
  .mt-confirm-row {
    display: flex; align-items: center; gap: 10px; padding: 10px 12px;
    background: var(--surface2); border-radius: 8px; font-size: 13px;
  }
  .mt-confirm-player { display: flex; align-items: center; gap: 6px; flex: 1; }
  .mt-confirm-player.out { color: var(--red); }
  .mt-confirm-player.in { color: var(--green); }
  .mt-confirm-summary {
    display: flex; gap: 16px; padding: 10px 12px; background: var(--surface2);
    border-radius: 8px; font-size: 13px;
  }

  .captain-picker {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 6px;
  }
  .captain-option {
    padding: 8px 10px;
    background: var(--surface2);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s;
    font-size: 13px;
    border: 1px solid transparent;
  }
  .captain-option:hover { border-color: var(--accent); }
  .captain-option.selected { border-color: #ef4444; background: rgba(239, 68, 68, 0.1); }
  .captain-option .co-name { font-weight: 600; }
  .captain-option .co-meta { font-size: 11px; color: var(--text2); }
  .captain-option .co-pts { font-weight: 600; color: var(--green); font-size: 12px; }

  .gw-history-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
  }
  .gw-history-table th {
    padding: 8px 12px;
    text-align: left;
    font-size: 11px;
    text-transform: uppercase;
    color: var(--text2);
    border-bottom: 1px solid var(--border);
    background: var(--surface2);
  }
  .gw-history-table td {
    padding: 6px 12px;
    border-bottom: 1px solid var(--border);
  }
  .gw-history-table tr:hover td { background: var(--surface2); }

  .live-squad-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    margin-top: 12px;
  }
  .live-squad-table th {
    padding: 8px 12px;
    text-align: left;
    font-size: 11px;
    text-transform: uppercase;
    color: var(--text2);
    border-bottom: 1px solid var(--border);
    background: var(--surface2);
  }
  .live-squad-table td {
    padding: 6px 12px;
    border-bottom: 1px solid var(--border);
  }
  .live-squad-table tr:hover td { background: var(--surface2); }

  .v2-delete-btn {
    margin-top: 24px;
    padding-top: 16px;
    border-top: 1px solid var(--border);
  }

  /* Help overlay */
  .help-btn {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text2);
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s, border-color 0.2s;
  }
  .help-btn:hover { color: var(--accent2); border-color: var(--accent); }
  .help-overlay {
    position: fixed;
    inset: 0;
    z-index: 9999;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 24px;
  }
  .help-content {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    max-width: 680px;
    width: 100%;
    max-height: 85vh;
    display: flex;
    flex-direction: column;
  }
  .help-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
  }
  .help-header h2 { font-size: 18px; font-weight: 700; }
  .help-close {
    background: none;
    border: none;
    color: var(--text2);
    font-size: 22px;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
  }
  .help-close:hover { color: var(--text); background: var(--surface2); }
  .help-body {
    padding: 20px;
    overflow-y: auto;
    font-size: 13px;
    line-height: 1.7;
    color: var(--text);
  }
  .help-body h3 {
    font-size: 15px;
    font-weight: 700;
    margin: 20px 0 8px 0;
    color: var(--accent2);
  }
  .help-body h3:first-child { margin-top: 0; }
  .help-body p { margin-bottom: 10px; color: var(--text); }
  .help-body ol, .help-body ul { margin: 0 0 10px 20px; }
  .help-body li { margin-bottom: 4px; }
  .help-body strong { color: var(--text); }
  .help-body code {
    background: var(--surface2);
    padding: 1px 5px;
    border-radius: 3px;
    font-size: 12px;
  }
  .inline-help {
    font-size: 12.5px;
    color: var(--text2);
    line-height: 1.6;
    margin-bottom: 16px;
  }

  /* ---- Backtest ---- */
  .backtest-panel { display: none; max-width: 1200px; }
  .backtest-panel.visible { display: block; }

  .bt-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  .bt-controls label { font-size: 13px; color: var(--text2); font-weight: 500; }

  .bt-explainer {
    background: linear-gradient(135deg, var(--surface) 0%, var(--surface2) 100%);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 28px 32px;
    margin-bottom: 24px;
  }
  .bt-explainer-header h3 {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 4px;
    background: linear-gradient(135deg, var(--text) 0%, var(--accent2) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .bt-explainer-subtitle {
    font-size: 14px;
    color: var(--text2);
    margin-bottom: 20px;
    font-style: italic;
  }
  .bt-explainer-body { display: flex; flex-direction: column; gap: 18px; }
  .bt-explainer-section {
    display: flex;
    gap: 14px;
    align-items: flex-start;
  }
  .bt-explainer-icon {
    font-size: 24px;
    flex-shrink: 0;
    width: 36px;
    text-align: center;
    padding-top: 2px;
  }
  .bt-explainer-section strong {
    font-size: 14px;
    color: var(--text);
    display: block;
    margin-bottom: 4px;
  }
  .bt-explainer-section p {
    font-size: 13px;
    color: var(--text2);
    line-height: 1.6;
    margin-bottom: 6px;
  }
  .bt-explainer-section em { color: var(--accent2); font-style: normal; font-weight: 500; }

  .bt-scoreboard {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 0;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px 32px;
    margin-bottom: 24px;
    align-items: center;
  }
  .bt-score-side {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .bt-score-side.right { text-align: right; }
  .bt-score-team {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-weight: 600;
  }
  .bt-score-team.model { color: var(--green); }
  .bt-score-team.ep { color: var(--text2); }
  .bt-score-record {
    font-family: 'Outfit', monospace;
    font-size: 48px;
    font-weight: 800;
    line-height: 1;
  }
  .bt-score-record.win { color: var(--green); }
  .bt-score-record.lose { color: var(--text2); }
  .bt-score-vs {
    font-size: 16px;
    color: var(--text2);
    font-weight: 600;
    padding: 0 24px;
    text-align: center;
  }
  .bt-score-stats {
    display: flex;
    gap: 24px;
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid var(--border);
    grid-column: 1 / -1;
    justify-content: center;
    flex-wrap: wrap;
  }
  .bt-stat-card {
    text-align: center;
    padding: 12px 18px;
    background: var(--surface2);
    border-radius: 8px;
    min-width: 110px;
  }
  .bt-stat-val {
    font-size: 22px;
    font-weight: 700;
    line-height: 1.2;
  }
  .bt-stat-val.good { color: var(--green); }
  .bt-stat-val.neutral { color: var(--text); }
  .bt-stat-val.bad { color: var(--red); }
  .bt-stat-label {
    font-size: 11px;
    color: var(--text2);
    margin-top: 4px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .bt-stat-sub {
    font-size: 11px;
    color: var(--text2);
    margin-top: 2px;
  }
  .bt-verdict {
    grid-column: 1 / -1;
    text-align: center;
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    margin-top: 12px;
  }
  .bt-verdict.positive { background: rgba(45, 212, 160, 0.1); color: var(--green); border: 1px solid rgba(45, 212, 160, 0.2); }
  .bt-verdict.negative { background: rgba(248, 113, 113, 0.1); color: var(--red); border: 1px solid rgba(248, 113, 113, 0.2); }
  .bt-verdict.neutral { background: var(--surface2); color: var(--text2); border: 1px solid var(--border); }

  .bt-timeline-header {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 16px;
  }
  .bt-timeline-header h3 { font-size: 16px; font-weight: 600; white-space: nowrap; }
  .bt-progress-bar {
    flex: 1;
    height: 6px;
    background: var(--surface2);
    border-radius: 3px;
    overflow: hidden;
  }
  .bt-progress-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--accent), var(--green));
    border-radius: 3px;
    transition: width 0.5s ease;
  }

  .bt-timeline {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 10px;
    margin-bottom: 24px;
  }
  .bt-gw-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px;
    transition: transform 0.2s, border-color 0.2s;
    animation: btCardIn 0.35s ease-out;
  }
  .bt-gw-card:hover { transform: translateY(-2px); }
  .bt-gw-card.win { border-left: 3px solid var(--green); }
  .bt-gw-card.lose { border-left: 3px solid var(--red); }
  .bt-gw-card.tie { border-left: 3px solid var(--yellow); }
  @keyframes btCardIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .bt-gw-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .bt-gw-num {
    font-size: 13px;
    font-weight: 700;
    color: var(--text);
  }
  .bt-gw-badge {
    font-size: 10px;
    font-weight: 700;
    padding: 2px 8px;
    border-radius: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .bt-gw-badge.win { background: rgba(45, 212, 160, 0.15); color: var(--green); }
  .bt-gw-badge.lose { background: rgba(248, 113, 113, 0.15); color: var(--red); }
  .bt-gw-badge.tie { background: rgba(251, 191, 36, 0.15); color: var(--yellow); }
  .bt-gw-row {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: var(--text2);
    padding: 2px 0;
  }
  .bt-gw-row .val { color: var(--text); font-weight: 500; }
  .bt-gw-captain {
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid var(--border);
    font-size: 11px;
    color: var(--text2);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .bt-gw-captain .captain-pts { font-weight: 600; }
  .bt-gw-captain .captain-pts.hit { color: var(--green); }
  .bt-gw-captain .captain-pts.miss { color: var(--text2); }

  .bt-section {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 20px;
  }
  .bt-section h3 {
    font-size: 16px;
    font-weight: 700;
    margin-bottom: 16px;
    color: var(--text);
  }
  .bt-section-subtitle {
    font-size: 13px;
    color: var(--text2);
    margin-top: -12px;
    margin-bottom: 16px;
  }

  .bt-pos-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
  }
  .bt-pos-table th {
    text-align: left;
    padding: 8px 12px;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    color: var(--text2);
    border-bottom: 1px solid var(--border);
    font-weight: 600;
  }
  .bt-pos-table td {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
  }
  .bt-pos-table tr:last-child td { border-bottom: none; }
  .bt-better { color: var(--green); font-weight: 600; }
  .bt-worse { color: var(--red); font-weight: 600; }

  .bt-cal-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
    font-size: 13px;
  }
  .bt-cal-label { width: 50px; color: var(--text2); text-align: right; font-weight: 500; }
  .bt-cal-bars { flex: 1; position: relative; height: 28px; }
  .bt-cal-bar {
    position: absolute;
    top: 0;
    height: 12px;
    border-radius: 3px;
    transition: width 0.5s ease;
  }
  .bt-cal-bar.predicted { background: var(--accent); opacity: 0.7; }
  .bt-cal-bar.actual { top: 14px; background: var(--green); opacity: 0.7; }
  .bt-cal-values { width: 140px; font-size: 11px; color: var(--text2); }

  .bt-miss-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
  }
  .bt-miss-col h4 {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 10px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .bt-miss-col.over h4 { color: var(--red); }
  .bt-miss-col.under h4 { color: var(--yellow); }
  .bt-miss-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 0;
    border-bottom: 1px solid var(--border);
    font-size: 12px;
  }
  .bt-miss-item:last-child { border-bottom: none; }
  .bt-miss-name { color: var(--text); font-weight: 500; }
  .bt-miss-gw { color: var(--text2); font-size: 11px; margin-left: 6px; }
  .bt-miss-nums { display: flex; gap: 10px; font-size: 12px; }
  .bt-miss-pred { color: var(--accent2); }
  .bt-miss-actual { color: var(--text); }
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <div class="header-brand">
    <svg class="header-icon" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
      <circle cx="32" cy="32" r="30" fill="#1a1d2e" stroke="url(#ball-grad)" stroke-width="3"/>
      <path d="M32 4 L38 18 L52 14 L48 28 L60 32 L48 36 L52 50 L38 46 L32 60 L26 46 L12 50 L16 36 L4 32 L16 28 L12 14 L26 18 Z" fill="none" stroke="url(#ball-grad)" stroke-width="1.5" opacity="0.5"/>
      <polygon points="32,12 37,24 32,20 27,24" fill="url(#ball-grad)" opacity="0.8"/>
      <polygon points="32,52 37,40 32,44 27,40" fill="url(#ball-grad)" opacity="0.8"/>
      <polygon points="12,32 24,27 20,32 24,37" fill="url(#ball-grad)" opacity="0.8"/>
      <polygon points="52,32 40,27 44,32 40,37" fill="url(#ball-grad)" opacity="0.8"/>
      <circle cx="32" cy="32" r="6" fill="none" stroke="url(#ball-grad)" stroke-width="1.5"/>
      <text x="32" y="33" text-anchor="middle" dominant-baseline="central" font-family="Impact,Arial Black,sans-serif" font-size="48" font-weight="bold" fill="#2dd4a0">G</text>
      <defs>
        <linearGradient id="ball-grad" x1="0" y1="0" x2="64" y2="64">
          <stop offset="0%" stop-color="#6c63ff"/>
          <stop offset="100%" stop-color="#2dd4a0"/>
        </linearGradient>
      </defs>
    </svg>
    <h1>FPL Gaffer - the brAIn</h1>
    <button class="help-btn" onclick="openHelp()" title="How to use">?</button>
  </div>
  <div style="display:flex;align-items:center;gap:10px">
    <span class="cache-badge" id="gwBadge" style="font-weight:600"></span>
    <span class="cache-badge" id="cacheBadge">Loading...</span>
  </div>
</div>

<!-- Action Bar -->
<div class="action-bar">
  <span class="bar-icon" title="Tools & Analysis">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="url(#gearGrad)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <defs><linearGradient id="gearGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#f39c12"/><stop offset="100%" stop-color="#e74c3c"/></linearGradient></defs>
      <circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/>
    </svg>
  </span>
  <button class="btn" id="btnRefresh" onclick="refreshData()"> Get Latest Data</button>
  <button class="btn btn-primary" id="btnTrain" onclick="trainModels()"> Train Models</button>
  <div style="border-left:1px solid var(--border);height:24px;margin:0 8px"></div>
  <button class="btn" id="btnBacktest" onclick="switchTab({dataset:{view:'backtest'},classList:{add:function(){},remove:function(){}}});document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));"> Backtest</button>
  <div style="border-left:1px solid var(--border);height:24px;margin:0 8px"></div>
  <button class="btn" id="btnButHow" onclick="switchTab({dataset:{view:'buthow'},classList:{add:function(){},remove:function(){}}});document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));"> but, how?</button>
  <div class="status-area">
    <div class="status-dot" id="statusDot"></div>
    <span class="status-text" id="statusText">Idle</span>
  </div>
</div>

<!-- Progress -->
<div class="progress-container" id="progressContainer">
  <div class="progress-header" onclick="toggleProgressLog()">
    <div class="progress-header-left">
      <div class="progress-spinner" id="progressSpinner"></div>
      <span class="progress-msg" id="progressMsg">Starting...</span>
    </div>
    <span class="progress-chevron" id="progressChevron"></span>
  </div>
  <div class="progress-log" id="progressLog"></div>
</div>

<!-- View Tabs -->
<div class="tabs">
  <span class="bar-icon" title="Management" style="margin-right:4px">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="url(#caseGrad)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <defs><linearGradient id="caseGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#00b894"/><stop offset="100%" stop-color="#0984e3"/></linearGradient></defs>
      <rect x="2" y="7" width="20" height="14" rx="2" ry="2"/><path d="M16 7V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2"/><line x1="12" y1="12" x2="12" y2="16"/><line x1="2" y1="12" x2="22" y2="12"/>
    </svg>
  </span>
  <div class="tab active" data-view="myteam" onclick="switchTab(this)"> My Team</div>
  <div class="tab" data-view="predictions" onclick="switchTab(this)"> Predictions</div>
  <div class="tab" data-view="bestteam" onclick="switchTab(this)"> Best Team</div>
  <div class="tab" data-view="gwcompare" onclick="switchTab(this)"> GW Compare</div>
  <div class="tab" data-view="pltable" onclick="switchTab(this)"> PL Table</div>
  <div class="tab" data-view="gwscores" onclick="switchTab(this)"> GW Scores</div>
  <div class="tab" data-view="teamform" onclick="switchTab(this)"> Form</div>
  <div class="tab" data-view="prices" onclick="switchTab(this)"> Prices</div>
  <div class="tab" data-view="players" onclick="switchTab(this)"> Players</div>
  <div class="tab" data-view="monsters" onclick="switchTab(this)"> Monsters</div>
  <div class="tab" data-view="season" onclick="switchTab(this)"> Season</div>
</div>

<!-- Predictions Panel -->
<div class="content" id="predictionsPanel" style="display:none">
  <div class="controls-row">
    <div class="pos-filters">
      <button class="pos-btn active" data-pos="ALL" onclick="filterPosition(this)">All</button>
      <button class="pos-btn" data-pos="GKP" onclick="filterPosition(this)">GKP</button>
      <button class="pos-btn" data-pos="DEF" onclick="filterPosition(this)">DEF</button>
      <button class="pos-btn" data-pos="MID" onclick="filterPosition(this)">MID</button>
      <button class="pos-btn" data-pos="FWD" onclick="filterPosition(this)">FWD</button>
    </div>
    <input type="text" class="search-box" id="searchBox" placeholder="Search players..." oninput="debounceSearch()">
    <span class="player-count" id="playerCount"></span>
  </div>
  <div class="table-wrap" id="tableWrap">
    <table>
      <thead id="tableHead"></thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<!-- Best Team Panel -->
<div class="content team-panel" id="bestTeamPanel">
  <div class="team-controls">
    <label>Budget:</label>
    <input type="number" class="budget-input" id="budgetInput" value="100.0" step="0.5" min="50" max="200">
    <label>Optimise for:</label>
    <select class="target-select" id="targetSelect">
      <option value="predicted_next_gw_points">Next GW Points</option>
      <option value="predicted_next_3gw_points">Next 3 GW Points</option>
    </select>
    <button class="btn btn-primary" onclick="pickBestTeam()">Pick Team</button>
  </div>
  <div class="team-summary" id="teamSummary"></div>
  <div id="squadDisplay">
    <div class="empty-state"><h3>Pick Your Best Team</h3><p>Set a budget above and click "Pick Team" to find the optimal squad.</p></div>
  </div>
</div>

<!-- GW Compare Panel -->
<div class="content compare-panel" id="gwComparePanel">
  <div class="compare-controls">
    <label>Manager ID:</label>
    <input type="number" class="budget-input" id="cmpManagerId" value="" style="width:120px">
    <label>Gameweek:</label>
    <input type="number" class="bt-input" id="cmpGW" value="" min="1" max="38" placeholder="GW">
    <button class="btn btn-primary" onclick="runGWCompare()">Compare</button>
  </div>
  <div class="compare-summary" id="cmpSummary"></div>
  <div id="cmpContent">
    <div class="empty-state"><h3>GW Compare</h3><p>Enter your Manager ID and a past gameweek to see your actual team vs the highest-scoring possible team.</p></div>
  </div>
</div>

<!-- Backtest Panel -->
<div class="content backtest-panel" id="backtestPanel">
  <div class="bt-controls">
    <label>From GW:</label>
    <input type="number" class="budget-input" id="btStartGW" value="9" min="2" max="37" style="width:70px">
    <label>To GW:</label>
    <input type="number" class="budget-input" id="btEndGW" value="26" min="3" max="38" style="width:70px">
    <button class="btn btn-primary" id="btnRunBacktest" onclick="runBacktest()">Run Backtest</button>
  </div>

  <!-- Methodology explainer -->
  <div class="bt-explainer" id="btExplainer">
    <div class="bt-explainer-header">
      <h3>How the Backtest Works</h3>
      <p class="bt-explainer-subtitle">A time machine for your prediction model</p>
    </div>
    <div class="bt-explainer-body">
      <div class="bt-explainer-section">
        <div class="bt-explainer-icon"></div>
        <div>
          <strong>Walk-Forward Testing</strong>
          <p>For each past gameweek, we go back in time. The model is retrained from scratch using <em>only data that was available before that gameweek</em> &mdash; no peeking at the future. Then it predicts the upcoming GW, and we compare those predictions against what actually happened. This is repeated for every gameweek in your range.</p>
        </div>
      </div>
      <div class="bt-explainer-section">
        <div class="bt-explainer-icon"></div>
        <div>
          <strong>What We Measure</strong>
          <p><strong>Prediction Accuracy (MAE)</strong> &mdash; Mean Absolute Error. If the model predicts a player will score 5 points and he scores 3, the error is 2. Lower is better. We compare our model's MAE against FPL's own prediction system (ep_next) and two simple baselines.</p>
          <p><strong>Player Ranking (Spearman)</strong> &mdash; How well does the model order players from best to worst? A score of 1.0 would mean perfect ranking. Even if exact point predictions are slightly off, good ranking means you're picking the right players.</p>
          <p><strong>Top-11 Points</strong> &mdash; If you picked the 11 highest-predicted players each week, how many actual points would they have scored? Compared against the hindsight-best 11 (the theoretical maximum).</p>
          <p><strong>Captain Accuracy</strong> &mdash; How often does the model's captain pick finish in the actual top 3 scorers?</p>
        </div>
      </div>
      <div class="bt-explainer-section">
        <div class="bt-explainer-icon"></div>
        <div>
          <strong>How to Read the Results</strong>
          <p>The model is tested against four rivals: FPL's built-in prediction (ep_next), a player's recent form, their last-3-gameweek average, and the position average. Every GW is a head-to-head matchup. The scoreboard shows the win/loss record.</p>
          <p>A good model should: beat FPL's ep_next on MAE most weeks, rank players well (Spearman &gt; 0.6), and capture 85%+ of the theoretical best team's points.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Results area (hidden until backtest runs) -->
  <div id="btResults" style="display:none">
    <!-- Scoreboard -->
    <div class="bt-scoreboard" id="btScoreboard"></div>

    <!-- GW Timeline -->
    <div class="bt-timeline-header" id="btTimelineHeader" style="display:none">
      <h3>Gameweek Timeline</h3>
      <div class="bt-progress-bar"><div class="bt-progress-fill" id="btProgressFill"></div></div>
    </div>
    <div class="bt-timeline" id="btTimeline"></div>

    <!-- Deep Dive (appears after completion) -->
    <div id="btDeepDive" style="display:none">
      <div class="bt-section" id="btPositionBreakdown"></div>
      <div class="bt-section" id="btCalibration"></div>
      <div class="bt-section" id="btCaptainAnalysis"></div>
      <div class="bt-section" id="btBiggestMisses"></div>
      <div class="bt-section" id="btThreeGW"></div>
    </div>
  </div>
</div>

<!-- My Team Panel -->
<div class="content team-panel visible" id="myTeamPanel">
  <div class="team-controls">
    <label>Manager ID:</label>
    <input type="number" class="budget-input" id="managerIdInput" value="904686" style="width:120px">
    <button class="btn btn-primary" onclick="importMyTeam()">Import Squad</button>
    <span id="myTeamManagerInfo" style="font-size:13px;color:var(--text2);margin-left:12px"></span>
  </div>
  <div class="team-summary" id="myTeamSummary"></div>
  <div id="myTeamDisplay">
    <div class="empty-state"><h3>Import Your FPL Team</h3><p>Enter your FPL Manager ID above and click "Import Squad" to see your current team with predictions.</p></div>
  </div>
  <!-- Transfer Recommendations (visible after squad import) -->
  <div id="transferSection" style="display:none">
    <div class="transfer-controls">
      <label style="font-weight:600;color:var(--text);font-size:14px">Transfer Recommendations</label>
      <label>Max Transfers:</label>
      <input type="number" class="budget-input" id="transferCount" value="1" min="1" max="5" style="width:60px">
      <label>Optimise for:</label>
      <select class="target-select" id="transferTarget">
        <option value="predicted_next_gw_points">Next GW Points</option>
        <option value="predicted_next_3gw_points">Next 3 GW Points</option>
      </select>
      <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
        <input type="checkbox" id="transferWildcard" style="accent-color:var(--accent)" onchange="toggleWildcard()"> Wildcard
      </label>
      <button class="btn btn-primary" id="btnFindTransfers" onclick="findTransfers()">Find Transfers</button>
    </div>
    <div id="transferResults"></div>
  </div>
</div>

<!-- PL Table Panel -->
<div class="content pltable-panel" id="plTablePanel">
  <div style="max-height:calc(100vh - 180px); overflow-y:auto">
    <table class="pl-table" id="plTable">
      <thead>
        <tr>
          <th class="num">#</th>
          <th>Team</th>
          <th class="num">P</th>
          <th class="num">W</th>
          <th class="num">D</th>
          <th class="num">L</th>
          <th class="num">GF</th>
          <th class="num">GA</th>
          <th class="num">GD</th>
          <th class="num">Pts</th>
          <th>Form</th>
        </tr>
      </thead>
      <tbody id="plTableBody"></tbody>
    </table>
  </div>
</div>

<!-- GW Scores Panel -->
<div class="content gwscores-panel" id="gwScoresPanel">
  <div class="controls-row">
    <label style="font-weight:600">Gameweek:</label>
    <input type="number" class="budget-input" id="gwScoresInput" value="" min="1" max="38" style="width:70px">
    <button class="btn btn-primary" onclick="loadGWScores()">Load</button>
    <span id="gwScoresStatus" style="font-size:12px;color:var(--text2)"></span>
  </div>
  <div class="scores-grid" id="gwScoresGrid">
    <div class="empty-state"><h3>GW Scores</h3><p>Select a gameweek above and click "Load" to see match results.</p></div>
  </div>
</div>

<!-- Team Form Panel -->
<div class="content teamform-panel" id="teamFormPanel">
  <div class="controls-row" id="formControls" style="display:none">
    <label style="font-weight:600">GW Range:</label>
    <input type="number" class="budget-input" id="formGwFrom" min="1" max="38" style="width:60px">
    <span style="color:var(--text2)">to</span>
    <input type="number" class="budget-input" id="formGwTo" min="1" max="38" style="width:60px">
    <button class="btn btn-primary" onclick="applyFormRange()">Apply</button>
    <button class="btn" onclick="resetFormRange()">All GWs</button>
    <span id="formRangeLabel" style="font-size:12px;color:var(--text2)"></span>
  </div>
  <div style="max-height:calc(100vh - 220px); overflow-y:auto">
    <table class="form-table" id="formTable">
      <thead id="formTableHead"></thead>
      <tbody id="formTableBody"></tbody>
    </table>
  </div>
  <div class="empty-state" id="formEmptyState"><h3>Team Form</h3><p>Loading...</p></div>
</div>

<!-- Match Detail Modal -->
<div class="match-modal-overlay" id="matchModal" onclick="if(event.target===this)closeMatchModal()">
  <div class="match-modal-content">
    <div class="match-modal-close"><button onclick="closeMatchModal()">&times;</button></div>
    <div id="matchModalBody"></div>
  </div>
</div>

<!-- "but, how?" Explainer Panel -->
<div class="content wtf-panel" id="wtfPanel">
  <div class="wtf-breadcrumb" id="wtfBreadcrumb"></div>
  <div id="wtfContent">
    <div class="wtf-intro">
      <p>Ever wondered how the model decides that Salah will score 8 points? <strong>Pick a team, pick a player</strong>,
      and we'll show you exactly how every model arrived at that number &mdash; from the raw features
      to the final prediction.</p>
    </div>
    <div class="empty-state"><p>Loading teams...</p></div>
  </div>
</div>

<!-- Prices Panel -->
<div class="content" id="pricesPanel" style="display:none">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
    <h2>Price Tracker</h2>
    <button class="btn btn-primary" onclick="updatePrices()">Update Prices</button>
  </div>
  <div id="priceAlertsContainer"></div>
  <h3 style="margin-top:20px">Squad Prices</h3>
  <div id="priceTableContainer"></div>
  <h3 style="margin-top:20px">Price Predictions</h3>
  <div id="pricePredictionsDisplay"></div>
  <h3 style="margin-top:20px">Watchlist</h3>
  <div style="position:relative;margin-bottom:12px">
    <input id="watchlistSearch" type="text" placeholder="Search player to add..." oninput="debounceWatchlistSearch()" style="width:100%;padding:8px 12px;background:var(--surface2);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:13px">
    <div id="watchlistDropdown" style="display:none;position:absolute;top:100%;left:0;right:0;background:var(--surface);border:1px solid var(--border);border-radius:6px;max-height:200px;overflow-y:auto;z-index:100"></div>
  </div>
  <div id="watchlistContainer"></div>
</div>

<!-- Players Panel -->
<div class="content players-panel" id="playersPanel">
  <div class="players-breadcrumb" id="playersBreadcrumb"></div>
  <div class="controls-row" id="playersGwControls" style="display:none">
    <label style="font-weight:600">GW Range:</label>
    <input type="number" class="budget-input" id="playersGwFrom" min="1" max="38" style="width:60px">
    <span style="color:var(--text2)">to</span>
    <input type="number" class="budget-input" id="playersGwTo" min="1" max="38" style="width:60px">
    <button class="btn btn-primary" onclick="applyPlayersGwRange()">Apply</button>
    <button class="btn" onclick="resetPlayersGwRange()">All GWs</button>
    <span id="playersRangeLabel" style="font-size:12px;color:var(--text2)"></span>
  </div>
  <div id="playersContent">
    <div class="empty-state"><h3>Players</h3><p>Loading...</p></div>
  </div>
</div>

<!-- Monsters Panel -->
<div class="content monsters-panel" id="monstersPanel">
  <div id="monstersContent">
    <div class="empty-state"><h3>Loading Monsters...</h3><p>Identifying the most dangerous players in the game.</p></div>
  </div>
</div>

<!-- Season Panel -->
<div class="content season-panel" id="seasonPanel">
  <!-- Init form (shown when no active season) -->
  <div id="seasonInitSection">
    <div class="season-init-form">
      <h3>Start Season Tracking</h3>
      <p>Enter your FPL Manager ID to import your season history and start receiving weekly recommendations.</p>
      <input type="number" id="seasonManagerId" placeholder="Manager ID (e.g. 904686)">
      <button class="btn btn-primary" style="width:100%" onclick="initSeasonV2()">Start Season</button>
      <button class="btn" style="width:100%;margin-top:8px" onclick="deleteSeasonV2()">Delete Season Data</button>
    </div>
  </div>

  <!-- Pre-Season Setup (shown when season hasn't started) -->
  <div id="preSeasonPanel" style="display:none">
    <div style="background:linear-gradient(135deg, var(--surface) 0%, #1a1d2e 100%);border:1px solid var(--accent);border-radius:12px;padding:24px;margin-bottom:20px">
      <h3 style="font-size:18px;margin-bottom:8px;color:var(--accent)">Pre-Season Setup</h3>
      <p style="color:var(--text2);margin-bottom:16px">The FPL season hasn't started yet. Generate an optimal initial squad based on player prices and last season's data.</p>
      <button class="btn btn-primary" onclick="generatePreseasonPlan()" style="margin-right:8px">Generate Initial Squad</button>
      <span id="preseasonStatus" style="font-size:12px;color:var(--text2)"></span>
    </div>
    <div id="preseasonSquadDisplay"></div>
    <div id="preseasonChipPlan"></div>
  </div>

  <!-- Phase-aware GW view (NEW v2) -->
  <div id="seasonGWView" style="display:none;">
    <!-- Header bar: GW number, phase badge, deadline countdown -->
    <div class="gw-header" id="gwHeader"></div>

    <!-- Phase content (rendered dynamically) -->
    <div id="gwPhaseContent"></div>

    <!-- History section (always shown when data exists) -->
    <div id="gwHistory" style="margin-top:24px;"></div>

    <!-- Delete season -->
    <div class="v2-delete-btn">
      <button class="btn" onclick="deleteSeasonV2()" style="font-size:11px;padding:4px 10px;">Delete Season Data</button>
    </div>
  </div>
</div>

<script>
// ---------------------------------------------------------------------------
// State
// ---------------------------------------------------------------------------
let players = [];
let currentPosition = 'ALL';
let currentSearch = '';
let currentSort = 'predicted_next_gw_points';
let sortAsc = false;
let searchTimer = null;
let taskRunning = false;
let nextGW = null;
let lastActionPlanData = null;
let lockedGWSquad = null;
const WALDO_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 110 140" width="110" height="140">
  <rect width="110" height="140" fill="#1a1a2e"/>
  <circle cx="55" cy="52" r="22" fill="#ffe0bd"/>
  <rect x="30" y="20" rx="12" ry="8" width="50" height="24" fill="#cc0000"/>
  <rect x="30" y="24" width="50" height="4" fill="white"/>
  <rect x="30" y="32" width="50" height="4" fill="white"/>
  <circle cx="55" cy="10" r="6" fill="#cc0000"/>
  <circle cx="46" cy="50" r="6" stroke="#333" stroke-width="2" fill="none"/>
  <circle cx="64" cy="50" r="6" stroke="#333" stroke-width="2" fill="none"/>
  <line x1="52" y1="50" x2="58" y2="50" stroke="#333" stroke-width="2"/>
  <line x1="34" y1="50" x2="40" y2="50" stroke="#333" stroke-width="2"/>
  <line x1="70" y1="50" x2="76" y2="50" stroke="#333" stroke-width="2"/>
  <path d="M48 62 Q55 68 62 62" stroke="#333" stroke-width="1.5" fill="none"/>
  <rect x="35" y="74" width="40" height="50" rx="4" fill="#cc0000"/>
  <rect x="35" y="78" width="40" height="5" fill="white"/>
  <rect x="35" y="88" width="40" height="5" fill="white"/>
  <rect x="35" y="98" width="40" height="5" fill="white"/>
  <rect x="35" y="108" width="40" height="5" fill="white"/>
  <text x="55" y="134" text-anchor="middle" font-size="10" fill="#888" font-family="sans-serif">Where am I?</text>
</svg>`;
const WALDO_DATA_URI = 'data:image/svg+xml,' + encodeURIComponent(WALDO_SVG);

function getColumns() {
  const gwLabel = nextGW ? `GW${nextGW}` : 'GW';
  const gw3Label = nextGW ? `GW${nextGW}-${nextGW+2}` : '3GW';
  return [
    { key: 'web_name',                  label: 'Name',           fmt: 'text' },
    { key: 'position',                  label: 'Pos',            fmt: 'pos' },
    { key: 'team',                      label: 'Team',           fmt: 'text' },
    { key: 'cost',                      label: 'Cost',           fmt: 'num1' },
    { key: 'player_form',               label: 'Form',           fmt: 'num1' },
    { key: 'event_minutes',             label: nextGW ? `Last GW Mins (${nextGW-1})` : 'Last GW Mins', fmt: 'num0' },
    { key: 'event_points',              label: nextGW ? `Last GW (${nextGW-1})` : 'Last GW', fmt: 'num0' },
    { key: 'total_points',              label: 'Total',            fmt: 'num0' },
    { key: 'predicted_next_gw_points',  label: `Pred ${gwLabel}`,  fmt: 'num2' },
    { key: 'predicted_next_3gw_points', label: `Pred ${gw3Label}`, fmt: 'num2' },
    { key: 'fdr',                       label: 'FDR',            fmt: 'fdr' },
    { key: 'is_home',                   label: 'H/A',            fmt: 'home' },
    { key: 'ep_next',                   label: 'EP Next',        fmt: 'num1' },
    { key: 'next_3_fixtures',           label: 'Next 3',         fmt: 'fixtures' },
  ];
}

// ---------------------------------------------------------------------------
// SSE connection
// ---------------------------------------------------------------------------
function connectSSE() {
  const es = new EventSource('/api/status');
  es.onmessage = function(e) {
    const d = JSON.parse(e.data);
    const msg = d.message;
    const evt = d.event;

    document.getElementById('statusText').textContent = msg;

    if (evt === 'task_start') {
      setTaskRunning(true);
    } else if (evt === 'task_done' || evt === 'task_error') {
      const spinner = document.getElementById('progressSpinner');
      const pmsg = document.getElementById('progressMsg');
      if (evt === 'task_done') {
        pmsg.textContent = 'Complete';
        spinner.className = 'progress-spinner done';
      } else {
        pmsg.textContent = 'Error  click to see details';
        spinner.className = 'progress-spinner error';
        // Auto-expand log on error
        document.getElementById('progressContainer').classList.add('expanded');
      }
      setTaskRunning(false);
      if (evt === 'task_done') {
        // Brief delay to ensure file writes are flushed before reloading
        setTimeout(() => {
          loadPredictions();
          loadModelInfo(true);
          if (typeof seasonOnTaskDone === 'function') seasonOnTaskDone();
          if (backtestGWResults.length > 0) handleBacktestDone();
        }, 500);
      }
    } else if (evt === 'backtest_gw') {
      try {
        const gwData = JSON.parse(msg);
        if (gwData && gwData.gw) handleBacktestGW(gwData);
      } catch(e) { /* not JSON, ignore */ }
    } else if (evt === 'plan_invalidated' || evt === 'alert') {
      if (typeof loadSeasonV2 === 'function') {
        const sp = document.getElementById('seasonPanel');
        if (sp && sp.classList.contains('visible')) loadSeasonV2();
      }
    } else if (evt === 'progress') {
      appendLog(msg);
    }
  };
  es.onerror = function() {
    document.getElementById('statusText').textContent = 'Disconnected  retrying...';
    setTimeout(connectSSE, 3000);
    es.close();
  };
}

function setTaskRunning(running) {
  taskRunning = running;
  const dot = document.getElementById('statusDot');
  const container = document.getElementById('progressContainer');
  const log = document.getElementById('progressLog');
  const btns = [document.getElementById('btnRefresh'), document.getElementById('btnTrain'), document.getElementById('btnRunBacktest')];

  if (running) {
    dot.classList.add('running');
    container.classList.add('visible');
    container.classList.remove('expanded');
    log.innerHTML = '';
    document.getElementById('progressMsg').textContent = 'Starting...';
    document.getElementById('progressSpinner').className = 'progress-spinner';
    btns.forEach(b => b.disabled = true);
  } else {
    dot.classList.remove('running');
    // Keep container visible so user sees done/error state; hide on next task start
    btns.forEach(b => b.disabled = false);
  }
}

function appendLog(msg) {
  const log = document.getElementById('progressLog');
  const line = document.createElement('div');
  line.textContent = msg;
  log.appendChild(line);
  log.scrollTop = log.scrollHeight;
  document.getElementById('progressMsg').textContent = msg;
}

function toggleProgressLog() {
  document.getElementById('progressContainer').classList.toggle('expanded');
  const log = document.getElementById('progressLog');
  log.scrollTop = log.scrollHeight;
}

function friendlyError(msg, fallbackTitle) {
  const m = (msg || '').toLowerCase();
  if (m.includes('no cached data') || m.includes('refresh data') || m.includes('bootstrap'))
    return '<div class="empty-state"><h3>No Data Yet</h3><p>Click <b>Get Latest Data</b> above to fetch FPL data first.</p></div>';
  if (m.includes('no predictions') || m.includes('train model'))
    return '<div class="empty-state"><h3>Models Not Trained</h3><p>Click <b>Train Models</b> above to generate predictions.</p></div>';
  if (m.includes('manager') && (m.includes('required') || m.includes('no current')))
    return '<div class="empty-state"><h3>Import Your Team</h3><p>Enter your FPL Manager ID and click <b>Import Squad</b> first.</p></div>';
  if (m.includes('no active season') || m.includes('initialize season'))
    return '<div class="empty-state"><h3>Start Season Tracking</h3><p>Go to the <b>Season</b> tab and initialize your season first.</p></div>';
  return `<div class="empty-state"><h3>${fallbackTitle || 'Error'}</h3><p>${msg}</p></div>`;
}

// ---------------------------------------------------------------------------
// Actions
// ---------------------------------------------------------------------------
function refreshData() {
  plTableLoaded = false;
  fetch('/api/refresh-data', { method: 'POST' }).then(r => r.json()).then(d => {
    if (d.error) alert(d.error);
  });
}

function trainModels() {
  fetch('/api/train', { method: 'POST' }).then(r => r.json()).then(d => {
    if (d.error) alert(d.error);
  });
}

// ---------------------------------------------------------------------------
// Load data
// ---------------------------------------------------------------------------
function loadPredictions() {
  const params = new URLSearchParams();
  if (currentPosition !== 'ALL') params.set('position', currentPosition);
  if (currentSearch) params.set('search', currentSearch);
  params.set('sort', currentSort);
  params.set('dir', sortAsc ? 'asc' : 'desc');

  fetch('/api/predictions?' + params).then(r => r.json()).then(d => {
    if (d.error && d.players.length === 0) {
      document.getElementById('tableWrap').innerHTML =
        '<div class="empty-state"><h3>No Predictions Yet</h3><p>Click <b>Get Latest Data</b> then <b>Train Models</b> above to generate predictions. If you\'ve already done this, click  to refresh.</p></div>';
      document.getElementById('playerCount').textContent = '';
      return;
    }
    players = d.players;
    renderTable();
  });
}

function loadModelInfo(afterTask) {
  fetch('/api/model-info').then(r => r.json()).then(d => {
    // GW badge
    const gwBadge = document.getElementById('gwBadge');
    if (d.next_gw) {
      nextGW = d.next_gw;
      gwBadge.textContent = `Predicting GW${nextGW}`;
      gwBadge.style.color = 'var(--accent)';
      // Set GW Compare default to previous GW
      const cmpGW = document.getElementById('cmpGW');
      if (cmpGW && !cmpGW.value) cmpGW.value = Math.max(1, nextGW - 1);
      // Update best-team dropdown labels
      const sel = document.getElementById('targetSelect');
      sel.options[0].text = `GW${nextGW} Points`;
      sel.options[1].text = `GW${nextGW}-${nextGW+2} Points`;
      // Re-render table if already loaded to update column headers
      if (players.length) renderTable();
    }

    // Season info
    window._currentSeason = d.current_season || '2025-2026';
    window._availableSeasons = d.available_seasons || ['2024-2025', '2025-2026'];

    // Cache badge
    const badge = document.getElementById('cacheBadge');
    const hasData = d.cache_age_seconds !== null;
    const hasModels = d.models && d.models.some(m => m.exists);
    if (hasData) {
      const hrs = (d.cache_age_seconds / 3600).toFixed(1);
      const fresh = d.cache_age_seconds < d.cache_max_age_seconds;
      badge.textContent = `Data: ${hrs}h ago`;
      badge.className = 'cache-badge ' + (fresh ? 'fresh' : 'stale');
    } else {
      badge.textContent = 'No data yet';
    }

    // Update My Team guidance based on state, auto-import once ready
    if (afterTask) {
      const display = document.getElementById('myTeamDisplay');
      const isShowingGuidance = display.querySelector('.empty-state');
      if (hasData && hasModels) {
        const savedId = localStorage.getItem('fpl_manager_id');
        if (savedId) importMyTeam();
      } else if (hasData && !hasModels && isShowingGuidance) {
        display.innerHTML =
          '<div class="empty-state"><h3>Data Loaded</h3><p>Next, click <b>Train Models</b> above to generate predictions.</p></div>';
      }
    }

  });
}

// ---------------------------------------------------------------------------
// Table rendering
// ---------------------------------------------------------------------------
function renderTable() {
  const cols = getColumns();
  // Header
  const thead = document.getElementById('tableHead');
  thead.innerHTML = '';
  const tr = document.createElement('tr');
  cols.forEach(col => {
    const th = document.createElement('th');
    th.textContent = col.label;
    th.dataset.key = col.key;
    if (col.key === currentSort) {
      th.classList.add('sorted');
      const arrow = document.createElement('span');
      arrow.className = 'sort-arrow';
      arrow.textContent = sortAsc ? ' \u25B2' : ' \u25BC';
      th.appendChild(arrow);
    }
    th.onclick = () => sortBy(col.key);
    tr.appendChild(th);
  });
  thead.appendChild(tr);

  // Body
  const tbody = document.getElementById('tableBody');
  tbody.innerHTML = '';

  players.forEach(p => {
    const row = document.createElement('tr');
    cols.forEach(col => {
      const td = document.createElement('td');
      const val = p[col.key];
      switch(col.fmt) {
        case 'pos':
          td.innerHTML = `<span class="pos-tag ${val || ''}">${val || '-'}</span>`;
          break;
        case 'fdr':
          if (val != null) {
            const fdrVal = Math.round(val);
            td.innerHTML = `<span class="fdr-cell fdr-${fdrVal}">${val}</span>`;
          } else {
            td.textContent = '-';
          }
          break;
        case 'home':
          if (val == null) {
            td.textContent = '-';
          } else if (val == 1 || val === true) {
            td.innerHTML = '<span class="home-badge home">H</span>';
          } else {
            td.innerHTML = '<span class="home-badge away">A</span>';
          }
          break;
        case 'num0':
          td.textContent = val != null ? Number(val).toFixed(0) : '-';
          break;
        case 'num1':
          td.textContent = val != null ? Number(val).toFixed(1) : '-';
          break;
        case 'num2':
          td.textContent = val != null ? Number(val).toFixed(2) : '-';
          break;
        case 'fixtures':
          td.style.whiteSpace = 'nowrap';
          td.style.fontSize = '12px';
          td.textContent = val || '-';
          break;
        default:
          td.textContent = val != null ? val : '-';
      }
      row.appendChild(td);
    });
    tbody.appendChild(row);
  });

  document.getElementById('playerCount').textContent = `${players.length} players`;
}

// ---------------------------------------------------------------------------
// PL Table
// ---------------------------------------------------------------------------
let plTableLoaded = false;
function loadPLTable() {
  if (plTableLoaded) return;
  const tbody = document.getElementById('plTableBody');
  tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;padding:24px;color:var(--text2)">Loading...</td></tr>';

  fetch('/api/pl-table').then(r => r.json()).then(d => {
    if (d.error) {
      const m = (d.error || '').toLowerCase();
      const msg = (m.includes('no cached') || m.includes('bootstrap')) ? 'Click <b>Get Latest Data</b> above first.' : d.error;
      tbody.innerHTML = `<tr><td colspan="11" style="text-align:center;padding:24px;color:var(--text2)">${msg}</td></tr>`;
      return;
    }
    plTableLoaded = true;
    tbody.innerHTML = '';
    d.table.forEach(row => {
      const tr = document.createElement('tr');
      // Position highlight class
      let posClass = '';
      if (row.pos <= 4) posClass = 'pos-cl';
      else if (row.pos <= 6) posClass = 'pos-el';
      else if (row.pos >= 18) posClass = 'pos-rel';

      const formHtml = (row.form || []).map(f => {
        const cls = f === 'W' ? 'form-w' : f === 'D' ? 'form-d' : 'form-l';
        return `<span class="form-dot ${cls}">${f}</span>`;
      }).join('');

      tr.innerHTML = `
        <td class="num ${posClass}">${row.pos}</td>
        <td class="team-name">${row.short} <span style="color:var(--text2);font-weight:400;font-size:12px">${row.team}</span></td>
        <td class="num">${row.p}</td>
        <td class="num">${row.w}</td>
        <td class="num">${row.d}</td>
        <td class="num">${row.l}</td>
        <td class="num">${row.gf}</td>
        <td class="num">${row.ga}</td>
        <td class="num" style="font-weight:600;color:${row.gd > 0 ? 'var(--green)' : row.gd < 0 ? 'var(--red)' : 'var(--text2)'}">${row.gd > 0 ? '+' : ''}${row.gd}</td>
        <td class="num" style="font-weight:700;font-size:14px">${row.points}</td>
        <td><div class="form-dots">${formHtml}</div></td>
      `;
      tbody.appendChild(tr);
    });
  }).catch(err => {
    tbody.innerHTML = `<tr><td colspan="11" style="text-align:center;padding:24px;color:var(--red)">Error: ${err.message}</td></tr>`;
  });
}

// ---------------------------------------------------------------------------
// Shared: Match Card HTML renderer (used by GW Scores + Team Form modal)
// ---------------------------------------------------------------------------
function renderMatchCardHtml(m) {
  let scoreHtml;
  if (m.finished || m.started) {
    scoreHtml = `<span class="score">${m.home_score ?? '?'} - ${m.away_score ?? '?'}</span>`;
  } else {
    scoreHtml = '<span class="vs">vs</span>';
  }

  let koText = '';
  if (m.kickoff) {
    const dt = new Date(m.kickoff);
    koText = dt.toLocaleDateString('en-GB', {weekday:'short', day:'numeric', month:'short'}) + ' ' +
             dt.toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
  }

  let eventsHtml = '';
  if (m.finished || m.started) {
    const allGoals = [];
    (m.goals?.home || []).forEach(g => {
      const cnt = g.count > 1 ? ` x${g.count}` : '';
      allGoals.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.home_short}</span> ${g.player}${cnt}</div>`);
    });
    (m.goals?.away || []).forEach(g => {
      const cnt = g.count > 1 ? ` x${g.count}` : '';
      allGoals.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.away_short}</span> ${g.player}${cnt}</div>`);
    });
    (m.own_goals?.home || []).forEach(g => {
      allGoals.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.home_short}</span> ${g.player} <span style="color:var(--text2)">(OG)</span></div>`);
    });
    (m.own_goals?.away || []).forEach(g => {
      allGoals.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.away_short}</span> ${g.player} <span style="color:var(--text2)">(OG)</span></div>`);
    });

    const allAssists = [];
    (m.assists?.home || []).forEach(a => {
      allAssists.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.home_short}</span> ${a.player}</div>`);
    });
    (m.assists?.away || []).forEach(a => {
      allAssists.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.away_short}</span> ${a.player}</div>`);
    });

    const allCards = [];
    (m.yellow_cards?.home || []).forEach(c => {
      allCards.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.home_short}</span> ${c.player}</div>`);
    });
    (m.yellow_cards?.away || []).forEach(c => {
      allCards.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.away_short}</span> ${c.player}</div>`);
    });
    (m.red_cards?.home || []).forEach(c => {
      allCards.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.home_short}</span> ${c.player}</div>`);
    });
    (m.red_cards?.away || []).forEach(c => {
      allCards.push(`<div class="match-event"><span class="ev-icon"></span><span class="ev-side">${m.away_short}</span> ${c.player}</div>`);
    });

    const allBonus = [];
    const bonusAll = [...(m.bonus?.home || []), ...(m.bonus?.away || [])];
    bonusAll.sort((a, b) => b.points - a.points);
    bonusAll.forEach(b => {
      allBonus.push(`<div class="match-event"><span class="bonus-badge">${b.points}</span> ${b.player}</div>`);
    });

    if (allGoals.length) eventsHtml += allGoals.join('');
    if (allAssists.length) eventsHtml += allAssists.join('');
    if (allCards.length) eventsHtml += allCards.join('');
    if (allBonus.length) eventsHtml += `<div style="margin-top:4px;padding-top:4px;border-top:1px solid var(--border)">${allBonus.join('')}</div>`;
  }

  return `<div class="match-card">
    <div class="match-card-header">
      <span class="team-short">${m.home_short}</span>
      ${scoreHtml}
      <span class="team-short">${m.away_short}</span>
    </div>
    <div class="match-card-body">
      <div class="kickoff-time">${koText}</div>
      <div class="match-events">${eventsHtml}</div>
    </div>
  </div>`;
}

// ---------------------------------------------------------------------------
// GW Scores
// ---------------------------------------------------------------------------
function loadGWScores() {
  const gw = parseInt(document.getElementById('gwScoresInput').value) || 1;
  const grid = document.getElementById('gwScoresGrid');
  const status = document.getElementById('gwScoresStatus');
  grid.innerHTML = '<div class="empty-state"><p>Loading...</p></div>';
  status.textContent = '';

  fetch(`/api/gw-scores?gameweek=${gw}`).then(r => r.json()).then(d => {
    if (d.error) {
      grid.innerHTML = friendlyError(d.error, 'Scores');
      return;
    }
    if (!d.matches || d.matches.length === 0) {
      grid.innerHTML = '<div class="empty-state"><p>No fixtures found for this gameweek.</p></div>';
      return;
    }
    status.textContent = `${d.matches.length} matches`;
    grid.innerHTML = d.matches.map(m => renderMatchCardHtml(m)).join('');
  }).catch(err => {
    grid.innerHTML = friendlyError(err.message, 'Scores');
  });
}

// ---------------------------------------------------------------------------
// Team Form
// ---------------------------------------------------------------------------
let formData = null;
let formMatchDetails = {};
let formSortKey = 'form_points';
let formSortAsc = false;
let formGwFrom = null;
let formGwTo = null;

function loadTeamForm() {
  if (formData) { renderFormTable(); return; }
  const empty = document.getElementById('formEmptyState');
  const table = document.getElementById('formTable');
  empty.style.display = 'block';
  table.style.display = 'none';

  fetch('/api/team-form').then(r => r.json()).then(d => {
    if (d.error) {
      const m = (d.error || '').toLowerCase();
      if (m.includes('no cached') || m.includes('bootstrap') || m.includes('refresh data'))
        empty.innerHTML = '<h3>No Data Yet</h3><p>Click <b>Get Latest Data</b> above first.</p>';
      else
        empty.innerHTML = `<p style="color:var(--red)">${d.error}</p>`;
      return;
    }
    formData = d;
    formMatchDetails = {};
    d.teams.forEach(t => {
      Object.values(t.results).forEach(arr => {
        arr.forEach(r => { if (r.fixture_id) formMatchDetails[r.fixture_id] = r.match_detail; });
      });
    });
    // Default to last 10 GWs
    const allGws = d.gw_columns;
    if (allGws.length > 10) {
      formGwFrom = allGws[allGws.length - 10];
      formGwTo = allGws[allGws.length - 1];
    } else {
      formGwFrom = allGws[0];
      formGwTo = allGws[allGws.length - 1];
    }
    document.getElementById('formGwFrom').value = formGwFrom;
    document.getElementById('formGwTo').value = formGwTo;
    document.getElementById('formGwFrom').max = allGws[allGws.length - 1];
    document.getElementById('formGwTo').max = allGws[allGws.length - 1];
    document.getElementById('formControls').style.display = '';
    empty.style.display = 'none';
    table.style.display = 'table';
    renderFormTable();
  }).catch(err => {
    empty.innerHTML = `<p style="color:var(--red)">Error: ${err.message}</p>`;
  });
}

function getVisibleGws() {
  if (!formData) return [];
  return formData.gw_columns.filter(gw => gw >= formGwFrom && gw <= formGwTo);
}

function calcFormPoints(team, gws) {
  let pts = 0;
  gws.forEach(gw => {
    (team.results[String(gw)] || []).forEach(r => {
      pts += r.result === 'W' ? 3 : r.result === 'D' ? 1 : 0;
    });
  });
  return pts;
}

function renderFormTable() {
  if (!formData) return;
  const gws = getVisibleGws();
  const thead = document.getElementById('formTableHead');
  const tbody = document.getElementById('formTableBody');
  const label = document.getElementById('formRangeLabel');
  label.textContent = `Showing GW${gws[0]}GW${gws[gws.length - 1]} (${gws.length} GWs)`;

  // Calculate form points for visible range
  let teams = formData.teams.map(t => ({...t, form_points: calcFormPoints(t, gws)}));

  // Sort
  if (formSortKey === 'name') {
    teams.sort((a, b) => formSortAsc ? a.name.localeCompare(b.name) : b.name.localeCompare(a.name));
  } else {
    teams.sort((a, b) => formSortAsc ? a.form_points - b.form_points : b.form_points - a.form_points);
  }

  // Header
  const arrow = k => `<span class="sort-arrow">${formSortKey === k ? (formSortAsc ? '' : '') : ''}</span>`;
  const sorted = k => formSortKey === k ? ' sorted' : '';
  thead.innerHTML = `<tr>
    <th class="${sorted('name')}" onclick="sortFormTable('name')">Team ${arrow('name')}</th>
    <th class="${sorted('form_points')}" onclick="sortFormTable('form_points')">Pts ${arrow('form_points')}</th>
    ${gws.map(gw => `<th>GW${gw}</th>`).join('')}
  </tr>`;

  // Body
  tbody.innerHTML = '';
  teams.forEach(t => {
    const tr = document.createElement('tr');
    const badge = t.code ? `<img src="https://resources.premierleague.com/premierleague/badges/25/t${t.code}.png" width="20" height="20" style="vertical-align:middle;margin-right:6px" alt="">` : '';
    let cells = `<td>${badge}${t.short}</td><td>${t.form_points}</td>`;
    gws.forEach(gw => {
      const results = t.results[String(gw)] || [];
      if (results.length === 0) {
        cells += `<td><span class="bgw-marker">-</span></td>`;
      } else {
        const badges = results.map(r => {
          const cls = r.result === 'W' ? 'win' : r.result === 'D' ? 'draw' : 'loss';
          const loc = r.is_home ? 'H' : 'A';
          return `<span class="result-badge ${cls}" onclick="openMatchModal(${r.fixture_id})" title="${loc}: ${r.score_for}-${r.score_against} vs ${r.opponent_short}">${r.score_for}-${r.score_against} <span class="opp">${r.opponent_short}</span></span>`;
        }).join('');
        cells += `<td>${results.length > 1 ? '<div class="dgw-cell">' + badges + '</div>' : badges}</td>`;
      }
    });
    tr.innerHTML = cells;
    tbody.appendChild(tr);
  });
}

function applyFormRange() {
  const from = parseInt(document.getElementById('formGwFrom').value);
  const to = parseInt(document.getElementById('formGwTo').value);
  if (!from || !to || from > to) return;
  formGwFrom = from;
  formGwTo = to;
  renderFormTable();
}

function resetFormRange() {
  if (!formData) return;
  const allGws = formData.gw_columns;
  formGwFrom = allGws[0];
  formGwTo = allGws[allGws.length - 1];
  document.getElementById('formGwFrom').value = formGwFrom;
  document.getElementById('formGwTo').value = formGwTo;
  renderFormTable();
}

function sortFormTable(key) {
  if (formSortKey === key) {
    formSortAsc = !formSortAsc;
  } else {
    formSortKey = key;
    formSortAsc = key === 'name';
  }
  renderFormTable();
}

function openMatchModal(fixtureId) {
  const detail = formMatchDetails[fixtureId];
  if (!detail) return;
  document.getElementById('matchModalBody').innerHTML = renderMatchCardHtml(detail);
  document.getElementById('matchModal').classList.add('visible');
}

function closeMatchModal() {
  document.getElementById('matchModal').classList.remove('visible');
}

// ---------------------------------------------------------------------------
// Interactions
// ---------------------------------------------------------------------------
function filterPosition(btn) {
  document.querySelectorAll('.pos-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  currentPosition = btn.dataset.pos;
  loadPredictions();
}

function debounceSearch() {
  clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    currentSearch = document.getElementById('searchBox').value;
    loadPredictions();
  }, 250);
}

function sortBy(key) {
  if (currentSort === key) {
    sortAsc = !sortAsc;
  } else {
    currentSort = key;
    sortAsc = false;
  }
  loadPredictions();
}

function switchTab(tab) {
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  if (tab.classList && tab.classList.add) tab.classList.add('active');

  const view = tab.dataset.view;
  document.getElementById('predictionsPanel').style.display = view === 'predictions' ? 'block' : 'none';

  const bestTeam = document.getElementById('bestTeamPanel');
  if (view === 'bestteam') {
    bestTeam.classList.add('visible');
  } else {
    bestTeam.classList.remove('visible');
  }

  const gwCompare = document.getElementById('gwComparePanel');
  if (view === 'gwcompare') {
    gwCompare.classList.add('visible');
    const saved = localStorage.getItem('fpl_manager_id');
    if (saved) document.getElementById('cmpManagerId').value = saved;
  } else {
    gwCompare.classList.remove('visible');
  }

  const myTeam = document.getElementById('myTeamPanel');
  if (view === 'myteam') {
    myTeam.classList.add('visible');
    const saved = localStorage.getItem('fpl_manager_id');
    if (saved) document.getElementById('managerIdInput').value = saved;
  } else {
    myTeam.classList.remove('visible');
  }

  const plTablePanel = document.getElementById('plTablePanel');
  if (view === 'pltable') {
    plTablePanel.classList.add('visible');
    loadPLTable();
  } else {
    plTablePanel.classList.remove('visible');
  }

  const gwScoresPanel = document.getElementById('gwScoresPanel');
  if (view === 'gwscores') {
    gwScoresPanel.classList.add('visible');
    if (!document.getElementById('gwScoresInput').value) {
      const defGW = nextGW ? nextGW - 1 : 1;
      document.getElementById('gwScoresInput').value = Math.max(1, defGW);
    }
  } else {
    gwScoresPanel.classList.remove('visible');
  }

  const teamFormPanel = document.getElementById('teamFormPanel');
  if (view === 'teamform') {
    teamFormPanel.classList.add('visible');
    loadTeamForm();
  } else {
    teamFormPanel.classList.remove('visible');
  }

  const pricesPanel = document.getElementById('pricesPanel');
  if (view === 'prices') {
    pricesPanel.style.display = 'block';
    loadPrices();
  } else {
    pricesPanel.style.display = 'none';
  }

  const playersPanel = document.getElementById('playersPanel');
  if (view === 'players') {
    playersPanel.classList.add('visible');
    loadPlayersTeams();
  } else {
    playersPanel.classList.remove('visible');
  }

  const monstersPanel = document.getElementById('monstersPanel');
  if (view === 'monsters') {
    monstersPanel.classList.add('visible');
    loadMonsters();
  } else {
    monstersPanel.classList.remove('visible');
  }

  const seasonPanel = document.getElementById('seasonPanel');
  if (view === 'season') {
    seasonPanel.classList.add('visible');
    const saved = localStorage.getItem('fpl_manager_id');
    if (saved) document.getElementById('seasonManagerId').value = saved;
    loadSeasonV2();
  } else {
    seasonPanel.classList.remove('visible');
    clearSeasonV2Poll();
  }

  const backtestPanel = document.getElementById('backtestPanel');
  if (view === 'backtest') {
    backtestPanel.classList.add('visible');
  } else {
    backtestPanel.classList.remove('visible');
  }

  const wtfPanel = document.getElementById('wtfPanel');
  if (view === 'buthow') {
    wtfPanel.classList.add('visible');
    loadWtfTeams();
  } else {
    wtfPanel.classList.remove('visible');
  }
}

// ---------------------------------------------------------------------------
// Best Team
// ---------------------------------------------------------------------------
function pickBestTeam() {
  const budget = parseFloat(document.getElementById('budgetInput').value) || 100;
  const target = document.getElementById('targetSelect').value;

  document.getElementById('squadDisplay').innerHTML = '<div class="empty-state"><p>Solving...</p></div>';
  document.getElementById('teamSummary').innerHTML = '';

  fetch('/api/best-team', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ budget, target }),
  }).then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('squadDisplay').innerHTML = friendlyError(d.error, 'No Solution');
      return;
    }

    const gwLabel = nextGW ? `GW${nextGW}` : 'GW';
    const gw3Label = nextGW ? `GW${nextGW}-${nextGW+2}` : '3GW';

    // Summary with both targets
    const summary = document.getElementById('teamSummary');
    summary.innerHTML = `
      <div class="summary-stat"><div class="label">XI Pred ${gwLabel}</div><div class="value">${Number(d.starting_gw_points).toFixed(1)}</div></div>
      <div class="summary-stat"><div class="label">XI Pred ${gw3Label}</div><div class="value">${Number(d.starting_gw3_points).toFixed(1)}</div></div>
      <div class="summary-stat"><div class="label">Total Cost</div><div class="value">${d.total_cost}</div></div>
      <div class="summary-stat"><div class="label">Remaining</div><div class="value green">${d.remaining}</div></div>
    `;

    const starters = d.players.filter(p => p.starter);
    const bench = d.players.filter(p => !p.starter);

    const display = document.getElementById('squadDisplay');
    display.innerHTML = '';

    // Find captain (highest predicted points among starters)
    const captainId = starters.reduce((best, p) =>
      (p[target] || 0) > (best[target] || 0) ? p : best, starters[0]
    ).player_id;

    // Build pitch card HTML
    function card(p) {
      let pts;
      const isCaptain = p.player_id === captainId;
      if (p[target] != null) {
        let rawPred = Number(p[target]);
        if (isCaptain) rawPred *= 2;
        pts = rawPred.toFixed(1);
      } else {
        pts = '-';
      }
      const fdrVal = Math.round(p.fdr || 3);
      const opp = p.opponent || '';
      const captainStyle = isCaptain ? 'border:2px solid #ef4444;box-shadow:0 0 8px rgba(239,68,68,0.4)' : '';
      const captainBadge = isCaptain ? '<span style="color:#ef4444;font-weight:700;font-size:10px"> (C)</span>' : '';
      return `<div class="pitch-card" style="${captainStyle}">
        <div class="p-name">${p.web_name || '-'}${captainBadge}</div>
        <div class="p-team">${p.team || ''} &middot; ${Number(p.cost).toFixed(1)}m</div>
        <div class="p-pts">${pts}</div>
        <span class="p-fdr fdr-${fdrVal}">${p.fdr != null ? p.fdr : '-'}</span>
        <span style="font-size:10px;color:var(--text2);margin-left:4px">${opp}</span>
      </div>`;
    }

    // Pitch
    const fwd = starters.filter(p => p.position === 'FWD');
    const mid = starters.filter(p => p.position === 'MID');
    const def = starters.filter(p => p.position === 'DEF');
    const gkp = starters.filter(p => p.position === 'GKP');

    const pitch = document.createElement('div');
    pitch.className = 'pitch';
    pitch.innerHTML = `
      <div class="pitch-bottom-box"></div>
      <div class="pitch-row fwd">${fwd.map(card).join('')}</div>
      <div class="pitch-row mid">${mid.map(card).join('')}</div>
      <div class="pitch-row def">${def.map(card).join('')}</div>
      <div class="pitch-row gkp">${gkp.map(card).join('')}</div>
    `;
    display.appendChild(pitch);

    // Bench
    if (bench.length) {
      const benchArea = document.createElement('div');
      benchArea.className = 'bench-area';
      benchArea.innerHTML = `<div class="bench-label">Bench</div>
        <div class="bench-row">${bench.map(p => {
          const pts = p[target] != null ? Number(p[target]).toFixed(1) : '-';
          return `<div class="bench-card">
            <div class="p-name">${p.web_name || '-'}</div>
            <div class="p-team">${p.team || ''} &middot; ${Number(p.cost).toFixed(1)}m</div>
            <div class="p-pts">${pts}</div>
          </div>`;
        }).join('')}</div>`;
      display.appendChild(benchArea);
    }
  });
}

// ---------------------------------------------------------------------------
// GW Compare
// ---------------------------------------------------------------------------
function runGWCompare() {
  const managerId = document.getElementById('cmpManagerId').value;
  if (!managerId) { alert('Enter a Manager ID'); return; }
  const gameweek = parseInt(document.getElementById('cmpGW').value) || 10;

  document.getElementById('cmpContent').innerHTML = '<div class="empty-state"><p>Running comparison...</p></div>';
  document.getElementById('cmpSummary').innerHTML = '';

  fetch('/api/gw-compare', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ manager_id: parseInt(managerId), gameweek }),
  }).then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('cmpContent').innerHTML = friendlyError(d.error, 'Compare Failed');
      return;
    }

    const overlapSet = new Set(d.overlap_player_ids || []);

    // Summary cards
    const summary = document.getElementById('cmpSummary');
    summary.innerHTML = `
      <div class="summary-stat"><div class="label">Gameweek</div><div class="value">${d.gameweek}</div></div>
      <div class="summary-stat"><div class="label">My Points</div><div class="value" style="color:var(--accent)">${d.my_team.starting_actual}</div></div>
      <div class="summary-stat"><div class="label">Best Possible</div><div class="value green">${d.best_team.starting_actual}</div></div>
      <div class="summary-stat"><div class="label">Capture %</div><div class="value" style="color:var(--yellow)">${d.capture_pct}%</div></div>
      <div class="summary-stat"><div class="label">Overlap</div><div class="value" style="color:var(--yellow)">${d.overlap_count}/11</div></div>
      <div class="summary-stat"><div class="label">Budget</div><div class="value" style="font-size:16px;color:var(--text2)">${d.budget}m</div></div>
    `;

    // Build dual pitches
    function makeCard(p, isBestSide) {
      const isOverlap = overlapSet.has(p.player_id);
      const overlapClass = isOverlap ? ' overlap' : '';
      let pts = p.actual != null ? Number(p.actual) : null;
      const mult = p.multiplier || 1;
      // Apply captain/TC multiplier to displayed points
      if (pts != null && mult > 1) pts = pts * mult;
      const ptsStr = pts != null ? pts.toFixed(0) : '-';
      const captainBadge = p.is_captain ? (mult === 3 ? ' (TC)' : ' (C)') : p.is_vice_captain ? ' (V)' : '';
      return `<div class="pitch-card${overlapClass}">
        <div class="p-name">${p.web_name || '?'}${captainBadge}</div>
        <div class="p-team">${p.team || ''} &middot; ${Number(p.cost || 0).toFixed(1)}m</div>
        <div class="p-pts">${ptsStr}</div>
      </div>`;
    }

    function buildPitch(starters) {
      const fwd = starters.filter(p => p.position === 'FWD');
      const mid = starters.filter(p => p.position === 'MID');
      const def_ = starters.filter(p => p.position === 'DEF');
      const gkp = starters.filter(p => p.position === 'GKP');
      return `<div class="pitch">
        <div class="pitch-bottom-box"></div>
        <div class="pitch-row fwd">${fwd.map(p => makeCard(p)).join('')}</div>
        <div class="pitch-row mid">${mid.map(p => makeCard(p)).join('')}</div>
        <div class="pitch-row def">${def_.map(p => makeCard(p)).join('')}</div>
        <div class="pitch-row gkp">${gkp.map(p => makeCard(p)).join('')}</div>
      </div>`;
    }

    function buildBench(bench) {
      if (!bench || !bench.length) return '';
      return `<div class="bench-area"><div class="bench-label">Bench</div><div class="bench-row">${
        bench.map(p => makeCard(p)).join('')
      }</div></div>`;
    }

    const container = document.getElementById('cmpContent');
    container.innerHTML = `<div class="compare-pitches">
      <div class="compare-side">
        <h3 style="color:var(--accent)">My Team (${d.my_team.starting_actual} pts)</h3>
        ${buildPitch(d.my_team.starters)}
        ${buildBench(d.my_team.bench)}
      </div>
      <div class="compare-side">
        <h3 style="color:var(--green)">Best Possible (${d.best_team.starting_actual} pts)</h3>
        ${buildPitch(d.best_team.starters)}
        ${buildBench(d.best_team.bench)}
      </div>
    </div>`;
  }).catch(err => {
    document.getElementById('cmpContent').innerHTML =
      `<div class="empty-state"><h3>Error</h3><p>${err.message}</p></div>`;
  });
}

// ---------------------------------------------------------------------------
// My Team
// ---------------------------------------------------------------------------
function importMyTeam() {
  const managerId = document.getElementById('managerIdInput').value;
  if (!managerId) { alert('Enter a Manager ID'); return; }
  localStorage.setItem('fpl_manager_id', managerId);

  document.getElementById('myTeamDisplay').innerHTML = '<div class="empty-state"><p>Loading squad...</p></div>';
  document.getElementById('myTeamSummary').innerHTML = '';
  document.getElementById('myTeamManagerInfo').textContent = '';

  fetch(`/api/my-team?manager_id=${managerId}`).then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('myTeamDisplay').innerHTML = friendlyError(d.error, 'Import Failed');
      return;
    }
    renderMyTeam(d);
  }).catch(err => {
    document.getElementById('myTeamDisplay').innerHTML = friendlyError(err.message, 'Connection Error');
  });
}

function renderMyTeam(d) {
  // Store for transfer recommendations
  lastMyTeamData = d;

  // Show transfer section and set defaults
  const transferSection = document.getElementById('transferSection');
  transferSection.style.display = 'block';
  document.getElementById('transferCount').value = d.free_transfers || 1;
  document.getElementById('transferWildcard').checked = false;
  document.getElementById('transferCount').disabled = false;
  document.getElementById('transferResults').innerHTML = '';

  // Update transfer target dropdown labels
  if (d.next_gw) {
    const tSel = document.getElementById('transferTarget');
    tSel.options[0].text = `GW${d.next_gw} Points`;
    tSel.options[1].text = `GW${d.next_gw}-${d.next_gw+2} Points`;
  }

  // Manager info
  const info = document.getElementById('myTeamManagerInfo');
  const mgr = d.manager;
  info.innerHTML = `<strong>${mgr.team_name}</strong> &middot; ${mgr.name} &middot; Rank: ${(mgr.overall_rank || '-').toLocaleString()} &middot; Points: ${mgr.overall_points || '-'}`;

  const gwLabel = d.next_gw ? `GW${d.next_gw}` : 'GW';
  const gw3Label = d.next_gw ? `GW${d.next_gw}-${d.next_gw+2}` : '3GW';

  // Summary stats
  const summary = document.getElementById('myTeamSummary');
  let chipHtml = '';
  if (d.active_chip) {
    chipHtml = `<div class="summary-stat"><div class="label">Active Chip</div><div class="value" style="color:var(--yellow)">${d.active_chip}</div></div>`;
  }
  const curGwLabel = d.current_event ? `GW${d.current_event}` : 'Current GW';
  summary.innerHTML = `
    <div class="summary-stat"><div class="label">XI Actual ${curGwLabel}</div><div class="value" style="color:var(--orange)">${d.xi_actual_gw}</div></div>
    <div class="summary-stat"><div class="label">XI Pred ${gwLabel}</div><div class="value">${Number(d.xi_pred_gw).toFixed(1)}</div></div>
    <div class="summary-stat"><div class="label">XI Pred ${gw3Label}</div><div class="value">${Number(d.xi_pred_3gw).toFixed(1)}</div></div>
    <div class="summary-stat"><div class="label">Squad Value</div><div class="value" style="color:var(--text)">${d.squad_value}m</div></div>
    <div class="summary-stat"><div class="label">Sell Value</div><div class="value" style="color:var(--text2)">${d.sell_value}m</div></div>
    <div class="summary-stat"><div class="label">Bank</div><div class="value green">${d.bank}m</div></div>
    <div class="summary-stat"><div class="label">Free Transfers</div><div class="value" style="color:var(--text)">${d.free_transfers}</div></div>
    ${chipHtml}
  `;

  // Free Hit revert banner
  const fhBanner = document.getElementById('fhRevertBanner');
  if (fhBanner) fhBanner.remove();
  if (d.fh_reverted) {
    const banner = document.createElement('div');
    banner.id = 'fhRevertBanner';
    banner.style.cssText = 'background:var(--surface2);border-left:3px solid var(--yellow);padding:8px 12px;margin:8px 0;border-radius:4px;font-size:0.85em;color:var(--text2)';
    banner.textContent = `Free Hit was played in GW${d.fh_event}. Showing your reverted GW${d.fh_event - 1} squad for planning.`;
    summary.after(banner);
  }

  // Captain rationale banner
  const oldCapBanner = document.getElementById('captainRationaleBanner');
  if (oldCapBanner) oldCapBanner.remove();
  const optSquadForBanner = d.optimized_squad || d.squad;
  const capPlayer = optSquadForBanner.find(p => p.is_captain && p.starter);
  if (capPlayer) {
    const optStForBanner = optSquadForBanner.filter(p => p.starter && !p.is_captain);
    const highestMean = optStForBanner.reduce((best, p) =>
      (p.predicted_next_gw_points || 0) > (best.predicted_next_gw_points || 0) ? p : best
    , optStForBanner[0]);
    const capMean = Number(capPlayer.predicted_next_gw_points || 0);
    const capQ80 = Number(capPlayer.predicted_next_gw_points_q80 || 0);
    const highMean = highestMean ? Number(highestMean.predicted_next_gw_points || 0) : 0;

    let bannerText = '';
    if (!highestMean || capMean >= highMean) {
      bannerText = `Captain: ${capPlayer.web_name}  highest base prediction (${capMean.toFixed(1)}  2 = ${(capMean * 2).toFixed(1)}).`;
    } else if (capQ80 > capMean) {
      bannerText = `Captain: ${capPlayer.web_name}  predicted ${(capMean * 2).toFixed(1)} pts (${capMean.toFixed(1)}  2), with explosive upside potential up to ${(capQ80 * 2).toFixed(1)} pts (${capQ80.toFixed(1)}  2). Highest base prediction: ${highestMean.web_name} (${highMean.toFixed(1)} pts).`;
    } else {
      bannerText = `Captain: ${capPlayer.web_name}  captain score ${Number(capPlayer.captain_score || 0).toFixed(1)} vs ${highestMean.web_name} (${highMean.toFixed(1)} pts predicted).`;
    }
    const capBanner = document.createElement('div');
    capBanner.id = 'captainRationaleBanner';
    capBanner.style.cssText = 'background:var(--surface2);border-left:3px solid var(--green);padding:8px 12px;margin:8px 0;border-radius:4px;font-size:0.85em;color:var(--text2)';
    capBanner.innerHTML = `<span style="color:var(--green)">&#9813;</span> ${bannerText}`;
    const insertAfter = document.getElementById('fhRevertBanner') || summary;
    insertAfter.after(capBanner);
  }

  const starters = d.squad.filter(p => p.starter);
  const bench = d.squad.filter(p => !p.starter);

  // Optimized squad for predicted pitch (best formation-valid XI from 15 players)
  const optSquad = d.optimized_squad || d.squad;
  const optStarters = optSquad.filter(p => p.starter);
  const optBench = optSquad.filter(p => !p.starter);

  function myTeamCard(p, mode, chipContext) {
    // mode: 'actual' = show event_points, 'predicted' = show predicted
    // chipContext: optional chip name (e.g. '3xc') to adjust captain multiplier
    const isActual = mode === 'actual';
    let pts;
    if (isActual) {
      pts = p.event_points != null ? Number(p.event_points).toFixed(0) : '-';
    } else if (p.predicted_next_gw_points != null) {
      let rawPred = Number(p.predicted_next_gw_points);
      if (p.is_captain) rawPred *= (chipContext === '3xc' ? 3 : 2);
      pts = rawPred.toFixed(1);
    } else {
      pts = '-';
    }
    const ptsColor = isActual ? 'var(--orange)' : 'var(--green)';
    const fdrVal = Math.round(p.fdr || 3);
    const opp = p.opponent || '';

    let extraClass = '';
    let statusHtml = '';
    if (p.status === 'i') {
      extraClass = ' injured';
      statusHtml = '<div class="p-avail injured">Injured</div>';
    } else if (p.status === 's') {
      extraClass = ' injured';
      statusHtml = '<div class="p-avail injured">Suspended</div>';
    } else if (p.chance_of_playing != null && p.chance_of_playing < 100) {
      extraClass = ' doubtful';
      statusHtml = `<div class="p-avail doubtful">${p.chance_of_playing}% chance</div>`;
    }

    let cardStyle = '';
    let badge = '';
    if (p.is_captain) {
      cardStyle = 'border:2px solid #ef4444;box-shadow:0 0 8px rgba(239,68,68,0.4)';
      badge = ' <span class="captain-badge">(C)</span>';
    } else if (p.is_vice_captain) {
      badge = ' <span class="vc-badge">(V)</span>';
    }

    const newsHtml = (!isActual && p.news) ? `<div class="p-news" title="${p.news}">${p.news}</div>` : '';

    return `<div class="pitch-card${extraClass}" style="${cardStyle}">
      <div class="p-name">${p.web_name || '-'}${badge}</div>
      <div class="p-team">${p.team || ''} &middot; ${Number(p.cost).toFixed(1)}m</div>
      <div class="p-pts" style="color:${ptsColor}">${pts}</div>
      ${isActual ? '' : `<span class="p-fdr fdr-${fdrVal}">${p.fdr != null ? p.fdr : '-'}</span>
      <span style="font-size:10px;color:var(--text2);margin-left:4px">${opp}</span>`}
      ${statusHtml}${newsHtml}
    </div>`;
  }

  function buildMyTeamPitch(players, mode, chipContext) {
    const fwd = players.filter(p => p.position === 'FWD');
    const mid = players.filter(p => p.position === 'MID');
    const def_ = players.filter(p => p.position === 'DEF');
    const gkp = players.filter(p => p.position === 'GKP');
    return `<div class="pitch">
      <div class="pitch-bottom-box"></div>
      <div class="pitch-row fwd">${fwd.map(p => myTeamCard(p, mode, chipContext)).join('')}</div>
      <div class="pitch-row mid">${mid.map(p => myTeamCard(p, mode, chipContext)).join('')}</div>
      <div class="pitch-row def">${def_.map(p => myTeamCard(p, mode, chipContext)).join('')}</div>
      <div class="pitch-row gkp">${gkp.map(p => myTeamCard(p, mode, chipContext)).join('')}</div>
    </div>`;
  }

  function buildMyTeamBench(players, mode) {
    if (!players || !players.length) return '';
    return `<div class="bench-area"><div class="bench-label">Bench</div>
      <div class="bench-row">${players.map(p => {
        const pts = mode === 'actual'
          ? (p.event_points_raw != null ? Number(p.event_points_raw).toFixed(0) : '-')
          : (p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-');
        const ptsColor = mode === 'actual' ? 'var(--orange)' : 'var(--accent)';
        let statusCls = '';
        let statusText = '';
        if (p.status === 'i') { statusCls = 'injured'; statusText = 'Injured'; }
        else if (p.status === 's') { statusCls = 'injured'; statusText = 'Suspended'; }
        else if (p.chance_of_playing != null && p.chance_of_playing < 100) { statusCls = 'doubtful'; statusText = p.chance_of_playing + '% chance'; }
        const statusHtml = statusText ? `<div class="p-avail ${statusCls}" style="font-size:9px">${statusText}</div>` : '';
        return `<div class="bench-card">
          <div class="p-name">${p.web_name || '-'}</div>
          <div class="p-team">${p.team || ''} &middot; ${Number(p.cost).toFixed(1)}m</div>
          <div class="p-pts" style="color:${ptsColor}">${pts}</div>
          ${statusHtml}
        </div>`;
      }).join('')}</div></div>`;
  }

  const display = document.getElementById('myTeamDisplay');
  display.innerHTML = `<div class="compare-pitches">
    <div class="compare-side">
      <h3 style="color:var(--orange)">${curGwLabel} Actual (${d.xi_actual_gw} pts)</h3>
      ${buildMyTeamPitch(starters, 'actual')}
      ${buildMyTeamBench(bench, 'actual')}
    </div>
    <div class="compare-side">
      <h3 style="color:var(--green)">Optimal ${gwLabel} (${Number(d.xi_pred_gw).toFixed(1)} pts)</h3>
      ${buildMyTeamPitch(optStarters, 'predicted')}
      ${buildMyTeamBench(optBench, 'predicted')}
    </div>
  </div>`;
}

// ---------------------------------------------------------------------------
// Transfer Recommendations
// ---------------------------------------------------------------------------
let lastMyTeamData = null;

function toggleWildcard() {
  const wc = document.getElementById('transferWildcard').checked;
  const countInput = document.getElementById('transferCount');
  if (wc) {
    countInput.disabled = true;
    countInput.value = '15';
  } else {
    countInput.disabled = false;
    countInput.value = lastMyTeamData ? lastMyTeamData.free_transfers : 1;
  }
}

function findTransfers() {
  if (!lastMyTeamData) { alert('Import your squad first.'); return; }

  const managerId = document.getElementById('managerIdInput').value;
  const maxTransfers = parseInt(document.getElementById('transferCount').value) || 1;
  const target = document.getElementById('transferTarget').value;
  const wildcard = document.getElementById('transferWildcard').checked;

  const btn = document.getElementById('btnFindTransfers');
  btn.disabled = true;
  btn.textContent = 'Solving...';
  document.getElementById('transferResults').innerHTML = '<div class="empty-state"><p>Running solver...</p></div>';

  fetch('/api/transfer-recommendations', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ manager_id: parseInt(managerId), max_transfers: maxTransfers, target, wildcard }),
  }).then(r => r.json()).then(d => {
    btn.disabled = false;
    btn.textContent = 'Find Transfers';
    if (d.error) {
      document.getElementById('transferResults').innerHTML = friendlyError(d.error, 'Transfer Error');
      return;
    }
    renderTransfers(d);
  }).catch(err => {
    btn.disabled = false;
    btn.textContent = 'Find Transfers';
    document.getElementById('transferResults').innerHTML = friendlyError(err.message, 'Connection Error');
  });
}

function renderTransfers(d) {
  const container = document.getElementById('transferResults');
  const target = d.target;
  const gwLabel = d.next_gw ? `GW${d.next_gw}` : 'GW';
  const newSigningIds = new Set(d.transfers_in_ids || []);

  let html = '';

  // Summary stats
  const hitClass = d.points_hit > 0 ? 'style="color:var(--red)"' : '';
  const netColor = d.net_gain > 0 ? 'green' : (d.net_gain < 0 ? 'style="color:var(--red)"' : '');
  const netStyle = d.net_gain >= 0 ? 'class="value green"' : 'class="value" style="color:var(--red)"';

  html += '<div class="team-summary">';
  html += `<div class="summary-stat"><div class="label">Points Gained</div><div class="value green">+${Number(d.points_gained).toFixed(1)}</div></div>`;
  if (d.points_hit > 0) {
    html += `<div class="summary-stat"><div class="label">Points Hit</div><div class="value" style="color:var(--red)">-${d.points_hit}</div></div>`;
  }
  html += `<div class="summary-stat"><div class="label">Net Gain</div><div ${netStyle}>${d.net_gain > 0 ? '+' : ''}${Number(d.net_gain).toFixed(1)}</div></div>`;
  html += `<div class="summary-stat"><div class="label">New XI Pred ${gwLabel}</div><div class="value">${Number(d.new_xi_points).toFixed(1)}</div></div>`;
  html += `<div class="summary-stat"><div class="label">Transfers</div><div class="value" style="color:var(--text)">${d.n_transfers}${d.wildcard ? ' (WC)' : ''}</div></div>`;
  html += `<div class="summary-stat"><div class="label">Budget Remaining</div><div class="value green">${d.bank_after}m</div></div>`;
  html += '</div>';

  if (d.points_hit > 0 && !d.wildcard) {
    html += `<div style="font-size:12px;color:var(--yellow);margin-bottom:12px">Using ${d.n_transfers} transfers with ${d.free_transfers} free  ${d.n_transfers - d.free_transfers} extra at 4pts each = ${d.points_hit}pt hit</div>`;
  }

  // Transfer cards
  if (d.transfers_in.length > 0) {
    html += '<div class="transfer-cards">';
    for (let i = 0; i < d.transfers_in.length; i++) {
      const inP = d.transfers_in[i];
      const outP = d.transfers_out[i] || {};
      const inPts = inP[target] != null ? Number(inP[target]).toFixed(1) : '-';
      const outPts = outP[target] != null ? Number(outP[target]).toFixed(1) : '-';
      const ptsDelta = (inP[target] || 0) - (outP[target] || 0);
      const costDelta = (inP.cost || 0) - (outP.cost || 0);
      const ptsColor = ptsDelta >= 0 ? 'var(--green)' : 'var(--red)';

      html += `<div class="transfer-card">
        <div class="transfer-side transfer-out">
          <div class="ts-name">${outP.web_name || '?'}</div>
          <div class="ts-meta">${outP.team || ''} &middot; ${outP.position || ''} &middot; ${Number(outP.cost || 0).toFixed(1)}m</div>
          <div class="ts-pts">${outPts} pts</div>
        </div>
        <div class="transfer-arrow">&rarr;</div>
        <div class="transfer-side transfer-in">
          <div class="ts-name">${inP.web_name || '?'}</div>
          <div class="ts-meta">${inP.team || ''} &middot; ${inP.position || ''} &middot; ${Number(inP.cost || 0).toFixed(1)}m</div>
          <div class="ts-pts">${inPts} pts</div>
        </div>
        <div class="transfer-delta">
          <div class="td-pts" style="color:${ptsColor}">${ptsDelta >= 0 ? '+' : ''}${ptsDelta.toFixed(1)}</div>
          <div class="td-cost">${costDelta >= 0 ? '+' : ''}${costDelta.toFixed(1)}m</div>
        </div>
      </div>`;
    }
    html += '</div>';
  } else {
    html += '<div style="text-align:center;color:var(--text2);padding:20px">No beneficial transfers found  your squad is already optimal!</div>';
  }

  // New squad pitch
  if (d.new_squad) {
    const starters = d.new_squad.starters || [];
    const bench = d.new_squad.bench || [];

    const is3gw = target === 'predicted_next_3gw_points';

    function transferCard(p) {
      const pts = p[target] != null ? Number(p[target]).toFixed(1) : '-';
      const fdrVal = Math.round(p.fdr || 3);
      const opp = p.opponent || '';
      const fixtures3 = p.next_3_fixtures || '';
      const isNew = newSigningIds.has(p.player_id);
      const newClass = isNew ? ' new-signing' : '';
      const fixtureHtml = is3gw
        ? `<div style="font-size:9px;color:var(--text2);margin-top:2px">${fixtures3}</div>`
        : `<span class="p-fdr fdr-${fdrVal}">${p.fdr != null ? p.fdr : '-'}</span>
           <div style="font-size:9px;color:var(--text2);margin-top:2px">${fixtures3}</div>`;
      return `<div class="pitch-card${newClass}">
        <div class="p-name">${p.web_name || '-'}</div>
        <div class="p-team">${p.team || ''} &middot; ${Number(p.cost).toFixed(1)}m</div>
        <div class="p-pts">${pts}</div>
        ${fixtureHtml}
      </div>`;
    }

    const fwd = starters.filter(p => p.position === 'FWD');
    const mid = starters.filter(p => p.position === 'MID');
    const def_ = starters.filter(p => p.position === 'DEF');
    const gkp = starters.filter(p => p.position === 'GKP');

    html += `<h3 style="text-align:center;font-size:15px;margin:20px 0 10px;color:var(--text2)">New Squad <span style="color:var(--green)">(green = new signing)</span></h3>`;
    html += `<div class="pitch" style="max-width:720px;margin:0 auto">
      <div class="pitch-bottom-box"></div>
      <div class="pitch-row fwd">${fwd.map(transferCard).join('')}</div>
      <div class="pitch-row mid">${mid.map(transferCard).join('')}</div>
      <div class="pitch-row def">${def_.map(transferCard).join('')}</div>
      <div class="pitch-row gkp">${gkp.map(transferCard).join('')}</div>
    </div>`;

    // Bench
    if (bench.length) {
      html += `<div class="bench-area"><div class="bench-label">Bench</div>
        <div class="bench-row">${bench.map(p => {
          const pts = p[target] != null ? Number(p[target]).toFixed(1) : '-';
          const isNew = newSigningIds.has(p.player_id);
          const borderStyle = isNew ? 'border:1px solid var(--green)' : '';
          return `<div class="bench-card" style="${borderStyle}">
            <div class="p-name">${p.web_name || '-'}</div>
            <div class="p-team">${p.team || ''} &middot; ${Number(p.cost).toFixed(1)}m</div>
            <div class="p-pts">${pts}</div>
          </div>`;
        }).join('')}</div></div>`;
    }
  }

  html += `<div style="font-size:11px;color:var(--text2);margin-top:16px;padding:10px;background:var(--surface);border:1px solid var(--border);border-radius:6px;max-width:720px;margin-left:auto;margin-right:auto">
    Note: Selling prices are approximate  actual budget may vary slightly for players who have risen in price since you bought them.
  </div>`;

  container.innerHTML = html;
}

// ---------------------------------------------------------------------------
// Season V2  Phase-Aware GW-Centric View
// ---------------------------------------------------------------------------

let _seasonV2PollTimer = null;
let _seasonV2StatusCache = null;
let _transferModalState = null;
let _multiTransferState = null; // {phase:'sell'|'buy'|'confirm', playersOut:[], playersIn:[], allCandidates:[], buyingPosition:null}

function getSeasonManagerId() {
  return document.getElementById('seasonManagerId').value || localStorage.getItem('fpl_manager_id') || '';
}

function clearSeasonV2Poll() {
  if (_seasonV2PollTimer) { clearInterval(_seasonV2PollTimer); _seasonV2PollTimer = null; }
}

async function loadSeasonV2() {
  const mid = getSeasonManagerId();
  if (!mid) return;

  try {
    const resp = await fetch(`/api/v2/season/status?manager_id=${mid}`);
    const data = await resp.json();
    _seasonV2StatusCache = data;

    if (!data.active) {
      // Check pre-season
      try {
        const teamResp = await fetch(`/api/my-team?manager_id=${mid}`);
        const teamData = await teamResp.json();
        if (teamData.pre_season) {
          document.getElementById('seasonInitSection').style.display = 'none';
          document.getElementById('seasonGWView').style.display = 'none';
          document.getElementById('preSeasonPanel').style.display = 'block';
          loadPreseasonResult();
          return;
        }
      } catch(e) { /* ignore */ }

      document.getElementById('seasonInitSection').style.display = 'block';
      document.getElementById('seasonGWView').style.display = 'none';
      document.getElementById('preSeasonPanel').style.display = 'none';
      return;
    }

    document.getElementById('seasonInitSection').style.display = 'none';
    document.getElementById('preSeasonPanel').style.display = 'none';
    document.getElementById('seasonGWView').style.display = 'block';

    renderGWHeader(data);
    const content = document.getElementById('gwPhaseContent');

    switch (data.phase) {
      case 'planning': renderPlanningPhase(content, data); break;
      case 'ready': renderReadyPhase(content, data); break;
      case 'live': renderLivePhase(content, data); break;
      case 'complete': renderCompletePhase(content, data); break;
      case 'season_over': renderSeasonOverPhase(content, data); break;
      default: content.innerHTML = `<div class="phase-spinner"><div class="spinner-text">Unknown phase: ${data.phase}</div></div>`;
    }

    loadGWHistory(mid);
    setupSeasonV2Poll(data);
  } catch(e) {
    console.error('loadSeasonV2 error:', e);
  }
}

function setupSeasonV2Poll(data) {
  clearSeasonV2Poll();
  // Poll in READY (60s for injury alerts) and LIVE (60s for phase change)
  const phase = data.phase;
  if (phase === 'ready' || phase === 'live') {
    _seasonV2PollTimer = setInterval(() => {
      const seasonPanel = document.getElementById('seasonPanel');
      if (!seasonPanel || !seasonPanel.classList.contains('visible')) {
        clearSeasonV2Poll();
        return;
      }
      loadSeasonV2();
    }, 60000);
  }
}

function renderGWHeader(data) {
  const el = document.getElementById('gwHeader');
  // In COMPLETE phase, show the completed GW (current_gw), not next GW
  const gw = (data.phase === 'complete' ? data.current_gw : data.gw) || '?';
  const phase = data.phase || 'planning';
  const phaseLabel = {
    planning: 'Planning', ready: 'Ready', live: 'Live',
    complete: 'Complete', season_over: 'Season Over'
  }[phase] || phase;

  let deadlineHtml = '';
  if (data.deadline && !data.deadline_passed) {
    const dl = new Date(data.deadline);
    const now = new Date();
    const diffMs = dl - now;
    if (diffMs > 0) {
      const days = Math.floor(diffMs / 86400000);
      const hours = Math.floor((diffMs % 86400000) / 3600000);
      const mins = Math.floor((diffMs % 3600000) / 60000);
      let timeStr = '';
      if (days > 0) timeStr += `${days}d `;
      timeStr += `${hours}h ${mins}m`;
      const deadlineFormatted = dl.toLocaleString('en-GB', {weekday:'short', day:'numeric', month:'short', hour:'2-digit', minute:'2-digit'});
      deadlineHtml = `<div class="gw-deadline">Deadline: <strong>${deadlineFormatted}</strong> (${timeStr})</div>`;
    }
  } else if (data.deadline_passed) {
    deadlineHtml = `<div class="gw-deadline" style="color:var(--red)">Deadline passed</div>`;
  }

  el.innerHTML = `
    <div class="gw-header-title">GW ${gw}</div>
    <span class="phase-badge ${phase}">${phaseLabel}</span>
    ${deadlineHtml}
  `;
}

// --- Phase: PLANNING ---
function renderPlanningPhase(el, data) {
  const isRunning = document.querySelector('.progress-spinner.running') !== null;
  if (isRunning) {
    el.innerHTML = `
      <div class="phase-spinner">
        <div class="spinner-ring"></div>
        <div class="spinner-text">Generating recommendations for GW${data.gw}...</div>
        <div class="spinner-sub">This runs data refresh, model predictions, and transfer optimization.</div>
      </div>
    `;
  } else {
    el.innerHTML = `
      <div style="text-align:center;padding:48px 24px">
        <div style="font-size:18px;font-weight:600;margin-bottom:8px">Ready to plan GW${data.gw}</div>
        <div style="font-size:14px;color:var(--text2);margin-bottom:20px">Generates predictions, runs transfer optimization, and picks captain.</div>
        <button class="btn btn-primary" onclick="triggerV2Tick()">Start Planning</button>
      </div>
    `;
  }
}

async function triggerV2Tick() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  try {
    const resp = await fetch('/api/v2/season/tick', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({manager_id: parseInt(mid)}),
    });
    const d = await resp.json();
    if (d.error) { alert(d.error); return; }
    // SSE will show progress; task_done will trigger loadSeasonV2
  } catch(e) { alert('Failed to start tick: ' + e.message); }
}

// --- Phase: READY (main view) ---
function renderReadyPhase(el, data) {
  const ps = data.planned_squad;
  if (!ps || !ps.squad_json) {
    el.innerHTML = `<div class="phase-spinner">
      <div class="spinner-text">No planned squad found.</div>
      <div style="margin-top:12px"><button class="btn btn-primary" onclick="triggerV2Tick()">Generate Plan</button></div>
    </div>`;
    return;
  }

  const sq = ps.squad_json;
  const players = sq.players || [];
  const starters = players.filter(p => p.starter);
  const bench = players.filter(p => !p.starter);
  const transfersIn = sq.transfers_in || [];
  const transfersOut = sq.transfers_out || [];
  const captainId = sq.captain_id;
  const chip = sq.chip;
  const source = ps.source || 'recommended';
  const hits = sq.hits || 0;
  const freeFTs = sq.free_transfers || 1;
  const predictedPts = sq.predicted_points;
  const bank = sq.bank;

  let html = '';

  // Source badge
  const sourceLabel = source === 'user_override' ? 'Your Overrides' : 'Recommended';
  const sourceClass = source === 'user_override' ? 'user_override' : 'recommended';
  html += `<div style="margin-bottom:16px"><span class="source-badge ${sourceClass}">${sourceLabel}</span></div>`;

  // --- Transfers section ---
  html += '<div class="ready-section">';
  html += '<h4><span class="section-icon">&#x1F504;</span> Transfers</h4>';

  if (transfersIn.length > 0 && transfersOut.length > 0) {
    html += '<div class="transfer-cards">';
    const maxLen = Math.max(transfersIn.length, transfersOut.length);
    for (let i = 0; i < maxLen; i++) {
      const pOut = transfersOut[i] || {};
      const pIn = transfersIn[i] || {};
      html += `<div class="transfer-card">
        <div class="transfer-player out">
          <div class="tp-name">${pOut.web_name || '?'}</div>
          <div class="tp-meta">${pOut.position || ''} &middot; ${pOut.team_code || ''} &middot; ${pOut.cost != null ? Number(pOut.cost).toFixed(1) + 'm' : ''}</div>
          <div class="tp-pred">${pOut.predicted_next_gw_points != null ? Number(pOut.predicted_next_gw_points).toFixed(1) + ' pts' : ''}</div>
        </div>
        <div class="transfer-arrow">&rarr;</div>
        <div class="transfer-player in">
          <div class="tp-name">${pIn.web_name || '?'}</div>
          <div class="tp-meta">${pIn.position || ''} &middot; ${pIn.team_code || ''} &middot; ${pIn.cost != null ? Number(pIn.cost).toFixed(1) + 'm' : ''}</div>
          <div class="tp-pred">${pIn.predicted_next_gw_points != null ? Number(pIn.predicted_next_gw_points).toFixed(1) + ' pts' : ''}</div>
        </div>
      </div>`;
    }
    html += '</div>';

    // Transfer cost info
    const nTransfers = Math.max(transfersIn.length, transfersOut.length);
    if (chip === 'wildcard' || chip === 'freehit') {
      const chipLabel = chip === 'wildcard' ? 'Wildcard' : 'Free Hit';
      html += `<div class="transfer-cost-info">Transfers: <strong>${nTransfers}</strong> &mdash; <span style="color:var(--green)">All free (${chipLabel})</span></div>`;
    } else if (hits > 0) {
      const hitCost = hits * 4;
      html += `<div class="transfer-cost-info">Transfers: <strong>${nTransfers}</strong> &mdash; <span style="color:var(--green)">${freeFTs} free</span> + <span style="color:var(--red);font-weight:600">${hits} hit${hits > 1 ? 's' : ''} (-${hitCost}pts)</span></div>`;
    } else {
      html += `<div class="transfer-cost-info">Transfers: <strong>${nTransfers}</strong> &mdash; <span style="color:var(--green)">${nTransfers} of ${freeFTs} free transfer${freeFTs > 1 ? 's' : ''} used</span></div>`;
    }
  } else {
    html += '<div class="no-transfer-msg">Recommendation: Bank your free transfer</div>';
  }

  // Transfer action buttons
  html += `<div class="action-buttons">
    <button class="btn btn-primary" onclick="acceptTransfersV2()">Accept Recommendations</button>
    <button class="btn" onclick="openMultiTransferModal()">Make My Own Transfers</button>
    ${source === 'user_override' ? '<button class="btn" onclick="undoTransfersV2()">Reset to Recommendations</button>' : ''}
  </div>`;
  html += '</div>';

  // --- Captain section ---
  const captainPlayer = starters.find(p => p.player_id === captainId);
  html += '<div class="ready-section">';
  html += '<h4><span class="section-icon">&#x00A9;</span> Captain</h4>';
  if (captainPlayer) {
    html += `<div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
      <div style="background:var(--surface2);border:2px solid #ef4444;border-radius:8px;padding:10px 14px;display:inline-block">
        <div style="font-weight:700;font-size:16px">${captainPlayer.web_name} <span class="captain-badge">(C)</span></div>
        <div style="font-size:12px;color:var(--text2)">${captainPlayer.position || ''} &middot; ${captainPlayer.cost != null ? Number(captainPlayer.cost).toFixed(1) + 'm' : ''}</div>
        <div style="font-size:14px;font-weight:600;color:var(--green);margin-top:4px">${captainPlayer.predicted_next_gw_points != null ? Number(captainPlayer.predicted_next_gw_points).toFixed(1) + ' pts predicted' : ''}</div>
      </div>
      <button class="btn" onclick="toggleCaptainPicker()" style="font-size:11px">Change Captain</button>
    </div>`;
  } else {
    html += '<div style="color:var(--text2);font-size:13px">No captain selected</div>';
  }
  html += '<div id="captainPickerContainer" style="display:none"></div>';
  html += '</div>';

  // --- Squad section (starters + bench) ---
  html += '<div class="ready-section">';
  html += '<h4><span class="section-icon">&#x26BD;</span> Starting XI</h4>';
  html += '<div class="squad-grid">';
  const posOrder = {GKP: 0, DEF: 1, MID: 2, FWD: 3};
  starters.sort((a, b) => (posOrder[a.position] || 9) - (posOrder[b.position] || 9));
  starters.forEach(p => {
    const isCap = p.player_id === captainId;
    const isVc = p.player_id === sq.vice_captain_id;
    let cls = 'squad-player';
    if (isCap) cls += ' captain';
    else if (isVc) cls += ' vice-captain';
    const badge = isCap ? ' (C)' : (isVc ? ' (V)' : '');
    html += `<div class="${cls}">
      <div class="sp-name">${p.web_name || '?'}${badge}</div>
      <div class="sp-meta">${p.position || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
      <div class="sp-pts">${p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) + ' pts' : '-'}</div>
    </div>`;
  });
  html += '</div>';

  if (bench.length) {
    html += '<h4 style="margin-top:12px;font-size:12px;color:var(--text2);text-transform:uppercase">Bench</h4>';
    html += '<div class="squad-grid">';
    bench.sort((a, b) => {
      if (a.position === 'GKP' && b.position !== 'GKP') return -1;
      if (a.position !== 'GKP' && b.position === 'GKP') return 1;
      return (b.predicted_next_gw_points || 0) - (a.predicted_next_gw_points || 0);
    });
    bench.forEach(p => {
      html += `<div class="squad-player">
        <div class="sp-name">${p.web_name || '?'}</div>
        <div class="sp-meta">${p.position || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
        <div class="sp-pts" style="color:var(--text2)">${p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) + ' pts' : '-'}</div>
      </div>`;
    });
    html += '</div>';
  }
  html += '</div>';

  // --- Pitch visualization ---
  html += '<div class="ready-section">';
  html += '<h4><span class="section-icon">&#x26BD;</span> Pitch View</h4>';
  const fwd = starters.filter(p => p.position === 'FWD');
  const mid = starters.filter(p => p.position === 'MID');
  const def_ = starters.filter(p => p.position === 'DEF');
  const gkp = starters.filter(p => p.position === 'GKP');
  function readyPitchCard(p) {
    let pts;
    if (p.predicted_next_gw_points != null) {
      let rawPred = Number(p.predicted_next_gw_points);
      if (p.is_captain || p.player_id === captainId) rawPred *= 2;
      pts = rawPred.toFixed(1);
    } else { pts = '-'; }
    let badge = '';
    let cardStyle = '';
    if (p.is_captain || p.player_id === captainId) {
      cardStyle = 'border:2px solid #ef4444;box-shadow:0 0 8px rgba(239,68,68,0.4)';
      badge = ' <span class="captain-badge">(C)</span>';
    } else if (p.is_vice_captain || p.player_id === sq.vice_captain_id) {
      badge = ' <span class="vc-badge">(V)</span>';
    }
    return `<div class="pitch-card" style="${cardStyle}">
      <div class="p-name">${p.web_name || '-'}${badge}</div>
      <div class="p-team">${p.team || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
      <div class="p-pts" style="color:var(--green)">${pts}</div>
    </div>`;
  }
  html += `<div class="pitch">
    <div class="pitch-bottom-box"></div>
    <div class="pitch-row fwd">${fwd.map(p => readyPitchCard(p)).join('')}</div>
    <div class="pitch-row mid">${mid.map(p => readyPitchCard(p)).join('')}</div>
    <div class="pitch-row def">${def_.map(p => readyPitchCard(p)).join('')}</div>
    <div class="pitch-row gkp">${gkp.map(p => readyPitchCard(p)).join('')}</div>
  </div>`;
  if (bench.length) {
    const benchSorted = [...bench].sort((a, b) => {
      if (a.position === 'GKP' && b.position !== 'GKP') return -1;
      if (a.position !== 'GKP' && b.position === 'GKP') return 1;
      return (b.predicted_next_gw_points || 0) - (a.predicted_next_gw_points || 0);
    });
    html += `<div class="bench-area"><div class="bench-label">Bench</div>
      <div class="bench-row">${benchSorted.map(p => {
        const pred = p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-';
        return `<div class="bench-card">
          <div class="p-name">${p.web_name || '-'}</div>
          <div class="p-team">${p.team || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
          <div class="p-pts" style="font-size:13px">${pred}</div>
        </div>`;
      }).join('')}</div></div>`;
  }
  html += '</div>';

  // --- Chip section ---
  html += '<div class="ready-section">';
  html += '<h4><span class="section-icon">&#x1F0CF;</span> Chips</h4>';
  html += '<div class="chip-toggles">';
  const chipNames = ['bboost', '3xc', 'freehit', 'wildcard'];
  const chipLabels = {bboost: 'Bench Boost', '3xc': 'Triple Captain', freehit: 'Free Hit', wildcard: 'Wildcard'};
  const chipsUsed = data.chips_used || [];
  chipNames.forEach(c => {
    const isUsed = chipsUsed.includes(c);
    const isActive = chip === c;
    const cls = isUsed ? 'chip-toggle used' : isActive ? 'chip-toggle active' : 'chip-toggle';
    const disabled = isUsed ? 'disabled' : '';
    const onclick = isUsed ? '' : `onclick="toggleChipV2('${c}')"`;
    const label = isUsed ? `${chipLabels[c]} (Used)` : chipLabels[c];
    html += `<button class="${cls}" ${onclick} ${disabled}>${label}</button>`;
  });
  html += '</div>';
  if (chip) {
    html += `<div style="margin-top:8px;font-size:12px;color:var(--green)">Active chip: <strong>${chipLabels[chip] || chip}</strong></div>`;
  }
  html += '</div>';

  // --- Points summary ---
  html += '<div class="points-summary">';
  if (predictedPts != null) {
    html += `<div class="points-box highlight">
      <div class="pb-label">Predicted Points</div>
      <div class="pb-value">${Number(predictedPts).toFixed(1)}</div>
    </div>`;
  }
  if (bank != null) {
    html += `<div class="points-box">
      <div class="pb-label">Bank</div>
      <div class="pb-value">${Number(bank).toFixed(1)}m</div>
    </div>`;
  }
  html += `<div class="points-box">
    <div class="pb-label">Free Transfers</div>
    <div class="pb-value">${freeFTs}</div>
  </div>`;
  html += '</div>';

  el.innerHTML = html;
}

// --- Accept transfers ---
async function acceptTransfersV2() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  try {
    const resp = await fetch('/api/v2/season/accept-transfers', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({manager_id: parseInt(mid)}),
    });
    const d = await resp.json();
    if (d.error) { alert(d.error); return; }
    loadSeasonV2();
  } catch(e) { alert('Error: ' + e.message); }
}

// --- Undo transfers ---
async function undoTransfersV2() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  try {
    const resp = await fetch('/api/v2/season/undo-transfers', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({manager_id: parseInt(mid)}),
    });
    const d = await resp.json();
    if (d.error) { alert(d.error); return; }
    loadSeasonV2();
  } catch(e) { alert('Error: ' + e.message); }
}

// --- Captain picker ---
function toggleCaptainPicker() {
  const container = document.getElementById('captainPickerContainer');
  if (!container) return;
  if (container.style.display !== 'none') {
    container.style.display = 'none';
    return;
  }
  container.style.display = 'block';

  const ps = _seasonV2StatusCache?.planned_squad;
  if (!ps || !ps.squad_json) return;

  const players = (ps.squad_json.players || []).filter(p => p.starter);
  players.sort((a, b) => (b.captain_score || b.predicted_next_gw_points || 0) - (a.captain_score || a.predicted_next_gw_points || 0));

  let html = '<div class="captain-picker">';
  players.forEach(p => {
    const isCurrent = p.player_id === ps.squad_json.captain_id;
    const cls = isCurrent ? 'captain-option selected' : 'captain-option';
    html += `<div class="${cls}" onclick="setCaptainV2(${p.player_id})">
      <div class="co-name">${p.web_name || '?'}${isCurrent ? ' (C)' : ''}</div>
      <div class="co-meta">${p.position || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
      <div class="co-pts">${p.captain_score != null ? Number(p.captain_score).toFixed(1) : (p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-')} cap score</div>
    </div>`;
  });
  html += '</div>';
  container.innerHTML = html;
}

async function setCaptainV2(playerId) {
  const mid = getSeasonManagerId();
  if (!mid) return;
  try {
    const resp = await fetch('/api/v2/season/set-captain', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({manager_id: parseInt(mid), player_id: playerId}),
    });
    const d = await resp.json();
    if (d.error) { alert(d.error); return; }
    loadSeasonV2();
  } catch(e) { alert('Error: ' + e.message); }
}

// --- Chip toggle ---
async function toggleChipV2(chipName) {
  const mid = getSeasonManagerId();
  if (!mid) return;

  const ps = _seasonV2StatusCache?.planned_squad;
  const currentChip = ps?.squad_json?.chip;

  try {
    if (currentChip === chipName) {
      // Unlock
      const resp = await fetch('/api/v2/season/unlock-chip', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({manager_id: parseInt(mid)}),
      });
      const d = await resp.json();
      if (d.error) { alert(d.error); return; }
    } else {
      // Lock
      const resp = await fetch('/api/v2/season/lock-chip', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({manager_id: parseInt(mid), chip: chipName}),
      });
      const d = await resp.json();
      if (d.error) { alert(d.error); return; }
    }
    loadSeasonV2();
  } catch(e) { alert('Error: ' + e.message); }
}

// --- Multi-Transfer Modal ---
function openMultiTransferModal() {
  const ps = _seasonV2StatusCache?.planned_squad;
  if (!ps || !ps.squad_json) { alert('No planned squad data.'); return; }
  _multiTransferState = { phase: 'sell', playersOut: [], playersIn: [], allCandidates: [], buyingPosition: null };
  renderMultiTransferModal();
}

function closeMultiTransferModal() {
  _multiTransferState = null;
  const overlay = document.getElementById('transferModalOverlay');
  if (overlay) overlay.remove();
}

function renderMultiTransferModal() {
  let overlay = document.getElementById('transferModalOverlay');
  if (overlay) overlay.remove();

  const ps = _seasonV2StatusCache?.planned_squad;
  if (!ps || !ps.squad_json) return;
  const st = _multiTransferState;
  if (!st) return;

  const sq = ps.squad_json;
  const players = sq.players || [];
  const bank = sq.bank || 0;
  const posOrder = {GKP: 0, DEF: 1, MID: 2, FWD: 3};

  overlay = document.createElement('div');
  overlay.id = 'transferModalOverlay';
  overlay.className = 'transfer-modal-overlay';
  overlay.onclick = function(e) { if (e.target === overlay) closeMultiTransferModal(); };

  // Step indicator
  const steps = ['SELL', 'BUY', 'CONFIRM'];
  const phaseIdx = {sell: 0, buy: 1, confirm: 2}[st.phase];
  let stepHtml = '<div class="mt-steps">';
  steps.forEach((s, i) => {
    const cls = i === phaseIdx ? 'mt-step active' : i < phaseIdx ? 'mt-step done' : 'mt-step';
    stepHtml += `<div class="${cls}">${s}</div>`;
  });
  stepHtml += '</div>';

  let html = `<div class="transfer-modal" style="max-width:560px">
    <div class="transfer-modal-header">
      <h3>Make Transfers</h3>
      <button class="transfer-modal-close" onclick="closeMultiTransferModal()">&times;</button>
    </div>
    <div class="transfer-modal-body">
    ${stepHtml}`;

  if (st.phase === 'sell') {
    // Budget bar
    const salesVal = st.playersOut.reduce((s, p) => s + (p.cost || 0), 0);
    const afterSales = round1(bank + salesVal);
    html += `<div class="mt-budget-bar">
      <span>Bank: <strong>${bank.toFixed(1)}m</strong></span>
      <span>After sales: <strong style="color:var(--green)">${afterSales.toFixed(1)}m</strong></span>
    </div>`;

    // Selected chips
    if (st.playersOut.length) {
      html += '<div class="mt-chips">';
      st.playersOut.forEach(p => {
        html += `<span class="mt-chip out" onclick="toggleSellPlayer(${p.player_id})">${p.web_name} &times;</span>`;
      });
      html += '</div>';
    }

    // Player list
    html += '<div class="mt-player-list">';
    const outIds = new Set(st.playersOut.map(p => p.player_id));
    const sorted = [...players].sort((a, b) => (posOrder[a.position] || 9) - (posOrder[b.position] || 9));
    sorted.forEach(p => {
      const sel = outIds.has(p.player_id);
      html += `<div class="modal-squad-player ${sel ? 'selected-out' : ''}" onclick="toggleSellPlayer(${p.player_id})">
        <div>
          <span style="font-weight:600">${p.web_name || '?'}</span>
          <span class="pos-tag ${p.position}" style="margin-left:6px">${p.position || ''}</span>
        </div>
        <div style="text-align:right">
          <div style="font-size:12px;color:var(--text2)">${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
          <div style="font-size:12px;color:var(--green)">${p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) + ' pts' : ''}</div>
        </div>
      </div>`;
    });
    html += '</div>';

    html += `<div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
      <button class="btn" onclick="closeMultiTransferModal()">Cancel</button>
      <button class="btn btn-primary" onclick="mtGoToBuy()" ${st.playersOut.length < 1 ? 'disabled style="opacity:0.5"' : ''}>Next</button>
    </div>`;

  } else if (st.phase === 'buy') {
    // Calculate position needs
    const posNeeds = {};
    st.playersOut.forEach(p => { posNeeds[p.position] = (posNeeds[p.position] || 0) + 1; });
    st.playersIn.forEach(p => { posNeeds[p.position] = (posNeeds[p.position] || 0) - 1; });
    // Remove filled positions
    Object.keys(posNeeds).forEach(k => { if (posNeeds[k] <= 0) delete posNeeds[k]; });

    const salesVal = st.playersOut.reduce((s, p) => s + (p.cost || 0), 0);
    const spentVal = st.playersIn.reduce((s, p) => s + (p.cost || 0), 0);
    const available = round1(bank + salesVal - spentVal);

    html += `<div class="mt-budget-bar">
      <span>Available: <strong style="color:var(--green)">${available.toFixed(1)}m</strong></span>
      <span>Spent: <strong>${spentVal.toFixed(1)}m</strong></span>
    </div>`;

    // Bought chips
    if (st.playersIn.length) {
      html += '<div class="mt-chips">';
      st.playersIn.forEach(p => {
        html += `<span class="mt-chip in">${p.web_name}</span>`;
      });
      html += '</div>';
    }

    // Position need pills
    const allNeededPos = Object.keys(posNeeds);
    if (allNeededPos.length) {
      const curBuyPos = st.buyingPosition || allNeededPos[0];
      html += '<div class="mt-pos-pills">';
      allNeededPos.forEach(pos => {
        const count = posNeeds[pos];
        const active = pos === curBuyPos ? ' active' : '';
        html += `<button class="mt-pos-pill${active}" onclick="mtSetBuyPosition('${pos}')">${pos} x${count}</button>`;
      });
      html += '</div>';

      // Search + player list
      html += `<input type="text" class="search-box" placeholder="Search player..." oninput="mtFilterBuyCandidates(this.value)" style="width:100%;margin-bottom:8px" id="mtBuySearch">`;
      html += '<div class="available-player-list" id="mtBuyList"><div style="padding:12px;color:var(--text2);text-align:center">Loading players...</div></div>';
    } else {
      html += '<div style="padding:16px;text-align:center;color:var(--green);font-weight:600">All positions filled! Proceed to confirm.</div>';
    }

    html += `<div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
      <button class="btn" onclick="closeMultiTransferModal()">Cancel</button>
      <button class="btn" onclick="mtBackToSell()">Back</button>
      ${!allNeededPos.length ? '<button class="btn btn-primary" onclick="mtGoToConfirm()">Next</button>' : ''}
    </div>`;

  } else if (st.phase === 'confirm') {
    const salesVal = st.playersOut.reduce((s, p) => s + (p.cost || 0), 0);
    const spentVal = st.playersIn.reduce((s, p) => s + (p.cost || 0), 0);
    const newBank = round1(bank + salesVal - spentVal);
    const freeFTs = sq.free_transfers || 1;
    const existingTransfers = (sq.transfers_in || []).length;
    const totalTransfers = existingTransfers + st.playersOut.length;
    const hits = Math.max(0, totalTransfers - freeFTs);

    html += '<div class="mt-confirm-list">';
    // Match by position for display
    const outByPos = {};
    st.playersOut.forEach(p => { (outByPos[p.position] = outByPos[p.position] || []).push(p); });
    const inByPos = {};
    st.playersIn.forEach(p => { (inByPos[p.position] = inByPos[p.position] || []).push(p); });

    Object.keys(outByPos).forEach(pos => {
      const outs = outByPos[pos] || [];
      const ins = inByPos[pos] || [];
      for (let i = 0; i < outs.length; i++) {
        const pOut = outs[i] || {};
        const pIn = ins[i] || {};
        html += `<div class="mt-confirm-row">
          <div class="mt-confirm-player out">
            <span class="pos-tag ${pos}">${pos}</span>
            <span>${pOut.web_name || '?'}</span>
            <span style="color:var(--text2)">${(pOut.cost || 0).toFixed(1)}m</span>
          </div>
          <span class="transfer-arrow">&rarr;</span>
          <div class="mt-confirm-player in">
            <span>${pIn.web_name || '?'}</span>
            <span style="color:var(--text2)">${(pIn.cost || 0).toFixed(1)}m</span>
          </div>
        </div>`;
      }
    });
    html += '</div>';

    html += `<div class="mt-confirm-summary">
      <div>Net cost: <strong>${(spentVal - salesVal) > 0 ? '+' : ''}${round1(spentVal - salesVal).toFixed(1)}m</strong></div>
      <div>New bank: <strong style="color:var(--green)">${newBank.toFixed(1)}m</strong></div>
      ${hits > 0 ? `<div style="color:var(--red)">Hits: <strong>${hits} (-${hits * 4}pts)</strong></div>` : ''}
    </div>`;

    html += `<div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
      <button class="btn" onclick="closeMultiTransferModal()">Cancel</button>
      <button class="btn" onclick="mtBackToBuy()">Back</button>
      <button class="btn btn-primary" onclick="mtConfirmTransfers()" id="mtConfirmBtn">Confirm Transfers</button>
    </div>`;
  }

  html += '</div></div>';
  overlay.innerHTML = html;
  document.body.appendChild(overlay);

  // Load buy candidates if in buy phase with unfilled positions
  if (st.phase === 'buy') {
    const posNeeds = {};
    st.playersOut.forEach(p => { posNeeds[p.position] = (posNeeds[p.position] || 0) + 1; });
    st.playersIn.forEach(p => { posNeeds[p.position] = (posNeeds[p.position] || 0) - 1; });
    Object.keys(posNeeds).forEach(k => { if (posNeeds[k] <= 0) delete posNeeds[k]; });
    if (Object.keys(posNeeds).length) {
      const pos = st.buyingPosition || Object.keys(posNeeds)[0];
      if (!st.buyingPosition) st.buyingPosition = pos;
      mtLoadBuyCandidates(pos);
    }
  }
}

function round1(n) { return Math.round(n * 10) / 10; }

function toggleSellPlayer(playerId) {
  const st = _multiTransferState;
  if (!st) return;
  const idx = st.playersOut.findIndex(p => p.player_id === playerId);
  if (idx >= 0) {
    st.playersOut.splice(idx, 1);
  } else {
    const ps = _seasonV2StatusCache?.planned_squad;
    if (!ps || !ps.squad_json) return;
    const player = (ps.squad_json.players || []).find(p => p.player_id === playerId);
    if (player) st.playersOut.push({...player});
  }
  // Reset buy state when sell changes
  st.playersIn = [];
  st.buyingPosition = null;
  renderMultiTransferModal();
}

function mtGoToBuy() {
  const st = _multiTransferState;
  if (!st || st.playersOut.length < 1) return;
  st.phase = 'buy';
  st.playersIn = [];
  st.buyingPosition = null;
  renderMultiTransferModal();
}

function mtBackToSell() {
  const st = _multiTransferState;
  if (!st) return;
  st.phase = 'sell';
  st.playersIn = [];
  st.buyingPosition = null;
  renderMultiTransferModal();
}

function mtBackToBuy() {
  const st = _multiTransferState;
  if (!st) return;
  st.phase = 'buy';
  renderMultiTransferModal();
}

function mtGoToConfirm() {
  const st = _multiTransferState;
  if (!st) return;
  st.phase = 'confirm';
  renderMultiTransferModal();
}

function mtSetBuyPosition(pos) {
  const st = _multiTransferState;
  if (!st) return;
  st.buyingPosition = pos;
  renderMultiTransferModal();
}

async function mtLoadBuyCandidates(position) {
  const st = _multiTransferState;
  if (!st) return;

  const ps = _seasonV2StatusCache?.planned_squad;
  if (!ps || !ps.squad_json) return;
  const sq = ps.squad_json;

  // Current squad IDs minus sells plus buys
  const outIds = new Set(st.playersOut.map(p => p.player_id));
  const inIds = new Set(st.playersIn.map(p => p.player_id));
  const currentIds = new Set((sq.players || []).filter(p => !outIds.has(p.player_id)).map(p => p.player_id));
  inIds.forEach(id => currentIds.add(id));

  // Budget
  const bank = sq.bank || 0;
  const salesVal = st.playersOut.reduce((s, p) => s + (p.cost || 0), 0);
  const spentVal = st.playersIn.reduce((s, p) => s + (p.cost || 0), 0);
  const available = round1(bank + salesVal - spentVal);

  // Team counts (remaining + bought)
  const teamCounts = {};
  (sq.players || []).forEach(p => {
    if (outIds.has(p.player_id)) return;
    const tc = p.team_code || 0;
    teamCounts[tc] = (teamCounts[tc] || 0) + 1;
  });
  st.playersIn.forEach(p => {
    const tc = p.team_code || 0;
    teamCounts[tc] = (teamCounts[tc] || 0) + 1;
  });

  try {
    const resp = await fetch('/api/predictions');
    const data = await resp.json();
    const allPlayers = data.players || [];

    let candidates = allPlayers.filter(p => {
      if (currentIds.has(p.player_id)) return false;
      if (p.position !== position) return false;
      if (p.cost > available) return false;
      const tc = p.team_code || 0;
      if ((teamCounts[tc] || 0) >= 3) return false;
      return true;
    });

    candidates.sort((a, b) => (b.predicted_next_gw_points || 0) - (a.predicted_next_gw_points || 0));
    candidates = candidates.slice(0, 50);
    st.allCandidates = candidates;
    mtRenderBuyList(candidates);
  } catch(e) {
    const list = document.getElementById('mtBuyList');
    if (list) list.innerHTML = '<div style="padding:12px;color:var(--red)">Error loading players</div>';
  }
}

function mtRenderBuyList(candidates) {
  const list = document.getElementById('mtBuyList');
  if (!list) return;
  if (!candidates.length) {
    list.innerHTML = '<div style="padding:12px;color:var(--text2)">No available players found</div>';
    return;
  }
  let html = '';
  candidates.forEach(p => {
    html += `<div class="available-player-row" onclick="mtSelectBuyPlayer(${p.player_id})">
      <div>
        <div class="apr-name">${p.web_name || '?'}</div>
        <div class="apr-meta">${p.position || ''} &middot; ${p.team || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
      </div>
      <div class="apr-pts">${p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) + ' pts' : '-'}</div>
    </div>`;
  });
  list.innerHTML = html;
}

function mtFilterBuyCandidates(query) {
  const st = _multiTransferState;
  if (!st) return;
  const candidates = st.allCandidates || [];
  if (!query) { mtRenderBuyList(candidates); return; }
  const q = query.toLowerCase();
  mtRenderBuyList(candidates.filter(p => (p.web_name || '').toLowerCase().includes(q)));
}

function mtSelectBuyPlayer(playerId) {
  const st = _multiTransferState;
  if (!st) return;
  const player = (st.allCandidates || []).find(p => p.player_id === playerId);
  if (!player) return;
  st.playersIn.push({...player});

  // Check if all positions filled
  const posNeeds = {};
  st.playersOut.forEach(p => { posNeeds[p.position] = (posNeeds[p.position] || 0) + 1; });
  st.playersIn.forEach(p => { posNeeds[p.position] = (posNeeds[p.position] || 0) - 1; });
  Object.keys(posNeeds).forEach(k => { if (posNeeds[k] <= 0) delete posNeeds[k]; });

  if (!Object.keys(posNeeds).length) {
    st.phase = 'confirm';
    st.buyingPosition = null;
  } else {
    // Move to next unfilled position
    st.buyingPosition = Object.keys(posNeeds)[0];
  }
  renderMultiTransferModal();
}

async function mtConfirmTransfers() {
  const st = _multiTransferState;
  if (!st) return;
  const mid = getSeasonManagerId();
  if (!mid) return;

  const btn = document.getElementById('mtConfirmBtn');
  if (btn) { btn.disabled = true; btn.textContent = 'Processing...'; }

  try {
    const resp = await fetch('/api/v2/season/make-transfers', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        manager_id: parseInt(mid),
        players_out: st.playersOut.map(p => p.player_id),
        players_in: st.playersIn.map(p => p.player_id),
      }),
    });
    const d = await resp.json();
    if (d.error) { alert(d.error); if (btn) { btn.disabled = false; btn.textContent = 'Confirm Transfers'; } return; }
    closeMultiTransferModal();
    loadSeasonV2();
  } catch(e) {
    alert('Error: ' + e.message);
    if (btn) { btn.disabled = false; btn.textContent = 'Confirm Transfers'; }
  }
}

// --- Phase: LIVE ---
function renderLivePhase(el, data) {
  const ps = data.planned_squad;
  let squadHtml = '';

  if (ps && ps.squad_json && ps.squad_json.players) {
    const players = ps.squad_json.players;
    const starters = players.filter(p => p.starter);
    const bench = players.filter(p => !p.starter);
    const posOrder = {GKP: 0, DEF: 1, MID: 2, FWD: 3};
    starters.sort((a, b) => (posOrder[a.position] || 9) - (posOrder[b.position] || 9));

    squadHtml = '<div class="ready-section"><h4>Your Planned Squad</h4>';
    squadHtml += '<table class="live-squad-table"><thead><tr><th>Player</th><th>Pos</th><th>Cost</th><th>Pred</th></tr></thead><tbody>';
    starters.forEach(p => {
      const badge = p.player_id === ps.squad_json.captain_id ? ' (C)' : (p.player_id === ps.squad_json.vice_captain_id ? ' (V)' : '');
      squadHtml += `<tr>
        <td style="font-weight:600">${p.web_name || '?'}${badge}</td>
        <td><span class="pos-tag ${p.position}">${p.position}</span></td>
        <td>${p.cost != null ? Number(p.cost).toFixed(1) : '-'}</td>
        <td style="color:var(--green)">${p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-'}</td>
      </tr>`;
    });
    squadHtml += '</tbody></table>';

    if (bench.length) {
      bench.sort((a, b) => (posOrder[a.position] || 9) - (posOrder[b.position] || 9));
      squadHtml += '<h4 style="margin-top:12px;font-size:12px;color:var(--text2);text-transform:uppercase">Bench</h4>';
      squadHtml += '<table class="live-squad-table"><thead><tr><th>Player</th><th>Pos</th><th>Cost</th><th>Pred</th></tr></thead><tbody>';
      bench.forEach(p => {
        squadHtml += `<tr>
          <td>${p.web_name || '?'}</td>
          <td><span class="pos-tag ${p.position}">${p.position}</span></td>
          <td>${p.cost != null ? Number(p.cost).toFixed(1) : '-'}</td>
          <td style="color:var(--text2)">${p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-'}</td>
        </tr>`;
      });
      squadHtml += '</tbody></table>';
    }
    squadHtml += '</div>';
  }

  el.innerHTML = `
    <div style="text-align:center;padding:24px 0;margin-bottom:16px">
      <div style="font-size:16px;font-weight:600;margin-bottom:4px">GW${data.gw} is live</div>
      <div style="font-size:13px;color:var(--text2)">The deadline has passed. Matches are in progress or upcoming.</div>
    </div>
    ${squadHtml}
  `;
}

// --- Phase: COMPLETE ---
function renderCompletePhase(el, data) {
  const isRunning = document.querySelector('.progress-spinner.running') !== null;
  if (isRunning) {
    el.innerHTML = `
      <div class="phase-spinner">
        <div class="spinner-ring"></div>
        <div class="spinner-text">GW${data.current_gw} complete. Recording results...</div>
        <div class="spinner-sub">Importing your actual picks and comparing to recommendations.</div>
      </div>
    `;
  } else {
    el.innerHTML = `
      <div style="text-align:center;padding:48px 24px">
        <div style="font-size:18px;font-weight:600;margin-bottom:8px">GW${data.current_gw} Complete</div>
        <div style="font-size:14px;color:var(--text2);margin-bottom:20px">All fixtures finished. Record your results to advance to GW${data.gw} planning.</div>
        <button class="btn btn-primary" onclick="triggerV2Tick()">Record Results</button>
      </div>
    `;
  }
}

// --- Phase: SEASON_OVER ---
function renderSeasonOverPhase(el, data) {
  el.innerHTML = `
    <div style="text-align:center;padding:48px 24px">
      <div style="font-size:24px;font-weight:700;margin-bottom:8px">Season Over</div>
      <div style="font-size:14px;color:var(--text2)">The FPL season has ended. Check your history below for a full season summary.</div>
    </div>
  `;
}

// --- GW History ---
async function loadGWHistory(mid) {
  if (!mid) mid = getSeasonManagerId();
  if (!mid) return;
  const container = document.getElementById('gwHistory');
  if (!container) return;

  try {
    const resp = await fetch(`/api/season/outcomes?manager_id=${mid}`);
    const d = await resp.json();
    const outcomes = d.outcomes || [];

    if (!outcomes.length) {
      container.innerHTML = '';
      return;
    }

    // Show last 8 GWs, newest first
    const recent = outcomes.slice(-8).reverse();

    let html = '<div class="ready-section"><h4>Recent History</h4>';
    html += '<table class="gw-history-table"><thead><tr><th>GW</th><th>Predicted</th><th>Actual</th><th>Delta</th><th>Captain</th></tr></thead><tbody>';
    recent.forEach(o => {
      const delta = o.point_delta || 0;
      const deltaColor = delta >= 0 ? 'var(--green)' : 'var(--red)';
      const deltaSign = delta >= 0 ? '+' : '';
      const captainIcon = o.followed_captain ? '<span style="color:var(--green)">&#x2714;</span>' : '<span style="color:var(--red)">&#x2718;</span>';
      html += `<tr>
        <td style="font-weight:600">GW${o.gameweek}</td>
        <td>${o.recommended_points != null ? Number(o.recommended_points).toFixed(1) : '-'}</td>
        <td style="font-weight:600">${o.actual_points || '-'}</td>
        <td style="color:${deltaColor};font-weight:600">${deltaSign}${Number(delta).toFixed(1)}</td>
        <td>${captainIcon}</td>
      </tr>`;
    });
    html += '</tbody></table></div>';
    container.innerHTML = html;
  } catch(e) {
    container.innerHTML = '';
  }
}

// --- Init / Delete V2 ---
async function initSeasonV2() {
  const mid = getSeasonManagerId();
  if (!mid) return alert('Enter a Manager ID');
  localStorage.setItem('fpl_manager_id', mid);
  try {
    const resp = await fetch('/api/v2/season/init', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({manager_id: parseInt(mid)}),
    });
    const d = await resp.json();
    if (d.error) { alert(d.error); return; }
    // SSE task_done will trigger loadSeasonV2
  } catch(e) { alert('Error: ' + e.message); }
}

async function deleteSeasonV2() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  if (!confirm('Delete all season data for this manager?')) return;
  try {
    const resp = await fetch('/api/v2/season/delete', {
      method: 'DELETE',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({manager_id: parseInt(mid)}),
    });
    const d = await resp.json();
    if (d.error) { alert(d.error); return; }
    document.getElementById('seasonInitSection').style.display = 'block';
    document.getElementById('seasonGWView').style.display = 'none';
  } catch(e) { alert('Error: ' + e.message); }
}


// ---------------------------------------------------------------------------
// Season Management (Legacy v1  retained for old code paths)
// ---------------------------------------------------------------------------

function checkSeasonStatus() {
  const mid = getSeasonManagerId();
  if (!mid) return;

  // Check if pre-season (no current event)
  fetch(`/api/my-team?manager_id=${mid}`)
    .then(r => r.json())
    .then(teamData => {
      if (teamData.pre_season) {
        // Pre-season mode
        document.getElementById('seasonInitSection').style.display = 'none';
        document.getElementById('seasonDashboard').style.display = 'none';
        document.getElementById('preSeasonPanel').style.display = 'block';
        loadPreseasonResult();
        return;
      }
      document.getElementById('preSeasonPanel').style.display = 'none';

      // Normal check
      fetch(`/api/season/status?manager_id=${mid}`)
        .then(r => r.json())
        .then(d => {
          if (d.active) {
            document.getElementById('seasonInitSection').style.display = 'none';
            document.getElementById('seasonDashboard').style.display = 'block';
            loadSeasonDashboard();
          } else {
            document.getElementById('seasonInitSection').style.display = 'block';
            document.getElementById('seasonDashboard').style.display = 'none';
          }
        });
    })
    .catch(() => {
      // If my-team fetch fails, fall back to season status check
      document.getElementById('preSeasonPanel').style.display = 'none';
      fetch(`/api/season/status?manager_id=${mid}`)
        .then(r => r.json())
        .then(d => {
          if (d.active) {
            document.getElementById('seasonInitSection').style.display = 'none';
            document.getElementById('seasonDashboard').style.display = 'block';
            loadSeasonDashboard();
          } else {
            document.getElementById('seasonInitSection').style.display = 'block';
            document.getElementById('seasonDashboard').style.display = 'none';
          }
        });
    });
}

function initSeason() {
  const mid = getSeasonManagerId();
  if (!mid) return alert('Enter a Manager ID');
  localStorage.setItem('fpl_manager_id', mid);
  fetch('/api/season/init', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid)}),
  }).then(r => r.json()).then(d => {
    if (d.error) return alert(d.error);
    // Will check status after task completes (SSE handler)
  });
}

function deleteSeason() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  if (!confirm('Delete all season data for this manager?')) return;
  fetch('/api/season/delete', {
    method: 'DELETE',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid)}),
  }).then(r => r.json()).then(() => {
    document.getElementById('seasonInitSection').style.display = 'block';
    document.getElementById('seasonDashboard').style.display = 'none';
  });
}

function switchSeasonSection(btn) {
  document.querySelectorAll('.season-sub-tab').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  const section = btn.dataset.section;
  document.querySelectorAll('.season-section').forEach(s => s.classList.remove('visible'));
  const sectionMap = {
    overview: 'seasonOverview',
    workflow: 'seasonWorkflow',
    fixtures: 'seasonFixtures',
    transfers: 'seasonTransfers',
    chips: 'seasonChips',
    prices: 'seasonPrices',
    strategy: 'seasonStrategy',
  };
  const el = document.getElementById(sectionMap[section]);
  if (el) el.classList.add('visible');

  // Load data for section
  if (section === 'overview' && lockedGWSquad && lastMyTeamData) { renderSeasonTeamView(lastMyTeamData); }
  if (section === 'workflow') { loadActionPlan(); loadOutcomes(); updateWorkflowSteps(); }
  if (section === 'fixtures') loadFixtures();
  if (section === 'transfers') loadTransferHistory();
  if (section === 'chips') loadChips();
  if (section === 'prices') loadPrices();
  if (section === 'strategy') { loadStrategicPlan(); checkPlanHealth(); }
}

function loadSeasonDashboard() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/dashboard?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      if (d.error) return;
      renderSeasonOverview(d);
    });
  // Also load team view
  fetch(`/api/my-team?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      if (d.error || !d.squad) return;
      lastMyTeamData = d;
      renderSeasonTeamView(d);
    });
}

function renderSeasonOverview(data) {
  const s = data.summary || {};
  const cards = document.getElementById('seasonSummaryCards');
  cards.innerHTML = `
    <div class="summary-card"><div class="sc-label">Overall Rank</div><div class="sc-value">${s.overall_rank ? s.overall_rank.toLocaleString() : '-'}</div></div>
    <div class="summary-card"><div class="sc-label">Total Points</div><div class="sc-value accent">${s.total_points ?? '-'}</div></div>
    <div class="summary-card"><div class="sc-label">Team Value</div><div class="sc-value">${s.team_value ? s.team_value.toFixed(1) + 'm' : '-'}</div></div>
    <div class="summary-card"><div class="sc-label">Bank</div><div class="sc-value green">${s.bank != null ? s.bank.toFixed(1) + 'm' : '-'}</div></div>
    <div class="summary-card"><div class="sc-label">Gameweek</div><div class="sc-value">${s.gameweek ?? '-'}</div></div>
  `;

  // Accuracy stats
  const acc = data.accuracy || {};
  const accDiv = document.getElementById('seasonAccuracy');
  if (acc.total > 0) {
    accDiv.innerHTML = `
      <div class="summary-card"><div class="sc-label">Recommendations</div><div class="sc-value">${acc.total}</div></div>
      <div class="summary-card"><div class="sc-label">Captain Followed</div><div class="sc-value">${acc.captain_followed || 0}/${acc.total}</div></div>
      <div class="summary-card"><div class="sc-label">Avg Point Delta</div><div class="sc-value">${acc.avg_delta != null ? acc.avg_delta.toFixed(1) : '-'}</div></div>
    `;
  } else {
    accDiv.innerHTML = '';
  }

  // Charts
  drawLineChart('rankChart', data.rank_history || [], 'gameweek', 'overall_rank', {
    invert: true, color: '#6c63ff', label: 'Rank'
  });
  drawBarChart('pointsChart', data.points_per_gw || [], 'gameweek', 'points', {
    color: '#2dd4a0', label: 'Points'
  });
  drawDualLineChart('accuracyChart', data.accuracy_history || [], 'gameweek',
    'predicted_points', 'actual_points', {
      color1: '#6c63ff', color2: '#2dd4a0', label1: 'Predicted', label2: 'Actual'
    });
}

function renderSeasonTeamView(d) {
  const container = document.getElementById('seasonTeamView');
  const starters = d.squad.filter(p => p.starter);
  const bench = d.squad.filter(p => !p.starter);
  const curGw = d.current_event || '?';
  const gwLabel = d.next_gw ? `GW${d.next_gw}` : 'Next GW';

  // Use locked squad for predicted side if available, otherwise optimized squad
  const useLocked = lockedGWSquad && lockedGWSquad.squad;
  const optSquad = d.optimized_squad || d.squad;
  const predSquad = useLocked ? lockedGWSquad.squad : optSquad;
  const predStarters = predSquad.filter(p => p.starter);
  const predBench = predSquad.filter(p => !p.starter);
  const predLabel = useLocked ? `Locked-in GW${lockedGWSquad.gameweek}` : `Optimal ${gwLabel}`;
  const predChipCtx = useLocked ? lockedGWSquad.chipCtx : null;

  // Total points this GW (include bench if Bench Boost active)
  // Actuals (event_points) already include captain multiplier  no extra bonus needed
  // Predictions (predicted_next_gw_points) are raw  add captain bonus
  const isBB = d.active_chip === 'bboost';
  const actualScorers = isBB ? d.squad : starters;
  const xiActual = actualScorers.reduce((s, p) => s + (p.event_points || 0), 0);
  const predScorers = (useLocked && lockedGWSquad.benchBoost) ? predSquad : predStarters;
  let xiPred = predScorers.reduce((s, p) => s + (p.predicted_next_gw_points || 0), 0);
  const predCap = predStarters.find(p => p.is_captain);
  // Captain bonus: +1x normal (2x total), +2x for TC (3x total)
  if (predCap) xiPred += (predCap.predicted_next_gw_points || 0) * (predChipCtx === '3xc' ? 2 : 1);

  function teamCard(p, mode, chipCtx) {
    const isActual = mode === 'actual';
    let pts;
    if (isActual) {
      pts = p.event_points != null ? Number(p.event_points).toFixed(0) : '-';
    } else if (p.predicted_next_gw_points != null) {
      let rawPred = Number(p.predicted_next_gw_points);
      if (p.is_captain) rawPred *= (chipCtx === '3xc' ? 3 : 2);
      pts = rawPred.toFixed(1);
    } else {
      pts = '-';
    }
    const ptsColor = isActual ? 'var(--orange)' : 'var(--green)';

    let badge = '';
    let cardStyle = '';
    if (p.is_captain) {
      cardStyle = 'border:2px solid #ef4444;box-shadow:0 0 8px rgba(239,68,68,0.4)';
      badge = ' <span class="captain-badge">(C)</span>';
    } else if (p.is_vice_captain) {
      badge = ' <span class="vc-badge">(V)</span>';
    }

    let extraClass = '';
    let statusHtml = '';
    if (p.status === 'i') {
      extraClass = ' injured';
      statusHtml = '<div class="p-avail injured">Injured</div>';
    } else if (p.status === 's') {
      extraClass = ' injured';
      statusHtml = '<div class="p-avail injured">Suspended</div>';
    } else if (p.chance_of_playing != null && p.chance_of_playing < 100) {
      extraClass = ' doubtful';
      statusHtml = `<div class="p-avail doubtful">${p.chance_of_playing}%</div>`;
    }

    return `<div class="pitch-card${extraClass}" style="${cardStyle}">
      <div class="p-name">${p.web_name || '-'}${badge}</div>
      <div class="p-team">${p.team || ''} &middot; ${Number(p.cost).toFixed(1)}m</div>
      <div class="p-pts" style="color:${ptsColor}">${pts}</div>
      ${!isActual && p.opponent ? `<span style="font-size:10px;color:var(--text2)">${p.opponent}</span>` : ''}
      ${statusHtml}
    </div>`;
  }

  function buildPitch(players, mode, chipCtx) {
    const fwd = players.filter(p => p.position === 'FWD');
    const mid = players.filter(p => p.position === 'MID');
    const def_ = players.filter(p => p.position === 'DEF');
    const gkp = players.filter(p => p.position === 'GKP');
    return `<div class="pitch">
      <div class="pitch-bottom-box"></div>
      <div class="pitch-row fwd">${fwd.map(p => teamCard(p, mode, chipCtx)).join('')}</div>
      <div class="pitch-row mid">${mid.map(p => teamCard(p, mode, chipCtx)).join('')}</div>
      <div class="pitch-row def">${def_.map(p => teamCard(p, mode, chipCtx)).join('')}</div>
      <div class="pitch-row gkp">${gkp.map(p => teamCard(p, mode, chipCtx)).join('')}</div>
    </div>`;
  }

  // Build bench HTML for each side
  let actualBenchHtml = '';
  if (bench.length) {
    actualBenchHtml = `<div class="bench-area"><div class="bench-label">Bench</div>
      <div class="bench-row">${bench.map(p => {
        const rawPts = p.event_points_raw != null ? Number(p.event_points_raw).toFixed(0) : (p.event_points != null ? Number(p.event_points).toFixed(0) : '-');
        return `<div class="bench-card">
          <div class="p-name">${p.web_name || '-'}</div>
          <div class="p-team">${p.team || ''} &middot; ${Number(p.cost).toFixed(1)}m</div>
          <div class="p-pts" style="color:var(--orange);font-size:13px">${rawPts}</div>
        </div>`;
      }).join('')}</div></div>`;
  }

  let predBenchHtml = '';
  if (predBench.length) {
    predBenchHtml = `<div class="bench-area"><div class="bench-label">Bench</div>
      <div class="bench-row">${predBench.map(p => {
        const pred = p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-';
        return `<div class="bench-card"${useLocked ? ' style="border:1px solid var(--green)"' : ''}>
          <div class="p-name">${p.web_name || '-'}</div>
          <div class="p-team">${p.team || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
          <div class="p-pts" style="font-size:13px">${pred}</div>
        </div>`;
      }).join('')}</div></div>`;
  }

  let html = `<div style="margin-bottom:20px">
    <div class="compare-pitches">
      <div class="compare-side">
        <h3 style="color:var(--orange)">GW${curGw} Actual${isBB ? ' [BB]' : ''} (${xiActual} pts)</h3>
        ${buildPitch(starters, 'actual')}
        ${actualBenchHtml}
      </div>
      <div class="compare-side">
        <h3 style="color:var(--green)">${predLabel} (${xiPred.toFixed(1)} pts)</h3>
        ${buildPitch(predStarters, 'predicted', predChipCtx)}
        ${predBenchHtml}
      </div>
    </div>`;

  html += '</div>';
  container.innerHTML = html;
}

// --- Canvas Chart Helpers ---

function drawLineChart(canvasId, data, xKey, yKey, opts = {}) {
  const canvas = document.getElementById(canvasId);
  if (!canvas || !data.length) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 180 * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = '180px';
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 180;
  const pad = {top: 10, right: 10, bottom: 25, left: 50};

  const xs = data.map(d => d[xKey]);
  const ys = data.map(d => d[yKey]).filter(v => v != null);
  if (!ys.length) return;

  let yMin = Math.min(...ys), yMax = Math.max(...ys);
  if (yMin === yMax) { yMin -= 1; yMax += 1; }
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;

  ctx.clearRect(0, 0, W, H);

  // Grid
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (chartH / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    let val = opts.invert ? yMin + ((yMax - yMin) / 4) * i : yMax - ((yMax - yMin) / 4) * i;
    ctx.fillStyle = '#8e91a4';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'right';
    const label = opts.decimals ? val.toFixed(opts.decimals) : Math.round(val).toLocaleString();
    ctx.fillText(label, pad.left - 6, y + 3);
  }

  // Line
  ctx.strokeStyle = opts.color || '#6c63ff';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.beginPath();
  let moved = false;
  data.forEach((d, i) => {
    if (d[yKey] == null) { moved = false; return; }
    const x = pad.left + (i / Math.max(data.length - 1, 1)) * chartW;
    const norm = opts.invert
      ? (d[yKey] - yMin) / (yMax - yMin)
      : 1 - (d[yKey] - yMin) / (yMax - yMin);
    const y = pad.top + norm * chartH;
    if (!moved) { ctx.moveTo(x, y); moved = true; } else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // X-axis labels
  ctx.fillStyle = '#8e91a4';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  const step = Math.max(1, Math.floor(data.length / 8));
  data.forEach((d, i) => {
    if (i % step === 0 || i === data.length - 1) {
      const x = pad.left + (i / Math.max(data.length - 1, 1)) * chartW;
      ctx.fillText('GW' + d[xKey], x, H - 4);
    }
  });
}

function drawBarChart(canvasId, data, xKey, yKey, opts = {}) {
  const canvas = document.getElementById(canvasId);
  if (!canvas || !data.length) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 180 * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = '180px';
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 180;
  const pad = {top: 10, right: 10, bottom: 25, left: 40};

  const ys = data.map(d => d[yKey] || 0);
  const yMax = Math.max(...ys, 1);
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;
  const barW = Math.max(2, (chartW / data.length) * 0.7);
  const gap = chartW / data.length;

  ctx.clearRect(0, 0, W, H);

  // Bars
  data.forEach((d, i) => {
    const val = d[yKey] || 0;
    const barH = (val / yMax) * chartH;
    const x = pad.left + i * gap + (gap - barW) / 2;
    const y = pad.top + chartH - barH;
    ctx.fillStyle = opts.color || '#2dd4a0';
    ctx.fillRect(x, y, barW, barH);
  });

  // Axes
  ctx.fillStyle = '#8e91a4';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  const step = Math.max(1, Math.floor(data.length / 8));
  data.forEach((d, i) => {
    if (i % step === 0 || i === data.length - 1) {
      const x = pad.left + i * gap + gap / 2;
      ctx.fillText('GW' + d[xKey], x, H - 4);
    }
  });
  ctx.textAlign = 'right';
  for (let i = 0; i <= 3; i++) {
    const y = pad.top + (chartH / 3) * i;
    const val = Math.round(yMax - (yMax / 3) * i);
    ctx.fillText(val, pad.left - 6, y + 3);
  }
}

function drawDualLineChart(canvasId, data, xKey, y1Key, y2Key, opts = {}) {
  const canvas = document.getElementById(canvasId);
  if (!canvas || !data.length) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 180 * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = '180px';
  ctx.scale(dpr, dpr);
  const W = rect.width, H = 180;
  const pad = {top: 10, right: 10, bottom: 25, left: 50};
  const y1s = data.map(d => d[y1Key]).filter(v => v != null);
  const y2s = data.map(d => d[y2Key]).filter(v => v != null);
  const allY = y1s.concat(y2s);
  if (!allY.length) return;
  let yMin = Math.min(...allY), yMax = Math.max(...allY);
  if (yMin === yMax) { yMin -= 1; yMax += 1; }
  const chartW = W - pad.left - pad.right;
  const chartH = H - pad.top - pad.bottom;
  ctx.clearRect(0, 0, W, H);
  // Grid
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (chartH / 4) * i;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    const val = yMax - ((yMax - yMin) / 4) * i;
    ctx.fillStyle = '#8e91a4'; ctx.font = '10px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText(Math.round(val), pad.left - 6, y + 3);
  }
  // Line 1 (predicted)
  const c1 = opts.color1 || '#6c63ff';
  ctx.strokeStyle = c1; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.beginPath();
  let m1 = false;
  data.forEach((d, i) => {
    if (d[y1Key] == null) { m1 = false; return; }
    const x = pad.left + (i / Math.max(data.length - 1, 1)) * chartW;
    const y = pad.top + (1 - (d[y1Key] - yMin) / (yMax - yMin)) * chartH;
    if (!m1) { ctx.moveTo(x, y); m1 = true; } else ctx.lineTo(x, y);
  }); ctx.stroke();
  // Line 2 (actual)
  const c2 = opts.color2 || '#2dd4a0';
  ctx.strokeStyle = c2; ctx.lineWidth = 2; ctx.beginPath();
  let m2 = false;
  data.forEach((d, i) => {
    if (d[y2Key] == null) { m2 = false; return; }
    const x = pad.left + (i / Math.max(data.length - 1, 1)) * chartW;
    const y = pad.top + (1 - (d[y2Key] - yMin) / (yMax - yMin)) * chartH;
    if (!m2) { ctx.moveTo(x, y); m2 = true; } else ctx.lineTo(x, y);
  }); ctx.stroke();
  // X-axis
  ctx.fillStyle = '#8e91a4'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  const step = Math.max(1, Math.floor(data.length / 8));
  data.forEach((d, i) => {
    if (i % step === 0 || i === data.length - 1) {
      const x = pad.left + (i / Math.max(data.length - 1, 1)) * chartW;
      ctx.fillText('GW' + d[xKey], x, H - 4);
    }
  });
  // Legend
  ctx.font = '10px sans-serif'; ctx.textAlign = 'left';
  const lx = pad.left + 8;
  ctx.fillStyle = c1; ctx.fillRect(lx, pad.top + 2, 12, 3);
  ctx.fillText(opts.label1 || y1Key, lx + 16, pad.top + 7);
  ctx.fillStyle = c2; ctx.fillRect(lx + 80, pad.top + 2, 12, 3);
  ctx.fillText(opts.label2 || y2Key, lx + 96, pad.top + 7);
}

// --- Weekly Workflow ---

function generateRecommendation() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  document.getElementById('recommendationDisplay').innerHTML = '<div class="empty-state"><p>Generating...</p></div>';
  fetch('/api/season/generate-recommendation', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid)}),
  }).then(r => r.json()).then(d => {
    if (d.error) return alert(d.error);
    // Results loaded after task_done SSE
  });
}

function recordResults() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  document.getElementById('outcomeDisplay').innerHTML = '<div class="empty-state"><p>Recording...</p></div>';
  fetch('/api/season/record-results', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid)}),
  }).then(r => r.json()).then(d => {
    if (d.error) return alert(d.error);
  });
}

// --- Action Plan ---

function loadActionPlan() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/action-plan?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      if (d.error) {
        document.getElementById('actionPlanDisplay').innerHTML = '';
        return;
      }
      lastActionPlanData = d;
      renderActionPlan(d);
    });
  // Also fetch my-team data for lock-in squad building
  fetch(`/api/my-team?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      if (!d.error && d.squad) lastMyTeamData = d;
    });
}

function renderActionPlan(plan) {
  const steps = plan.steps || [];
  if (!steps.length) {
    document.getElementById('actionPlanDisplay').innerHTML = '';
    return;
  }

  const deadlineStr = plan.deadline
    ? new Date(plan.deadline).toLocaleString('en-GB', {weekday:'short', day:'numeric', month:'short', hour:'2-digit', minute:'2-digit'})
    : 'Unknown';

  const actionIcons = {
    transfer: '&#x1F504;',
    captain: '&#x00A9;',
    chip: '&#x1F0CF;',
    bench_order: '&#x1F4CB;',
  };
  const actionColors = {
    transfer: 'var(--red)',
    captain: 'var(--yellow)',
    chip: 'var(--green)',
    bench_order: 'var(--text2)',
  };

  let html = `<div class="action-plan-card">
    <h4>
      <span>GW${plan.gameweek} Action Plan</span>
      <span style="font-size:12px;font-weight:400;color:var(--yellow)">Deadline: ${deadlineStr}</span>
    </h4>`;

  steps.forEach((step, i) => {
    const icon = actionIcons[step.action] || '&#x2022;';
    const color = actionColors[step.action] || 'var(--text2)';
    html += `<div class="action-step" data-step-index="${i}">
      <div class="action-step-check" onclick="toggleActionCheck(this)"></div>
      <div class="action-step-icon" style="color:${color}">${icon}</div>
      <div>${step.description}</div>
    </div>`;
    // Render WC/FH squad pitch below the chip step
    if (step.action === 'chip' && step.new_squad && step.new_squad.length) {
      html += renderChipSquadPitch(step.new_squad, step.description);
    }
  });

  if (plan.rationale) {
    html += `<div style="margin-top:12px;padding-top:10px;border-top:1px solid var(--border);font-size:12px;color:var(--text2);line-height:1.5">${plan.rationale}</div>`;
  }

  html += `<div style="margin-top:10px;display:flex;justify-content:flex-end;gap:8px">
    <button class="btn" onclick="lockInGWTeam()" id="lockInBtn" disabled style="font-size:11px;padding:4px 10px;opacity:0.5">Lock-in GW Team</button>
    <button class="btn" onclick="copyActionPlan()" style="font-size:11px;padding:4px 10px">Copy to Clipboard</button>
  </div>`;
  html += '</div>';
  html += '<div id="lockedSquadDisplay"></div>';
  document.getElementById('actionPlanDisplay').innerHTML = html;

  // Re-render locked squad if exists
  if (lockedGWSquad) renderLockedSquadPitch(lockedGWSquad);
}

function renderChipSquadPitch(squad, chipLabel) {
  const starters = squad.filter(p => p.starter);
  const bench = squad.filter(p => !p.starter);
  let totalPts = starters.reduce((s, p) => s + (p.predicted_next_gw_points || 0), 0);
  const capPlayer = starters.find(p => p.is_captain);
  if (capPlayer) totalPts += (capPlayer.predicted_next_gw_points || 0);

  function card(p) {
    let pts;
    if (p.predicted_next_gw_points != null) {
      let rawPred = Number(p.predicted_next_gw_points);
      if (p.is_captain) rawPred *= 2;
      pts = rawPred.toFixed(1);
    } else {
      pts = '-';
    }
    let badge = '';
    let cardStyle = '';
    if (p.is_captain) {
      cardStyle = 'border:2px solid #ef4444;box-shadow:0 0 8px rgba(239,68,68,0.4)';
      badge = ' <span class="captain-badge">(C)</span>';
    } else if (p.is_vice_captain) {
      badge = ' <span class="vc-badge">(V)</span>';
    }
    return `<div class="pitch-card" style="${cardStyle}">
      <div class="p-name">${p.web_name || '-'}${badge}</div>
      <div class="p-team">${p.team || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
      <div class="p-pts" style="color:var(--green)">${pts}</div>
      ${p.opponent ? `<span style="font-size:10px;color:var(--text2)">${p.opponent}</span>` : ''}
    </div>`;
  }

  const fwd = starters.filter(p => p.position === 'FWD');
  const mid = starters.filter(p => p.position === 'MID');
  const def_ = starters.filter(p => p.position === 'DEF');
  const gkp = starters.filter(p => p.position === 'GKP');

  let html = `<div class="action-plan-card" style="margin-top:8px;margin-bottom:8px;border:1px solid var(--green);border-radius:8px">
    <h4 style="color:var(--green)">${chipLabel} Squad (Predicted: ${totalPts.toFixed(1)} pts)</h4>
    <div class="pitch">
      <div class="pitch-bottom-box"></div>
      <div class="pitch-row fwd">${fwd.map(p => card(p)).join('')}</div>
      <div class="pitch-row mid">${mid.map(p => card(p)).join('')}</div>
      <div class="pitch-row def">${def_.map(p => card(p)).join('')}</div>
      <div class="pitch-row gkp">${gkp.map(p => card(p)).join('')}</div>
    </div>`;

  if (bench.length) {
    html += `<div class="bench-area"><div class="bench-label">Bench</div>
      <div class="bench-row">${bench.map(p => {
        const pred = p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-';
        return `<div class="bench-card">
          <div class="p-name">${p.web_name || '-'}</div>
          <div class="p-team">${p.team || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
          <div class="p-pts" style="font-size:13px">${pred}</div>
        </div>`;
      }).join('')}</div></div>`;
  }

  html += '</div>';
  return html;
}

function copyActionPlan() {
  const card = document.getElementById('actionPlanDisplay');
  if (!card) return;
  const steps = card.querySelectorAll('.action-step');
  const lines = [];
  steps.forEach((el, i) => {
    const text = el.querySelector('div:last-child').textContent.trim();
    lines.push(`${i + 1}. ${text}`);
  });
  navigator.clipboard.writeText(lines.join('\n')).then(() => {
    const copyBtn = card.querySelectorAll('button');
    const btn = copyBtn[copyBtn.length - 1];
    if (btn) { btn.textContent = 'Copied!'; setTimeout(() => btn.textContent = 'Copy to Clipboard', 1500); }
  });
}

function toggleActionCheck(el) {
  el.classList.toggle('checked');
  const btn = document.getElementById('lockInBtn');
  if (!btn) return;
  const anyChecked = document.querySelectorAll('.action-step-check.checked').length > 0;
  btn.disabled = !anyChecked;
  btn.style.opacity = anyChecked ? '1' : '0.5';
}

function optimizeStartingXI(squad) {
  // Try all valid formations and pick the XI that maximizes predicted_next_gw_points.
  // Formation: 1 GKP + d DEF + m MID + f FWD where d+m+f=10, d[3,5], m[2,5], f[1,3]
  const byPos = { GKP: [], DEF: [], MID: [], FWD: [] };
  squad.forEach(p => { if (byPos[p.position]) byPos[p.position].push(p); });
  // Sort each position group by predicted points descending
  for (const pos in byPos) byPos[pos].sort((a, b) => (b.predicted_next_gw_points || 0) - (a.predicted_next_gw_points || 0));

  let bestXI = null, bestPts = -1;
  for (let d = 3; d <= 5; d++) {
    for (let m = 2; m <= 5; m++) {
      const f = 10 - d - m;
      if (f < 1 || f > 3) continue;
      if (byPos.GKP.length < 1 || byPos.DEF.length < d || byPos.MID.length < m || byPos.FWD.length < f) continue;
      const xi = [byPos.GKP[0], ...byPos.DEF.slice(0, d), ...byPos.MID.slice(0, m), ...byPos.FWD.slice(0, f)];
      const pts = xi.reduce((s, p) => s + (p.predicted_next_gw_points || 0), 0);
      if (pts > bestPts) { bestPts = pts; bestXI = new Set(xi.map(p => p.player_id)); }
    }
  }
  if (!bestXI) return;
  squad.forEach(p => { p.starter = bestXI.has(p.player_id); });

  // Set captain to starter with highest captain_score
  const starters = squad.filter(p => p.starter);
  starters.sort((a, b) => (b.captain_score || b.predicted_next_gw_points || 0) - (a.captain_score || a.predicted_next_gw_points || 0));
  squad.forEach(p => { p.is_captain = false; p.is_vice_captain = false; });
  if (starters.length > 0) starters[0].is_captain = true;
  if (starters.length > 1) starters[1].is_vice_captain = true;
}

function lockInGWTeam() {
  if (!lastMyTeamData || !lastMyTeamData.squad || !lastActionPlanData) {
    alert('Import your squad and generate a recommendation first.');
    return;
  }
  const steps = lastActionPlanData.steps || [];
  const checkedEls = document.querySelectorAll('.action-step-check.checked');

  // Check if a WC/FH chip step with new_squad is checked
  let wcFhSquad = null;
  let benchBoost = false;
  let tripleCaptain = false;
  checkedEls.forEach(el => {
    const stepDiv = el.closest('.action-step');
    const idx = parseInt(stepDiv.dataset.stepIndex, 10);
    const step = steps[idx];
    if (!step) return;
    if (step.action === 'chip' && step.new_squad && step.new_squad.length) {
      wcFhSquad = step.new_squad;
    }
    if (step.action === 'chip' && step.description.includes('Bench Boost')) benchBoost = true;
    if (step.action === 'chip' && step.description.includes('Triple Captain')) tripleCaptain = true;
  });

  let squad;
  if (wcFhSquad) {
    // WC/FH: use the full new squad directly, then optimize
    squad = JSON.parse(JSON.stringify(wcFhSquad));
    optimizeStartingXI(squad);
    // Apply captain from checked captain step (overrides optimizer)
    checkedEls.forEach(el => {
      const stepDiv = el.closest('.action-step');
      const idx = parseInt(stepDiv.dataset.stepIndex, 10);
      const step = steps[idx];
      if (step && step.action === 'captain' && step.captain_id) {
        squad.forEach(p => { p.is_captain = (p.player_id === step.captain_id); });
      }
    });
  } else {
    // Normal flow: apply transfers/captain to current squad
    squad = JSON.parse(JSON.stringify(lastMyTeamData.squad));
    const transferredInIds = new Set();

    checkedEls.forEach(el => {
      const stepDiv = el.closest('.action-step');
      const idx = parseInt(stepDiv.dataset.stepIndex, 10);
      const step = steps[idx];
      if (!step) return;

      if (step.action === 'transfer' && step.player_out && step.player_in) {
        const outId = step.player_out.player_id;
        const si = squad.findIndex(p => p.player_id === outId);
        if (si !== -1) {
          const old = squad[si];
          squad[si] = {
            player_id: step.player_in.player_id,
            web_name: step.player_in.web_name,
            position: step.player_in.position,
            team: step.player_in.team,
            team_code: step.player_in.team_code,
            cost: step.player_in.cost,
            predicted_next_gw_points: step.player_in.predicted_next_gw_points,
            captain_score: step.player_in.captain_score,
            opponent: step.player_in.opponent || '',
            starter: old.starter,
            is_captain: old.is_captain,
            is_vice_captain: old.is_vice_captain,
            event_points: null,
            status: 'a',
          };
          transferredInIds.add(step.player_in.player_id);
        }
      } else if (step.action === 'captain' && step.captain_id) {
        squad.forEach(p => {
          p.is_captain = (p.player_id === step.captain_id);
        });
      }
    });

    // Optimize starting XI: pick best formation from all 15 players
    optimizeStartingXI(squad);

    // Re-apply captain from checked captain step (overrides optimizer's pick)
    checkedEls.forEach(el => {
      const stepDiv = el.closest('.action-step');
      const idx = parseInt(stepDiv.dataset.stepIndex, 10);
      const step = steps[idx];
      if (step && step.action === 'captain' && step.captain_id) {
        squad.forEach(p => { p.is_captain = (p.player_id === step.captain_id); });
        // Ensure captain is a starter
        const cap = squad.find(p => p.is_captain);
        if (cap && !cap.starter) {
          const samePos = squad.filter(q => q.position === cap.position && q.starter);
          if (samePos.length) {
            samePos.sort((a, b) => (a.predicted_next_gw_points || 0) - (b.predicted_next_gw_points || 0));
            samePos[0].starter = false;
            cap.starter = true;
          }
        }
      }
    });
  }

  const gw = lastActionPlanData.gameweek || '?';
  const starters = squad.filter(p => p.starter);
  const scoringPlayers = benchBoost ? squad : starters;
  let totalPts = scoringPlayers.reduce((s, p) => s + (p.predicted_next_gw_points || 0), 0);
  const lockedCaptain = starters.find(p => p.is_captain);
  // Captain bonus: +1x for normal (2x total), +2x for TC (3x total)
  if (lockedCaptain) totalPts += (lockedCaptain.predicted_next_gw_points || 0) * (tripleCaptain ? 2 : 1);
  const chipCtx = tripleCaptain ? '3xc' : (benchBoost ? 'bboost' : null);
  lockedGWSquad = { gameweek: gw, squad: squad, predicted_points: totalPts, benchBoost, chipCtx };
  renderLockedSquadPitch(lockedGWSquad);

  // Refresh Overview predicted pitch if visible
  const overviewSection = document.getElementById('seasonOverview');
  if (overviewSection && overviewSection.classList.contains('visible') && lastMyTeamData) {
    renderSeasonTeamView(lastMyTeamData);
  }
}

function renderLockedSquadPitch(data) {
  const container = document.getElementById('lockedSquadDisplay');
  if (!container) return;
  const squad = data.squad;
  const starters = squad.filter(p => p.starter);
  const bench = squad.filter(p => !p.starter);
  const totalPts = data.predicted_points || 0;
  const chipCtx = data.chipCtx;

  function card(p) {
    let pts;
    if (p.predicted_next_gw_points != null) {
      let rawPred = Number(p.predicted_next_gw_points);
      if (p.is_captain) rawPred *= (chipCtx === '3xc' ? 3 : 2);
      pts = rawPred.toFixed(1);
    } else {
      pts = '-';
    }
    let badge = '';
    let cardStyle = '';
    if (p.is_captain) {
      cardStyle = 'border:2px solid #ef4444;box-shadow:0 0 8px rgba(239,68,68,0.4)';
      badge = ' <span class="captain-badge">(C)</span>';
    } else if (p.is_vice_captain) {
      badge = ' <span class="vc-badge">(V)</span>';
    }
    return `<div class="pitch-card" style="${cardStyle}">
      <div class="p-name">${p.web_name || '-'}${badge}</div>
      <div class="p-team">${p.team || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
      <div class="p-pts" style="color:var(--green)">${pts}</div>
      ${p.opponent ? `<span style="font-size:10px;color:var(--text2)">${p.opponent}</span>` : ''}
    </div>`;
  }

  const fwd = starters.filter(p => p.position === 'FWD');
  const mid = starters.filter(p => p.position === 'MID');
  const def_ = starters.filter(p => p.position === 'DEF');
  const gkp = starters.filter(p => p.position === 'GKP');

  let html = `<div class="action-plan-card" style="margin-top:12px">
    <h4 style="display:flex;justify-content:space-between;align-items:center">
      <span style="color:var(--green)">Locked-in GW${data.gameweek} Squad${data.benchBoost ? ' [BB]' : ''} (Predicted: ${totalPts.toFixed(1)} pts)</span>
      <button class="btn" onclick="clearLockedSquad()" style="font-size:11px;padding:4px 10px">Clear</button>
    </h4>
    <div class="pitch">
      <div class="pitch-bottom-box"></div>
      <div class="pitch-row fwd">${fwd.map(p => card(p)).join('')}</div>
      <div class="pitch-row mid">${mid.map(p => card(p)).join('')}</div>
      <div class="pitch-row def">${def_.map(p => card(p)).join('')}</div>
      <div class="pitch-row gkp">${gkp.map(p => card(p)).join('')}</div>
    </div>`;

  if (bench.length) {
    html += `<div class="bench-area"><div class="bench-label">Bench</div>
      <div class="bench-row">${bench.map(p => {
        const pred = p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-';
        return `<div class="bench-card">
          <div class="p-name">${p.web_name || '-'}</div>
          <div class="p-team">${p.team || ''} &middot; ${p.cost != null ? Number(p.cost).toFixed(1) + 'm' : ''}</div>
          <div class="p-pts" style="font-size:13px">${pred}</div>
        </div>`;
      }).join('')}</div></div>`;
  }

  html += '</div>';
  container.innerHTML = html;
}

function clearLockedSquad() {
  lockedGWSquad = null;
  const container = document.getElementById('lockedSquadDisplay');
  if (container) container.innerHTML = '';
  // Refresh Overview predicted pitch if visible
  const overviewSection = document.getElementById('seasonOverview');
  if (overviewSection && overviewSection.classList.contains('visible') && lastMyTeamData) {
    renderSeasonTeamView(lastMyTeamData);
  }
}

// --- Outcomes ---

function loadOutcomes() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/outcomes?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      const outcomes = d.outcomes || [];
      if (!outcomes.length) {
        document.getElementById('outcomeDisplay').innerHTML = '';
        return;
      }
      renderOutcomes(outcomes);
    });
}

function renderOutcomes(outcomes) {
  if (!outcomes.length) {
    document.getElementById('outcomeDisplay').innerHTML = '';
    return;
  }

  // Show latest outcome prominently + summary trend
  const latest = outcomes[outcomes.length - 1];
  const delta = latest.point_delta || 0;
  const deltaColor = delta >= 0 ? 'var(--green)' : 'var(--red)';
  const deltaSign = delta >= 0 ? '+' : '';
  const captainIcon = latest.followed_captain ? '<span style="color:var(--green)">&#x2714;</span>' : '<span style="color:var(--red)">&#x2718;</span>';
  const transferIcon = latest.followed_transfers ? '<span style="color:var(--green)">&#x2714;</span>' : '<span style="color:var(--red)">&#x2718;</span>';

  let html = `<div class="outcome-card">
    <h4>GW${latest.gameweek} Outcome</h4>
    <div class="outcome-row">
      <span>Actual Points</span>
      <strong>${latest.actual_points || 0}</strong>
    </div>
    <div class="outcome-row">
      <span>Predicted Points</span>
      <span>${(latest.recommended_points || 0).toFixed(1)}</span>
    </div>
    <div class="outcome-row">
      <span>Delta</span>
      <span style="color:${deltaColor};font-weight:600">${deltaSign}${delta.toFixed(1)}</span>
    </div>
    <div class="outcome-row">
      <span>Followed Captain</span>
      ${captainIcon}
    </div>
    <div class="outcome-row">
      <span>Followed Transfers</span>
      ${transferIcon}
    </div>`;

  // Trend over all outcomes
  if (outcomes.length > 1) {
    const avgDelta = outcomes.reduce((s, o) => s + (o.point_delta || 0), 0) / outcomes.length;
    const avgColor = avgDelta >= 0 ? 'var(--green)' : 'var(--red)';
    const avgSign = avgDelta >= 0 ? '+' : '';
    const captainRate = Math.round(outcomes.filter(o => o.followed_captain).length / outcomes.length * 100);
    html += `<div style="margin-top:10px;padding-top:10px;border-top:1px solid var(--border)">
      <div style="font-size:12px;color:var(--text2);margin-bottom:4px">Season Trend (${outcomes.length} GWs)</div>
      <div style="display:flex;gap:16px;font-size:12px">
        <span>Avg delta: <strong style="color:${avgColor}">${avgSign}${avgDelta.toFixed(1)}</strong></span>
        <span>Captain follow rate: <strong>${captainRate}%</strong></span>
      </div>
    </div>`;
  }

  html += '</div>';
  document.getElementById('outcomeDisplay').innerHTML = html;
}

// --- Workflow Step Indicators ---

function updateWorkflowSteps() {
  const mid = getSeasonManagerId();
  if (!mid) return;

  // Check state to determine which step we're on
  const steps = [
    document.getElementById('wfStep1'),
    document.getElementById('wfStep2'),
    document.getElementById('wfStep3'),
    document.getElementById('wfStep4'),
  ];
  if (!steps[0]) return;

  // Reset all
  steps.forEach(s => { s.classList.remove('done', 'current'); });

  // Step 1: Has data? Check cache age
  fetch('/api/model-info').then(r => r.json()).then(info => {
    const hasData = info.cache_age_seconds != null;
    const hasModels = (info.models || []).some(m => m.exists);

    if (hasData) steps[0].classList.add('done');
    else { steps[0].classList.add('current'); return; }

    // Step 2: Has recommendation for next GW?
    fetch(`/api/season/recommendations?manager_id=${mid}`).then(r => r.json()).then(d => {
      const recs = d.recommendations || [];
      const nextGwVal = info.next_gw;
      const hasRec = recs.some(r => r.gameweek === nextGwVal);

      if (hasRec) {
        steps[1].classList.add('done');
        steps[2].classList.add('current'); // Execute actions is always "current" until GW finishes
      } else {
        steps[1].classList.add('current');
        return;
      }

      // Step 4: Has outcome for this GW?
      fetch(`/api/season/outcomes?manager_id=${mid}`).then(r => r.json()).then(od => {
        const outcomes = od.outcomes || [];
        const hasOutcome = outcomes.some(o => o.gameweek === nextGwVal);
        if (hasOutcome) {
          steps[2].classList.add('done');
          steps[2].classList.remove('current');
          steps[3].classList.add('done');
        }
      });
    });
  });
}

function loadLatestRecommendation() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/recommendations?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      const recs = d.recommendations || [];
      if (!recs.length) {
        document.getElementById('recommendationDisplay').innerHTML =
          '<div class="empty-state"><p>No recommendations yet. Click "Generate Recommendation" before the next deadline.</p></div>';
        return;
      }
      const latest = recs[recs.length - 1];
      renderRecommendation(latest);
    });
}

function recPlayerBadge(p, type) {
  if (!p || !p.web_name) return '<div style="min-width:140px"></div>';
  const borderColor = type === 'out' ? 'var(--red)' : 'var(--green)';
  const pred = p.predicted_next_gw_points != null ? Number(p.predicted_next_gw_points).toFixed(1) : '-';
  const pred3 = p.predicted_next_3gw_points != null ? Number(p.predicted_next_3gw_points).toFixed(1) : '-';
  const lastGw = p.event_points != null ? p.event_points : '-';
  const total = p.total_points != null ? p.total_points : '-';
  const cost = p.cost != null ? Number(p.cost).toFixed(1) : '-';
  const posClass = p.position || '';
  return `<div style="background:var(--surface);border:2px solid ${borderColor};border-radius:8px;padding:10px 14px;min-width:160px">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
      <span style="font-weight:700;font-size:14px">${p.web_name}</span>
      <span class="pos-tag ${posClass}" style="font-size:10px">${posClass}</span>
    </div>
    <div style="font-size:11px;color:var(--text2);margin-bottom:6px">${p.team || ''} &middot; ${cost}m</div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px 12px;font-size:12px">
      <div style="color:var(--text2)">Last GW</div><div style="text-align:right;font-weight:600;color:var(--orange)">${lastGw}</div>
      <div style="color:var(--text2)">Pred GW</div><div style="text-align:right;font-weight:600;color:var(--green)">${pred}</div>
      <div style="color:var(--text2)">Pred 3GW</div><div style="text-align:right;font-weight:600">${pred3}</div>
      <div style="color:var(--text2)">Season</div><div style="text-align:right">${total}</div>
    </div>
  </div>`;
}

function renderRecommendation(rec) {
  let transfers = [];
  try { transfers = JSON.parse(rec.transfers_json || '[]'); } catch(e) {}
  let chipValues = {};
  try { chipValues = JSON.parse(rec.chip_values_json || '{}'); } catch(e) {}
  let bankAnalysis = {};
  try { bankAnalysis = JSON.parse(rec.bank_analysis_json || '{}'); } catch(e) {}

  let html = `<div class="rec-card"><h4>GW${rec.gameweek} Recommendation</h4>`;

  // Transfers  new format: array of {out, in} pairs
  // Also support old format: array of {direction, ...} objects
  const hasPairs = transfers.length > 0 && transfers[0].out !== undefined;

  if (hasPairs && transfers.length) {
    html += '<div style="display:flex;flex-direction:column;gap:12px;margin-bottom:12px">';
    for (const pair of transfers) {
      html += `<div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap">
        ${recPlayerBadge(pair.out, 'out')}
        <div style="font-size:20px;color:var(--text2)">&rarr;</div>
        ${recPlayerBadge(pair.in, 'in')}
      </div>`;
    }
    html += '</div>';
  } else if (!hasPairs) {
    // Old format fallback
    const inT = transfers.filter(t => t.direction === 'in');
    const outT = transfers.filter(t => t.direction === 'out');
    if (inT.length || outT.length) {
      html += '<div style="display:flex;flex-direction:column;gap:12px;margin-bottom:12px">';
      const maxLen = Math.max(inT.length, outT.length);
      for (let i = 0; i < maxLen; i++) {
        html += `<div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap">
          ${recPlayerBadge(outT[i], 'out')}
          <div style="font-size:20px;color:var(--text2)">&rarr;</div>
          ${recPlayerBadge(inT[i], 'in')}
        </div>`;
      }
      html += '</div>';
    } else {
      html += '<p style="color:var(--text2);font-size:13px;margin-bottom:12px">No transfers recommended (bank your FT)</p>';
    }
  } else {
    html += '<p style="color:var(--text2);font-size:13px;margin-bottom:12px">No transfers recommended (bank your FT)</p>';
  }

  // Transfer cost breakdown
  const nTransfers = hasPairs ? transfers.length : Math.max(
    transfers.filter(t => t.direction === 'in').length,
    transfers.filter(t => t.direction === 'out').length
  );
  const freeFTs = rec.free_transfers != null ? rec.free_transfers : null;
  const isUnlimitedChip = rec.chip_suggestion === 'wildcard' || rec.chip_suggestion === 'freehit';
  if (nTransfers > 0 && isUnlimitedChip) {
    const chipLabel = rec.chip_suggestion === 'wildcard' ? 'Wildcard' : 'Free Hit';
    html += `<div style="font-size:12px;margin-bottom:12px;padding:6px 10px;background:var(--surface);border:1px solid var(--border);border-radius:6px;display:inline-block">
      Transfers: <strong>${nTransfers}</strong> &mdash; <span style="color:var(--green)">All free (${chipLabel})</span>
    </div>`;
  } else if (nTransfers > 0 && freeFTs != null) {
    const paidTransfers = Math.max(0, nTransfers - freeFTs);
    let ftText;
    if (paidTransfers > 0) {
      const hitCost = paidTransfers * 4;
      ftText = `<span style="color:var(--green)">${freeFTs} free</span> + <span style="color:var(--red);font-weight:600">${paidTransfers} hit (-${hitCost}pts)</span>`;
    } else {
      ftText = `<span style="color:var(--green)">${nTransfers} of ${freeFTs} free transfer${freeFTs > 1 ? 's' : ''} used</span>`;
    }
    html += `<div style="font-size:12px;margin-bottom:12px;padding:6px 10px;background:var(--surface);border:1px solid var(--border);border-radius:6px;display:inline-block">
      Transfers: <strong>${nTransfers}</strong> &mdash; ${ftText}
    </div>`;
  }

  // Captain
  html += `<div style="margin-bottom:10px;padding:8px 14px;background:var(--surface);border:2px solid #ef4444;border-radius:8px;display:inline-block">
    <span style="font-size:13px;color:var(--text2)">Captain:</span>
    <strong style="margin-left:6px;font-size:15px">${rec.captain_name || '-'}</strong>
  </div>`;

  // Chip suggestion
  if (rec.chip_suggestion) {
    html += `<div style="margin:8px 0;padding:8px 14px;background:rgba(45,212,160,0.1);border:1px solid var(--green);border-radius:8px;display:inline-block;margin-left:8px">
      <span style="font-size:13px;color:var(--green);font-weight:600">Play ${rec.chip_suggestion}</span>
    </div>`;
  }

  // Predicted points: up to 3 boxes showing progressive impact
  const currentPts = rec.current_xi_points;   // Box 1: no changes
  const basePts = rec.base_points;            // Box 2: after transfers only (no chip)
  const fullPts = rec.predicted_points;       // Box 3: full recommendation (with chip)
  const chip = rec.chip_suggestion;
  const hasChipEffect = chip === 'bboost' || chip === '3xc';
  const isWcFh = chip === 'wildcard' || chip === 'freehit';
  const hasTransfers = nTransfers > 0;

  if (currentPts != null && fullPts != null) {
    html += `<div style="margin-top:12px;display:flex;align-items:center;gap:12px;flex-wrap:wrap">`;

    // Box 1: No changes (always shown)
    html += `<div style="padding:10px 14px;background:var(--surface);border:1px solid var(--border);border-radius:8px;text-align:center;min-width:120px">
      <div style="font-size:11px;color:var(--text2);margin-bottom:2px">No changes</div>
      <div style="font-size:22px;font-weight:700">${currentPts.toFixed(1)}</div>
      <div style="font-size:11px;color:var(--text2)">predicted pts</div>
    </div>`;

    // Box 2: After transfers (shown when transfers exist AND chip adds extra, or WC/FH)
    if (hasTransfers && basePts != null && hasChipEffect) {
      const tDiff = basePts - currentPts;
      const tDiffStr = tDiff >= 0 ? `+${tDiff.toFixed(1)}` : tDiff.toFixed(1);
      const tColor = tDiff > 0 ? 'var(--green)' : tDiff < 0 ? 'var(--red)' : 'var(--text2)';
      html += `<div style="font-size:16px;color:var(--text2)">&rarr;</div>
      <div style="padding:10px 14px;background:var(--surface);border:1px solid var(--border);border-radius:8px;text-align:center;min-width:120px">
        <div style="font-size:11px;color:var(--text2);margin-bottom:2px">After transfers</div>
        <div style="font-size:22px;font-weight:700">${basePts.toFixed(1)}</div>
        <div style="font-size:11px;color:var(--text2)">predicted pts</div>
        <div style="font-size:12px;font-weight:600;color:${tColor};margin-top:2px">${tDiffStr}</div>
      </div>`;
    }

    // Box 3: Full recommendation (shown when there's any change from Box 1)
    const showFull = (hasTransfers && !hasChipEffect) || hasChipEffect || isWcFh;
    if (showFull && Math.abs(fullPts - currentPts) > 0.05) {
      const fDiff = fullPts - currentPts;
      const fDiffStr = fDiff >= 0 ? `+${fDiff.toFixed(1)}` : fDiff.toFixed(1);
      const fColor = fDiff > 0 ? 'var(--green)' : fDiff < 0 ? 'var(--red)' : 'var(--text2)';
      const chipLabel = chip === 'bboost' ? 'Bench Boost'
        : chip === '3xc' ? 'Triple Captain'
        : chip === 'wildcard' ? 'Wildcard'
        : chip === 'freehit' ? 'Free Hit' : '';
      const boxLabel = hasTransfers && !hasChipEffect ? 'After transfers'
        : chipLabel ? `With ${chipLabel}` : 'Recommended';
      html += `<div style="font-size:16px;color:var(--text2)">&rarr;</div>
      <div style="padding:10px 14px;background:var(--surface);border:2px solid var(--green);border-radius:8px;text-align:center;min-width:120px">
        <div style="font-size:11px;color:var(--text2);margin-bottom:2px">${boxLabel}</div>
        <div style="font-size:22px;font-weight:700">${fullPts.toFixed(1)}</div>
        <div style="font-size:11px;color:var(--text2)">predicted pts</div>
        <div style="font-size:12px;font-weight:600;color:${fColor};margin-top:2px">${fDiffStr}</div>
      </div>`;
    }

    html += `</div>`;
  }
  html += '</div>';

  document.getElementById('recommendationDisplay').innerHTML = html;
}

// --- Fixtures ---

function loadFixtures() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  const nextGwVal = nextGW || 1;
  fetch(`/api/season/fixtures?manager_id=${mid}&from_gw=${nextGwVal}&to_gw=${Math.min(nextGwVal + 7, 38)}`)
    .then(r => r.json())
    .then(d => {
      if (d.error) return;
      renderFixtureGrid(d.fixtures || [], nextGwVal);
    });
}

function refreshFixtures() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch('/api/season/update-fixtures', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid)}),
  }).then(() => loadFixtures());
}

function renderFixtureGrid(fixtures, fromGW) {
  if (!fixtures.length) {
    document.getElementById('fixtureGridContainer').innerHTML =
      '<div class="empty-state"><p>No fixture data. Click "Refresh Fixtures".</p></div>';
    return;
  }

  // Organize: team -> gw -> fixture data
  const teams = {};
  const gws = new Set();
  fixtures.forEach(f => {
    if (!teams[f.team_short]) teams[f.team_short] = {};
    gws.add(f.gameweek);
    teams[f.team_short][f.gameweek] = f;
  });

  const sortedGWs = Array.from(gws).sort((a, b) => a - b);
  const sortedTeams = Object.keys(teams).sort();

  let html = '<div class="fixture-grid-wrap"><table class="fixture-grid"><thead><tr><th>Team</th>';
  sortedGWs.forEach(gw => { html += `<th>GW${gw}</th>`; });
  html += '</tr></thead><tbody>';

  sortedTeams.forEach(team => {
    html += `<tr><td>${team}</td>`;
    sortedGWs.forEach(gw => {
      const f = teams[team][gw];
      if (!f) {
        html += '<td>-</td>';
      } else if (f.is_bgw) {
        html += '<td class="fx-bgw">BLANK</td>';
      } else {
        let opps = [];
        try { opps = JSON.parse(f.opponents_json || '[]'); } catch(e) {}
        const fdrClass = f.fdr_avg ? `fx-fdr-${Math.round(f.fdr_avg)}` : '';
        const dgwClass = f.is_dgw ? 'fx-dgw' : '';
        html += `<td class="${fdrClass} ${dgwClass}">${opps.join(', ') || '-'}</td>`;
      }
    });
    html += '</tr>';
  });

  html += '</tbody></table></div>';
  document.getElementById('fixtureGridContainer').innerHTML = html;
}

// --- Transfer History ---

function loadTransferHistory() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/transfer-history?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      renderTransferHistory(d.transfer_history || []);
    });
}

function renderTransferHistory(history) {
  if (!history.length) {
    document.getElementById('transferHistoryContainer').innerHTML =
      '<div class="empty-state"><p>No transfer history yet.</p></div>';
    return;
  }

  let html = '<div class="bt-table-wrap"><table class="bt-table"><thead><tr>';
  html += '<th>GW</th><th>Out</th><th>In</th><th>Cost</th><th>Chip</th>';
  html += '</tr></thead><tbody>';

  history.forEach(h => {
    const cost = h.transfers_cost || 0;
    const chip = h.chip_used || '-';
    let outsHtml = '-';
    let insHtml = '-';
    try {
      const outs = JSON.parse(h.transfers_out_json || '[]');
      const ins = JSON.parse(h.transfers_in_json || '[]');
      if (outs.length) outsHtml = outs.map(p => `<span style="color:var(--red)">${p.web_name}</span>`).join(', ');
      if (ins.length) insHtml = ins.map(p => `<span style="color:var(--green)">${p.web_name}</span>`).join(', ');
    } catch(e) {}
    html += `<tr>
      <td>GW${h.gameweek}</td>
      <td>${outsHtml}</td>
      <td>${insHtml}</td>
      <td>${cost > 0 ? '-' + cost + 'pts' : 'Free'}</td>
      <td>${chip}</td>
    </tr>`;
  });

  html += '</tbody></table></div>';
  document.getElementById('transferHistoryContainer').innerHTML = html;
}

// --- Chips ---

function loadChips() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/chips?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      renderChips(d.chips || [], d.chip_values || {});
    });
}

function renderChips(chips, chipValues) {
  let html = '<div class="chip-cards">';
  chips.forEach(c => {
    const usedClass = c.used ? 'used' : '';
    const statusText = c.used ? `Used GW${c.used_gw}` : 'Available';
    const statusClass = c.used ? '' : 'available';
    const value = chipValues[c.name];
    let otherHalfHtml = '';
    if (c.used_other_half) {
      otherHalfHtml = `<div style="font-size:10px;color:var(--text2);margin-top:2px">Other half: Used GW${c.used_other_gw}</div>`;
    } else if (c.used_other_gw == null && c.used_other_half === false) {
      otherHalfHtml = `<div style="font-size:10px;color:var(--text2);margin-top:2px">Other half: Available</div>`;
    }
    html += `<div class="chip-card ${usedClass}">
      <div class="chip-name">${c.label}</div>
      <div class="chip-status ${statusClass}">${statusText}</div>
      ${otherHalfHtml}
      ${!c.used && value != null ? `<div class="chip-value">+${value} pts</div>` : ''}
    </div>`;
  });
  html += '</div>';
  document.getElementById('chipsContainer').innerHTML = html;
}

// --- Prices ---

function loadPrices() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/prices?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      renderPriceAlerts(d.alerts || []);
      renderPriceTable(d.prices || []);
    });
  loadPricePredictions();
  loadWatchlist();
}

function updatePrices() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch('/api/season/update-prices', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid)}),
  }).then(() => loadPrices());
}

function renderPriceAlerts(alerts) {
  if (!alerts.length) {
    document.getElementById('priceAlertsContainer').innerHTML =
      '<p style="color:var(--text2);font-size:13px">No significant price alerts right now.</p>';
    return;
  }
  let html = '<div class="price-alerts">';
  alerts.forEach(a => {
    const dirClass = a.direction === 'rise' ? 'rise' : 'fall';
    const arrow = a.direction === 'rise' ? '&uarr;' : '&darr;';
    const net = Math.abs(a.net_transfers).toLocaleString();
    html += `<div class="price-alert">
      <div>
        <strong>${a.web_name}</strong>
        <span style="color:var(--text2);margin-left:4px">${a.team} &middot; ${a.price.toFixed(1)}m</span>
      </div>
      <div class="pa-dir ${dirClass}">${arrow} ${net}</div>
    </div>`;
  });
  html += '</div>';
  document.getElementById('priceAlertsContainer').innerHTML = html;
}

let _priceTableData = [];
let _priceTableSort = null; // 'in' or 'out'
let _priceTableSortAsc = false;

function renderPriceTable(prices) {
  _priceTableData = prices;
  _renderPriceTableSorted();
}

function _renderPriceTableSorted() {
  const prices = _priceTableData;
  if (!prices.length) {
    document.getElementById('priceTableContainer').innerHTML =
      '<p style="color:var(--text2);font-size:13px">No price data yet. Click "Update Prices".</p>';
    return;
  }
  const sorted = [...prices];
  if (_priceTableSort === 'in') {
    sorted.sort((a, b) => _priceTableSortAsc
      ? (a.transfers_in_event || 0) - (b.transfers_in_event || 0)
      : (b.transfers_in_event || 0) - (a.transfers_in_event || 0));
  } else if (_priceTableSort === 'out') {
    sorted.sort((a, b) => _priceTableSortAsc
      ? (a.transfers_out_event || 0) - (b.transfers_out_event || 0)
      : (b.transfers_out_event || 0) - (a.transfers_out_event || 0));
  }
  const inArrow = _priceTableSort === 'in' ? (_priceTableSortAsc ? ' \u25B2' : ' \u25BC') : '';
  const outArrow = _priceTableSort === 'out' ? (_priceTableSortAsc ? ' \u25B2' : ' \u25BC') : '';
  let html = '<div class="bt-table-wrap"><table class="bt-table"><thead><tr>';
  html += '<th>Player</th><th>Price</th>';
  html += `<th style="cursor:pointer" onclick="sortPriceTable('in')">In<span class="sort-arrow">${inArrow}</span></th>`;
  html += `<th style="cursor:pointer" onclick="sortPriceTable('out')">Out<span class="sort-arrow">${outArrow}</span></th>`;
  html += '<th>Date</th>';
  html += '</tr></thead><tbody>';
  sorted.forEach(p => {
    html += `<tr>
      <td>${p.web_name || '-'}</td>
      <td>${p.price ? p.price.toFixed(1) + 'm' : '-'}</td>
      <td style="color:var(--green)">${(p.transfers_in_event || 0).toLocaleString()}</td>
      <td style="color:var(--red)">${(p.transfers_out_event || 0).toLocaleString()}</td>
      <td>${p.snapshot_date || '-'}</td>
    </tr>`;
  });
  html += '</tbody></table></div>';
  document.getElementById('priceTableContainer').innerHTML = html;
}

function sortPriceTable(col) {
  if (_priceTableSort === col) {
    _priceTableSortAsc = !_priceTableSortAsc;
  } else {
    _priceTableSort = col;
    _priceTableSortAsc = false;
  }
  _renderPriceTableSorted();
}

function loadPricePredictions() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/price-predictions?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      const el = document.getElementById('pricePredictionsDisplay');
      if (!el) return;
      const preds = d.predictions || [];
      if (!preds.length) {
        el.innerHTML = '<p style="color:var(--text2);font-size:13px">No price movements predicted.</p>';
        return;
      }
      const risers = preds.filter(p => p.direction === 'rise').slice(0, 30);
      const fallers = preds.filter(p => p.direction === 'fall').slice(0, 30);
      let html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:16px">';
      // Risers
      html += '<div><h5 style="color:var(--green);margin-bottom:6px;font-size:13px">Likely Risers</h5>';
      if (risers.length) {
        html += '<div class="bt-table-wrap"><table class="bt-table"><thead><tr><th>Player</th><th>Price</th><th>Own%</th><th>Prob</th></tr></thead><tbody>';
        risers.forEach(p => {
          const pct = Math.round(p.probability * 100);
          html += `<tr><td>${p.web_name} <span style="color:var(--text2)">${p.team}</span></td><td>${p.price.toFixed(1)}m</td><td>${p.ownership}%</td><td><div style="display:flex;align-items:center;gap:4px"><div style="width:40px;height:8px;background:var(--surface2);border-radius:4px"><div style="width:${pct}%;height:100%;background:var(--green);border-radius:4px"></div></div>${pct}%</div></td></tr>`;
        });
        html += '</tbody></table></div>';
      } else { html += '<p style="color:var(--text2);font-size:12px">None</p>'; }
      html += '</div>';
      // Fallers
      html += '<div><h5 style="color:var(--red);margin-bottom:6px;font-size:13px">Likely Fallers</h5>';
      if (fallers.length) {
        html += '<div class="bt-table-wrap"><table class="bt-table"><thead><tr><th>Player</th><th>Price</th><th>Own%</th><th>Prob</th></tr></thead><tbody>';
        fallers.forEach(p => {
          const pct = Math.round(p.probability * 100);
          html += `<tr><td>${p.web_name} <span style="color:var(--text2)">${p.team}</span></td><td>${p.price.toFixed(1)}m</td><td>${p.ownership}%</td><td><div style="display:flex;align-items:center;gap:4px"><div style="width:40px;height:8px;background:var(--surface2);border-radius:4px"><div style="width:${pct}%;height:100%;background:var(--red);border-radius:4px"></div></div>${pct}%</div></td></tr>`;
        });
        html += '</tbody></table></div>';
      } else { html += '<p style="color:var(--text2);font-size:12px">None</p>'; }
      html += '</div></div>';
      el.innerHTML = html;
    });
}

// --- Watchlist ---

let _watchlistSearchTimer = null;
function debounceWatchlistSearch() {
  clearTimeout(_watchlistSearchTimer);
  _watchlistSearchTimer = setTimeout(searchWatchlistPlayer, 250);
}

function searchWatchlistPlayer() {
  const input = document.getElementById('watchlistSearch');
  const dropdown = document.getElementById('watchlistDropdown');
  const query = (input.value || '').trim();
  if (query.length < 2) { dropdown.style.display = 'none'; return; }
  fetch(`/api/predictions?search=${encodeURIComponent(query)}`)
    .then(r => r.json())
    .then(d => {
      const players = (d.players || []).slice(0, 10);
      if (!players.length) {
        dropdown.innerHTML = '<div style="padding:8px 12px;font-size:12px;color:var(--text2)">No players found</div>';
        dropdown.style.display = 'block';
        return;
      }
      let html = '';
      players.forEach(p => {
        const price = p.cost ? p.cost.toFixed(1) + 'm' : '';
        html += `<div style="padding:6px 12px;cursor:pointer;font-size:13px;display:flex;justify-content:space-between;border-bottom:1px solid var(--border)" onmouseover="this.style.background='var(--surface3)'" onmouseout="this.style.background=''" onclick="addToWatchlist(${p.player_id})">
          <span>${p.web_name} <span style="color:var(--text2)">${p.position || ''}</span></span>
          <span style="color:var(--text2)">${price}</span>
        </div>`;
      });
      dropdown.innerHTML = html;
      dropdown.style.display = 'block';
    });
}

function addToWatchlist(playerId) {
  const mid = getSeasonManagerId();
  if (!mid) return;
  document.getElementById('watchlistDropdown').style.display = 'none';
  document.getElementById('watchlistSearch').value = '';
  fetch('/api/season/watchlist/add', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid), player_id: playerId}),
  }).then(() => loadWatchlist());
}

function removeFromWatchlist(playerId) {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch('/api/season/watchlist/remove', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid), player_id: playerId}),
  }).then(() => loadWatchlist());
}

function loadWatchlist() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/season/watchlist?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => renderWatchlist(d.watchlist || []));
}

function renderWatchlist(watchlist) {
  const el = document.getElementById('watchlistContainer');
  if (!el) return;
  if (!watchlist.length) {
    el.innerHTML = '<p style="color:var(--text2);font-size:13px">No players on watchlist. Search above to add players you\'re interested in.</p>';
    return;
  }
  let html = '<div class="bt-table-wrap"><table class="bt-table"><thead><tr>';
  html += '<th>Player</th><th>Team</th><th>Added Price</th><th>Current Price</th><th>Change</th><th></th>';
  html += '</tr></thead><tbody>';
  watchlist.forEach(w => {
    const addedPrice = w.price_when_added;
    const currentPrice = w.current_price;
    let changeHtml = '-';
    if (addedPrice != null && currentPrice != null) {
      const diff = currentPrice - addedPrice;
      if (Math.abs(diff) >= 0.05) {
        const color = diff > 0 ? 'var(--green)' : 'var(--red)';
        const sign = diff > 0 ? '+' : '';
        changeHtml = `<span style="color:${color}">${sign}${diff.toFixed(1)}</span>`;
      } else {
        changeHtml = '<span style="color:var(--text2)">0.0</span>';
      }
    }
    html += `<tr>
      <td>${w.web_name || '-'}</td>
      <td>${w.team_short || '-'}</td>
      <td>${addedPrice != null ? addedPrice.toFixed(1) + 'm' : '-'}</td>
      <td>${currentPrice != null ? currentPrice.toFixed(1) + 'm' : '-'}</td>
      <td>${changeHtml}</td>
      <td><button class="btn" style="font-size:11px;padding:2px 8px;color:var(--red)" onclick="removeFromWatchlist(${w.player_id})">Remove</button></td>
    </tr>`;
  });
  html += '</tbody></table></div>';
  el.innerHTML = html;
}

// Close watchlist dropdown on outside click
document.addEventListener('click', function(e) {
  const dropdown = document.getElementById('watchlistDropdown');
  const search = document.getElementById('watchlistSearch');
  if (dropdown && search && !dropdown.contains(e.target) && e.target !== search) {
    dropdown.style.display = 'none';
  }
});

// Hook into SSE task_done to reload season data
const _origSSEHandler = null;
(function() {
  const origConnectSSE = connectSSE;
  // Patch: after task_done, reload season dashboard
  const patchInterval = setInterval(() => {
    const statusText = document.getElementById('statusText');
    if (!statusText) return;
    clearInterval(patchInterval);
  }, 100);
})();

// We'll add a check in the existing SSE handler by overriding after load
function seasonOnTaskDone() {
  const seasonPanel = document.getElementById('seasonPanel');
  if (seasonPanel && seasonPanel.classList.contains('visible')) {
    // V2: just re-poll status -- phase will have changed after tick/planning
    loadSeasonV2();
  }
}

// ---------------------------------------------------------------------------
// Pre-Season
// ---------------------------------------------------------------------------

function generatePreseasonPlan() {
  const mid = getSeasonManagerId();
  if (!mid) return alert('Enter a Manager ID');
  localStorage.setItem('fpl_manager_id', mid);
  document.getElementById('preseasonStatus').textContent = 'Generating...';
  fetch('/api/preseason/generate', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: parseInt(mid)}),
  }).then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('preseasonStatus').textContent = d.error;
    } else {
      document.getElementById('preseasonStatus').textContent = 'Running in background...';
    }
  });
}

function loadPreseasonResult() {
  const mid = getSeasonManagerId();
  if (!mid) return;
  fetch(`/api/preseason/result?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      if (d.error) return;
      renderPreseasonSquad(d);
      renderPreseasonChipPlan(d);
      document.getElementById('preseasonStatus').textContent = 'Plan generated';
    });
}

function renderPreseasonSquad(data) {
  const squad = data.initial_squad || [];
  if (!squad.length) {
    document.getElementById('preseasonSquadDisplay').innerHTML = '';
    return;
  }

  const starters = squad.filter(p => p.starter);
  const bench = squad.filter(p => !p.starter);
  const posOrder = {GKP: 0, DEF: 1, MID: 2, FWD: 3};
  starters.sort((a, b) => (posOrder[a.position] || 9) - (posOrder[b.position] || 9));
  bench.sort((a, b) => (posOrder[a.position] || 9) - (posOrder[b.position] || 9));

  let html = `<div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:16px;margin-bottom:16px">
    <h4 style="font-size:14px;margin-bottom:4px">Recommended Initial Squad</h4>
    <div style="font-size:12px;color:var(--text2);margin-bottom:12px">
      Predicted XI: <strong style="color:var(--green)">${(data.predicted_points || 0).toFixed(1)} pts</strong>
      &middot; Captain: <strong>${data.captain?.name || '-'}</strong>
    </div>
    <div style="font-size:11px;text-transform:uppercase;color:var(--text2);margin-bottom:6px">Starting XI</div>
    <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:8px;margin-bottom:12px">`;

  starters.forEach(p => {
    html += `<div style="background:var(--surface2);padding:8px 10px;border-radius:6px;border-left:3px solid var(--green)">
      <div style="font-weight:600;font-size:13px">${p.web_name || '?'}</div>
      <div style="font-size:11px;color:var(--text2)">${p.position || ''} &middot; ${p.team || ''} &middot; ${(p.cost || 0).toFixed(1)}m</div>
    </div>`;
  });

  html += `</div><div style="font-size:11px;text-transform:uppercase;color:var(--text2);margin-bottom:6px">Bench</div>
    <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:8px">`;

  bench.forEach(p => {
    html += `<div style="background:var(--surface2);padding:8px 10px;border-radius:6px;border-left:3px solid var(--border)">
      <div style="font-weight:600;font-size:13px">${p.web_name || '?'}</div>
      <div style="font-size:11px;color:var(--text2)">${p.position || ''} &middot; ${p.team || ''} &middot; ${(p.cost || 0).toFixed(1)}m</div>
    </div>`;
  });

  html += '</div></div>';
  document.getElementById('preseasonSquadDisplay').innerHTML = html;
}

function renderPreseasonChipPlan(data) {
  const schedule = data.chip_schedule || {};
  const entries = Object.entries(schedule);
  if (!entries.length) {
    document.getElementById('preseasonChipPlan').innerHTML = '';
    return;
  }

  let html = `<div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:16px">
    <h4 style="font-size:14px;margin-bottom:12px">Season Chip Plan</h4>
    <div style="display:flex;gap:12px;flex-wrap:wrap">`;

  entries.forEach(([chip, gw]) => {
    html += `<div style="background:var(--accent);color:#fff;padding:10px 16px;border-radius:8px;text-align:center">
      <div style="font-size:14px;font-weight:600">${chipLabel(chip)}</div>
      <div style="font-size:20px;font-weight:800">GW${gw}</div>
    </div>`;
  });

  html += '</div></div>';
  document.getElementById('preseasonChipPlan').innerHTML = html;
}

// ---------------------------------------------------------------------------
// Strategic Planning
// ---------------------------------------------------------------------------
function getSeasonMid() {
  return getSeasonManagerId();
}

function generateStrategicPlan() {
  const mid = getSeasonMid();
  if (!mid) return;
  document.getElementById('strategyPlanStatus').textContent = 'Generating...';
  fetch('/api/season/strategic-plan', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({manager_id: mid}),
  }).then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('strategyPlanStatus').textContent = d.error;
    } else {
      document.getElementById('strategyPlanStatus').textContent = 'Running in background...';
    }
  });
}

function loadStrategicPlan() {
  const mid = getSeasonMid();
  if (!mid) return;
  fetch(`/api/season/strategic-plan?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      if (d.error) {
        document.getElementById('strategyPlanStatus').textContent = d.error;
        return;
      }
      renderStrategicPlan(d);
    });
}

function checkPlanHealth() {
  const mid = getSeasonMid();
  if (!mid) return;
  fetch(`/api/season/plan-health?manager_id=${mid}`)
    .then(r => r.json())
    .then(d => {
      const banner = document.getElementById('planHealthBanner');
      const triggers = document.getElementById('planHealthTriggers');
      if (!banner || !triggers) return;
      if (d.healthy) {
        banner.style.display = 'none';
        return;
      }
      banner.style.display = 'block';
      const list = (d.triggers || []).slice(0, 5);
      let html = '';
      list.forEach(t => {
        const color = t.severity === 'critical' ? 'var(--red)' : 'var(--yellow, #fbbf24)';
        html += `<div style="margin-bottom:4px"><span style="color:${color};font-weight:600">[${t.severity}]</span> ${t.description}</div>`;
      });
      const s = d.summary || {};
      html += `<div style="margin-top:6px;font-size:11px;color:var(--text2)">${s.critical || 0} critical, ${s.moderate || 0} moderate issue(s)</div>`;
      triggers.innerHTML = html;
    });
}

function renderStrategicPlan(data) {
  const plan = data.plan || {};
  const changelog = data.changelog || [];

  document.getElementById('strategyPlanStatus').textContent =
    `Plan as of GW${data.as_of_gw || '?'} (${data.created_at || ''})`;

  // Rationale
  const ratEl = document.getElementById('strategyRationale');
  if (plan.rationale) {
    ratEl.style.display = 'block';
    document.getElementById('strategyRationaleText').textContent = plan.rationale;
  } else {
    ratEl.style.display = 'none';
  }

  // Timeline
  renderTimeline(plan.timeline || []);

  // Captain plan
  renderCaptainPlan(plan.timeline || []);

  // Chip schedule
  renderChipSchedule(plan.chip_schedule || {}, plan.chip_synergies || []);

  // Changelog
  renderChangelog(changelog);
}

function renderTimeline(timeline) {
  const container = document.getElementById('strategyTimeline');
  if (!timeline.length) {
    container.innerHTML = '<p style="color:var(--text2);font-size:13px">No plan generated yet.</p>';
    return;
  }
  let html = '';
  timeline.forEach((entry, i) => {
    const conf = entry.confidence || 0.9;
    const confColor = conf > 0.8 ? 'var(--green)' : conf > 0.6 ? 'var(--yellow)' : 'var(--red)';
    const borderColor = i === 0 ? 'var(--accent)' : 'var(--border)';
    const chipBadge = entry.chip
      ? `<div style="background:var(--accent);color:#fff;padding:2px 8px;border-radius:10px;font-size:11px;display:inline-block;margin-top:6px">${chipLabel(entry.chip)} (+${(entry.chip_value||0).toFixed(1)})</div>`
      : '';

    html += `<div style="min-width:200px;background:var(--surface2);border-radius:8px;padding:12px 14px;border-top:3px solid ${borderColor};flex-shrink:0">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <strong style="font-size:15px">GW${entry.gw}</strong>
        <span style="font-size:11px;color:${confColor}">${(conf*100).toFixed(0)}%</span>
      </div>`;

    // FT strategy
    const ftUsed = entry.ft_used || 0;
    const ftAvail = entry.ft_available || 0;
    if (ftUsed === 0) {
      html += `<div style="font-size:12px;color:var(--yellow);margin-bottom:4px">Bank FT (${ftAvail}${Math.min(ftAvail+1,5)})</div>`;
    } else {
      html += `<div style="font-size:12px;color:var(--green);margin-bottom:4px">Use ${ftUsed} FT</div>`;
    }

    // Transfers
    const tIn = entry.transfers_in || [];
    if (tIn.length > 0) {
      tIn.forEach(t => {
        html += `<div style="font-size:12px;margin-left:4px">+ ${t.web_name || '?'} <span style="color:var(--text2)">${t.position || ''} ${t.cost ? t.cost.toFixed(1)+'m' : ''}</span></div>`;
      });
    }
    const tOut = entry.transfers_out || [];
    tOut.forEach(t => {
      html += `<div style="font-size:12px;margin-left:4px;color:var(--red)">- ${t.web_name || 'player'}</div>`;
    });

    // Captain
    if (entry.captain_name) {
      const weakBadge = entry.weak_captain ? ' <span style="color:var(--red);font-size:10px">WEAK</span>' : '';
      html += `<div style="font-size:12px;margin-top:6px">C: <strong>${entry.captain_name}</strong> (${(entry.captain_points||0).toFixed(1)})${weakBadge}</div>`;
    }

    // Predicted points
    if (entry.predicted_points) {
      html += `<div style="font-size:12px;color:var(--text2);margin-top:4px">XI: ${entry.predicted_points.toFixed(1)} pts</div>`;
    }

    html += chipBadge;
    html += '</div>';
  });
  container.innerHTML = html;
}

function renderCaptainPlan(timeline) {
  const container = document.getElementById('strategyCaptainPlan');
  const caps = timeline.filter(e => e.captain_name);
  if (!caps.length) {
    container.innerHTML = '<p style="color:var(--text2);font-size:13px">No captain plan available.</p>';
    return;
  }
  let html = '<div style="display:flex;gap:8px;flex-wrap:wrap">';
  caps.forEach(c => {
    const weakStyle = c.weak_captain ? 'border-color:var(--red)' : 'border-color:var(--green)';
    html += `<div style="background:var(--surface2);padding:8px 12px;border-radius:6px;border-left:3px solid;${weakStyle};font-size:13px">
      <div style="color:var(--text2);font-size:11px">GW${c.gw}</div>
      <strong>${c.captain_name}</strong>
      <div style="font-size:12px;color:var(--text2)">${(c.captain_points||0).toFixed(1)} pts</div>
    </div>`;
  });
  html += '</div>';
  container.innerHTML = html;
}

function chipLabel(name) {
  const labels = {wildcard:'Wildcard', freehit:'Free Hit', bboost:'Bench Boost', '3xc':'Triple Captain'};
  return labels[name] || name;
}

function renderChipSchedule(schedule, synergies) {
  const container = document.getElementById('strategyChipSchedule');
  const entries = Object.entries(schedule);
  if (!entries.length) {
    container.innerHTML = '<p style="color:var(--text2);font-size:13px">No chips scheduled.</p>';
    return;
  }

  let html = '<div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:12px">';
  entries.forEach(([chip, gw]) => {
    html += `<div style="background:var(--accent);color:#fff;padding:10px 16px;border-radius:8px;text-align:center">
      <div style="font-size:14px;font-weight:600">${chipLabel(chip)}</div>
      <div style="font-size:20px;font-weight:800">GW${gw}</div>
    </div>`;
  });
  html += '</div>';

  // Synergies
  if (synergies && synergies.length) {
    html += '<div style="font-size:12px;color:var(--text2);margin-top:4px">';
    synergies.forEach(s => {
      html += `<div style="margin-bottom:4px">&#x1F517; ${s.description} <strong>+${(s.synergy_bonus||0).toFixed(1)} pts</strong></div>`;
    });
    html += '</div>';
  }
  container.innerHTML = html;
}


function renderChangelog(changelog) {
  const container = document.getElementById('strategyChangelog');
  if (!changelog.length) {
    container.innerHTML = '<p style="color:var(--text2);font-size:13px">No plan changes recorded.</p>';
    return;
  }
  let html = '<div style="max-height:300px;overflow-y:auto">';
  changelog.forEach(c => {
    const typeColor = c.change_type === 'chip_schedule' ? 'var(--accent)' : 'var(--yellow)';
    html += `<div style="display:flex;gap:8px;align-items:flex-start;padding:6px 0;border-bottom:1px solid var(--border);font-size:12px">
      <span style="color:${typeColor};font-weight:600;min-width:80px">${c.change_type}</span>
      <div>
        <div>${c.description}</div>
        <div style="color:var(--text2)">${c.old_value || ''} &rarr; ${c.new_value || ''}</div>
        <div style="color:var(--text2);font-size:11px">${c.created_at || ''}</div>
      </div>
    </div>`;
  });
  html += '</div>';
  container.innerHTML = html;
}

// Reload strategy after task completes
const _origSeasonOnTaskDone = seasonOnTaskDone;
seasonOnTaskDone = function() {
  _origSeasonOnTaskDone();
  const strategySection = document.getElementById('seasonStrategy');
  if (strategySection && strategySection.classList.contains('visible')) {
    loadStrategicPlan();
  }
  // Reload pre-season results if that panel is visible
  const preSeasonPanel = document.getElementById('preSeasonPanel');
  if (preSeasonPanel && preSeasonPanel.style.display !== 'none') {
    loadPreseasonResult();
  }
};

// ---------------------------------------------------------------------------
// "but, how?" Prediction Explainer
// ---------------------------------------------------------------------------
let wtfTeamData = null;
let wtfView = 'teams'; // 'teams' | 'roster' | 'explain'
let wtfSelectedTeam = null;
let wtfSelectedPlayer = null;
let wtfPredLookup = {}; // player_id -> predicted pts

function loadWtfTeams() {
  if (wtfTeamData) {
    if (wtfView === 'teams') showWtfTeamGrid();
    return;
  }
  document.getElementById('wtfContent').innerHTML =
    '<div class="wtf-intro"><p>Ever wondered how the model decides that Salah will score 8 points? <strong>Pick a team, pick a player</strong>, and we\'ll show you exactly how every model arrived at that number &mdash; from the raw features to the final prediction.</p></div>' +
    '<div class="empty-state"><p>Loading teams...</p></div>';
  fetch('/api/players/teams').then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('wtfContent').innerHTML = friendlyError(d.error, 'Explainer');
      return;
    }
    wtfTeamData = d.teams;
    // Load predictions to show pts next to player names
    fetch('/api/predictions').then(r => r.json()).then(pd => {
      if (pd.players) {
        pd.players.forEach(p => { wtfPredLookup[p.player_id] = p.predicted_next_gw_points || 0; });
      }
      wtfView = 'teams';
      showWtfTeamGrid();
    }).catch(() => {
      wtfView = 'teams';
      showWtfTeamGrid();
    });
  }).catch(() => {
    document.getElementById('wtfContent').innerHTML = friendlyError('Could not load teams. Click Get Latest Data first.', 'Explainer');
  });
}

function showWtfTeamGrid() {
  wtfView = 'teams';
  wtfSelectedTeam = null;
  wtfSelectedPlayer = null;
  updateWtfBreadcrumb();
  const html =
    '<div class="wtf-intro"><p>Ever wondered how the model decides that Salah will score 8 points? <strong>Pick a team, pick a player</strong>, and we\'ll show you exactly how every model arrived at that number &mdash; from the raw features to the final prediction.</p></div>' +
    '<div class="players-team-grid">' +
    wtfTeamData.map(t =>
      `<div class="players-team-card" onclick="showWtfRoster(${t.id})">
        <img src="https://resources.premierleague.com/premierleague/badges/25/t${t.code}.png"
             alt="${t.short_name}" onerror="this.style.display='none'">
        <div class="team-name">${t.name}</div>
        <div class="player-count">${t.player_count} players</div>
      </div>`
    ).join('') + '</div>';
  document.getElementById('wtfContent').innerHTML = html;
}

function showWtfRoster(teamId) {
  const team = wtfTeamData.find(t => t.id === teamId);
  if (!team) return;
  wtfView = 'roster';
  wtfSelectedTeam = team;
  wtfSelectedPlayer = null;
  updateWtfBreadcrumb();

  const positions = ['GKP', 'DEF', 'MID', 'FWD'];
  const posLabels = {GKP: 'Goalkeepers', DEF: 'Defenders', MID: 'Midfielders', FWD: 'Forwards'};
  let html = '';
  positions.forEach(pos => {
    const players = team.players[pos];
    if (!players || !players.length) return;
    html += `<div class="roster-section"><h3 class="pos-${pos}">${posLabels[pos]}</h3><div class="roster-grid">`;
    players.forEach(p => {
      const pred = wtfPredLookup[p.id];
      const predStr = pred != null ? pred.toFixed(1) : '-';
      const statusCls = (p.status === 'i' || p.status === 'u' || p.status === 's') ? ' status-i' : '';
      html += `<div class="roster-player${statusCls}" onclick="showWtfExplain(${p.id})">
        <img src="https://resources.premierleague.com/premierleague/photos/players/110x140/p${p.code}.png"
             alt="${p.web_name}" onerror="this.src=WALDO_DATA_URI">
        <div class="rp-info">
          <div class="rp-name">${p.web_name}</div>
          <div class="rp-meta">
            <span>\u00a3${p.now_cost}m</span>
            <span>${pos}</span>
            <span>F:${p.form}</span>
          </div>
        </div>
        <div class="rp-pts" title="Predicted next GW">${predStr}</div>
      </div>`;
    });
    html += '</div></div>';
  });
  document.getElementById('wtfContent').innerHTML = html;
}

function showWtfExplain(playerId) {
  wtfView = 'explain';
  wtfSelectedPlayer = playerId;
  updateWtfBreadcrumb();
  document.getElementById('wtfContent').innerHTML =
    '<div class="empty-state"><p>Loading explanation...</p></div>';

  fetch(`/api/players/${playerId}/explain`).then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('wtfContent').innerHTML = friendlyError(d.error, 'Explainer');
      return;
    }
    renderWtfExplain(d);
  }).catch(() => {
    document.getElementById('wtfContent').innerHTML = friendlyError('Could not load prediction explanation.', 'Explainer');
  });
}

function renderWtfExplain(d) {
  const pos = d.position;
  const posCls = 'pos-' + pos;
  const fixture = d.fixture || {};
  const fixtureStr = fixture.opponent
    ? `${fixture.is_home ? '' : ''}${fixture.opponent} (${fixture.is_home ? 'H' : 'A'})${fixture.is_dgw ? ' DGW' : ''} FDR:${fixture.fdr}`
    : '';

  // Confidence interval
  const confStr = (d.confidence && d.confidence.low != null && d.confidence.high != null)
    ? `${d.confidence.low}  ${d.confidence.high} pts`
    : '';

  // --- Header / Verdict ---
  let html = `
  <div class="wtf-verdict">
    <img class="wtf-verdict-photo" src="https://resources.premierleague.com/premierleague/photos/players/110x140/p${d.photo_code}.png"
         alt="${d.web_name}" onerror="this.src=WALDO_DATA_URI">
    <div class="wtf-verdict-info">
      <h2>${d.web_name}</h2>
      <div class="wtf-verdict-meta">
        <img src="https://resources.premierleague.com/premierleague/badges/25/t${d.team_code}.png" onerror="this.style.display='none'">
        <span class="${posCls}" style="font-weight:600">${pos}</span>
        <span>${d.team_short}</span>
        ${fixtureStr ? `<span style="margin-left:8px">vs ${fixtureStr}</span>` : ''}
      </div>
    </div>
    <div class="wtf-verdict-number">
      <div class="wtf-verdict-pts">${d.final_prediction}</div>
      <div class="wtf-verdict-label">predicted pts</div>
      ${confStr ? `<div class="wtf-confidence-range">${confStr}</div>` : ''}
    </div>
  </div>`;

  // --- How We Got There: Model cards ---
  const mm = d.mean_model || {};
  const dm = d.decomposed_model || {};
  const wM = Math.round((mm.weight || 0.85) * 100);
  const wD = Math.round((dm.weight || 0.15) * 100);

  html += `
  <div class="wtf-section">
    <h3>How We Got There</h3>
    <div class="wtf-model-row">
      <div class="wtf-model-card">
        <h3>Mean Model</h3>
        <span class="wtf-model-weight">${wM}% weight</span>
        <div class="wtf-model-pred">${(mm.prediction || 0).toFixed(2)}</div>
        <div class="wtf-model-desc">XGBoost trained on 100+ features per player, predicting total GW points directly. One model per position.</div>
      </div>
      <div class="wtf-formula-arrow">
        <div class="formula">${(mm.weight||0.85).toFixed(2)} &times; ${(mm.prediction||0).toFixed(2)}</div>
        <div class="formula">+</div>
        <div class="formula">${(dm.weight||0.15).toFixed(2)} &times; ${(dm.prediction||0).toFixed(2)}</div>
        <div class="equals">=</div>
        <div class="formula" style="color:var(--accent);font-weight:700">${d.final_prediction}</div>
      </div>
      <div class="wtf-model-card">
        <h3>Component Model</h3>
        <span class="wtf-model-weight">${wD}% weight</span>
        <div class="wtf-model-pred">${(dm.prediction || 0).toFixed(2)}</div>
        <div class="wtf-model-desc">Breaks prediction into goals, assists, clean sheets, bonus, etc. Each component predicted separately, then combined via FPL scoring rules.</div>
      </div>
    </div>
  </div>`;

  // --- Component Breakdown ---
  const comps = dm.components || {};
  const compKeys = Object.keys(comps);
  if (compKeys.length > 0) {
    const colors = {
      appearance: '#6c7a89', goals: '#e74c3c', assists: '#2ecc71', cs: '#3498db',
      gc: '#8e44ad', saves: '#f39c12', bonus: '#e67e22', defcon: '#1abc9c',
    };
    const total = compKeys.reduce((s, k) => s + Math.abs(comps[k].pts || 0), 0) || 1;

    html += `<div class="wtf-section"><h3>Component Breakdown</h3><div class="wtf-component-bar-container">`;

    // Probability badges
    html += `<div class="wtf-prob-row">
      <div class="wtf-prob-badge">
        <span class="prob-val">${((dm.p_plays || 0) * 100).toFixed(0)}%</span>
        <span class="prob-label">chance of playing</span>
      </div>
      <div class="wtf-prob-badge">
        <span class="prob-val">${((dm.p_60plus || 0) * 100).toFixed(0)}%</span>
        <span class="prob-label">chance of 60+ mins</span>
      </div>
    </div>`;

    // Stacked bar
    html += '<div class="wtf-stacked-bar">';
    compKeys.forEach(k => {
      const pts = Math.abs(comps[k].pts || 0);
      const pct = (pts / total) * 100;
      if (pct < 1) return;
      const color = colors[k] || '#95a5a6';
      html += `<div class="wtf-bar-seg" style="flex:${pct};background:${color}" title="${comps[k].label}: ${comps[k].pts} pts">
        ${pct > 6 ? comps[k].label : ''}
      </div>`;
    });
    html += '</div>';

    // Component detail cards
    html += '<div class="wtf-component-detail">';
    compKeys.forEach(k => {
      const c = comps[k];
      const color = colors[k] || '#95a5a6';
      const rawLabel = k === 'appearance' ? '' :
        k === 'goals' ? `${c.raw.toFixed(2)} goals expected` :
        k === 'assists' ? `${c.raw.toFixed(2)} assists expected` :
        k === 'cs' ? `${(c.raw * 100).toFixed(0)}% CS probability` :
        k === 'gc' ? `${c.raw.toFixed(2)} goals conceded` :
        k === 'saves' ? `${c.raw.toFixed(1)} saves expected` :
        k === 'bonus' ? `${c.raw.toFixed(2)} bonus expected` :
        k === 'defcon' ? `${c.raw.toFixed(1)} CBIT expected` : '';
      html += `<div class="wtf-comp-item">
        <div class="comp-pts" style="color:${color}">${c.pts >= 0 ? '+' : ''}${c.pts.toFixed(2)}</div>
        <div class="comp-label">${c.label}</div>
        ${rawLabel ? `<div class="comp-raw">${rawLabel}</div>` : ''}
      </div>`;
    });
    html += '</div></div></div>';
  }

  // --- Captain Score ---
  const cap = d.captain || {};
  if (cap.score && cap.q80_prediction) {
    html += `
    <div class="wtf-section">
      <h3>Captain Score</h3>
      <div class="wtf-captain-box">
        <div class="wtf-captain-score">${cap.score.toFixed(2)}</div>
        ${cap.formula ? `<div class="wtf-captain-formula">${cap.formula}</div>` : ''}
        <div class="wtf-captain-explain">
          The captain score blends the mean prediction with the Q80 (80th percentile) prediction.
          Q80 captures explosive upside  what the player could score on a great day.
          Higher Q80 weight (60%) means we value upside potential for captaincy decisions.
        </div>
      </div>
    </div>`;
  }

  // --- Top Features ---
  const feats = d.top_features || [];
  if (feats.length > 0) {
    const maxImp = Math.max(...feats.map(f => f.importance));
    html += `<div class="wtf-section"><h3>What's Driving This?</h3><div class="wtf-feature-list">`;
    feats.forEach(f => {
      const pct = maxImp > 0 ? (f.importance / maxImp) * 100 : 0;
      const valStr = f.value != null ? (typeof f.value === 'number' ? f.value.toFixed(2) : f.value) : '-';
      html += `<div class="wtf-feature-row">
        <div class="wtf-feature-label" title="${f.name}">${f.label}</div>
        <div class="wtf-feature-bar-bg">
          <div class="wtf-feature-bar" style="width:${pct.toFixed(1)}%"></div>
        </div>
        <div class="wtf-feature-value">${valStr}</div>
      </div>`;
    });
    html += '</div></div>';
  }

  document.getElementById('wtfContent').innerHTML = html;
}

function updateWtfBreadcrumb() {
  let html = '';
  if (wtfView === 'teams') {
    html = '<span class="current">All Teams</span>';
  } else if (wtfView === 'roster') {
    html = `<a onclick="showWtfTeamGrid()">All Teams</a><span class="sep">\u203a</span>
            <span class="current">${wtfSelectedTeam ? wtfSelectedTeam.name : ''}</span>`;
  } else if (wtfView === 'explain') {
    html = `<a onclick="showWtfTeamGrid()">All Teams</a><span class="sep">\u203a</span>`;
    if (wtfSelectedTeam) {
      html += `<a onclick="showWtfRoster(${wtfSelectedTeam.id})">${wtfSelectedTeam.name}</a><span class="sep">\u203a</span>`;
    }
    html += `<span class="current">Explain</span>`;
  }
  document.getElementById('wtfBreadcrumb').innerHTML = html;
}

// ---------------------------------------------------------------------------
// Players Drill-Down
// ---------------------------------------------------------------------------
let playersTeamData = null;
let playersView = 'teams'; // 'teams' | 'roster' | 'detail'
let playersSelectedTeam = null;
let playersSelectedPlayer = null;
let playersGwFrom = null;
let playersGwTo = null;
let playersDetailCache = {};

function loadPlayersTeams() {
  if (playersTeamData) {
    if (playersView === 'teams') showPlayersTeamGrid();
    return;
  }
  document.getElementById('playersContent').innerHTML =
    '<div class="empty-state"><p>Loading teams...</p></div>';
  fetch('/api/players/teams').then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('playersContent').innerHTML = friendlyError(d.error, 'Players');
      return;
    }
    playersTeamData = d.teams;
    playersView = 'teams';
    showPlayersTeamGrid();
  }).catch(() => {
    document.getElementById('playersContent').innerHTML = friendlyError('Could not load teams. Click Get Latest Data first.', 'Players');
  });
}

function showPlayersTeamGrid() {
  playersView = 'teams';
  playersSelectedTeam = null;
  playersSelectedPlayer = null;
  document.getElementById('playersGwControls').style.display = 'none';
  updatePlayersBreadcrumb();
  const html = '<div class="players-team-grid">' +
    playersTeamData.map(t =>
      `<div class="players-team-card" onclick="showTeamRoster(${t.id})">
        <img src="https://resources.premierleague.com/premierleague/badges/25/t${t.code}.png"
             alt="${t.short_name}" onerror="this.style.display='none'">
        <div class="team-name">${t.name}</div>
        <div class="player-count">${t.player_count} players</div>
      </div>`
    ).join('') + '</div>';
  document.getElementById('playersContent').innerHTML = html;
}

function showTeamRoster(teamId) {
  const team = playersTeamData.find(t => t.id === teamId);
  if (!team) return;
  playersView = 'roster';
  playersSelectedTeam = team;
  playersSelectedPlayer = null;
  document.getElementById('playersGwControls').style.display = 'none';
  updatePlayersBreadcrumb();

  const positions = ['GKP', 'DEF', 'MID', 'FWD'];
  const posLabels = {GKP: 'Goalkeepers', DEF: 'Defenders', MID: 'Midfielders', FWD: 'Forwards'};
  let html = '';
  positions.forEach(pos => {
    const players = team.players[pos];
    if (!players || !players.length) return;
    html += `<div class="roster-section"><h3 class="pos-${pos}">${posLabels[pos]}</h3><div class="roster-grid">`;
    players.forEach(p => {
      const statusCls = (p.status === 'i' || p.status === 'u' || p.status === 's') ? ' status-i' : '';
      html += `<div class="roster-player${statusCls}" onclick="showPlayerDetail(${p.id})">
        <img src="https://resources.premierleague.com/premierleague/photos/players/110x140/p${p.code}.png"
             alt="${p.web_name}" onerror="this.src=WALDO_DATA_URI">
        <div class="rp-info">
          <div class="rp-name">${p.web_name}</div>
          <div class="rp-meta">
            <span>${p.now_cost}m</span>
            <span>${p.minutes} min</span>
            <span>F:${p.form}</span>
          </div>
        </div>
        <div class="rp-pts">${p.total_points}</div>
      </div>`;
    });
    html += '</div></div>';
  });
  document.getElementById('playersContent').innerHTML = html;
}

function showPlayerDetail(playerId) {
  playersView = 'detail';
  playersSelectedPlayer = playerId;
  document.getElementById('playersGwControls').style.display = 'none';
  updatePlayersBreadcrumb();

  if (playersDetailCache[playerId]) {
    renderPlayerDetail(playersDetailCache[playerId]);
    return;
  }

  document.getElementById('playersContent').innerHTML =
    '<div class="empty-state"><p>Loading player...</p></div>';
  fetch(`/api/players/${playerId}/detail`).then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('playersContent').innerHTML = friendlyError(d.error, 'Player');
      return;
    }
    playersDetailCache[playerId] = d;
    // Set GW range defaults (last 10)
    if (d.available_gws && d.available_gws.length > 0) {
      const maxGw = Math.max(...d.available_gws);
      playersGwTo = maxGw;
      playersGwFrom = Math.max(1, maxGw - 9);
    }
    renderPlayerDetail(d);
  }).catch(() => {
    document.getElementById('playersContent').innerHTML = friendlyError('Could not load player details.', 'Player');
  });
}

function renderPlayerDetail(d) {
  const p = d.player;
  const gwFrom = playersGwFrom || 1;
  const gwTo = playersGwTo || 38;
  const filteredHistory = d.gw_history.filter(g => g.gw >= gwFrom && g.gw <= gwTo);
  const rangeLabel = `GW${gwFrom}-${gwTo}`;

  // Show GW controls
  const ctrl = document.getElementById('playersGwControls');
  ctrl.style.display = 'flex';
  document.getElementById('playersGwFrom').value = gwFrom;
  document.getElementById('playersGwTo').value = gwTo;
  document.getElementById('playersRangeLabel').textContent = filteredHistory.length + ' gameweeks';

  // --- Status pill ---
  const statusMap = {a: 'Available', d: 'Doubtful', i: 'Injured', s: 'Suspended', u: 'Unavailable'};
  const statusLabel = statusMap[p.status] || p.status;

  // --- Header ---
  let html = `<div class="player-detail-header">
    <img class="player-photo-lg"
         src="https://resources.premierleague.com/premierleague/photos/players/110x140/p${p.code}.png"
         alt="${p.web_name}"
         onerror="this.src=WALDO_DATA_URI">
    <div class="player-header-info">
      <h2>${p.first_name} ${p.second_name}</h2>
      <div class="player-team-line">
        <img src="https://resources.premierleague.com/premierleague/badges/25/t${p.team_code}.png"
             alt="${p.team_short}" onerror="this.style.display='none'">
        <span>${p.team_name}</span>
      </div>
      <div class="player-header-meta">
        <div class="meta-pill"><span class="label">Pos</span> <span class="value">${p.position}</span></div>
        <div class="meta-pill"><span class="label">Price</span> <span class="value">${p.now_cost}m</span></div>
        <div class="meta-pill"><span class="label">Ownership</span> <span class="value">${p.selected_by_percent}%</span></div>
        <div class="meta-pill status-${p.status}"><span class="label">Status</span> <span class="value">${statusLabel}</span></div>
        ${p.news ? `<div class="meta-pill"><span class="label">News</span> <span class="value" style="font-size:11px">${p.news}</span></div>` : ''}
      </div>
    </div>
  </div>`;

  // --- Season summary stats (from filtered GW range) ---
  const totalPts = filteredHistory.reduce((s, g) => s + g.event_points, 0);
  const totalMins = filteredHistory.reduce((s, g) => s + g.minutes, 0);
  const totalGoals = filteredHistory.reduce((s, g) => s + g.goals_scored, 0);
  const totalAssists = filteredHistory.reduce((s, g) => s + g.assists, 0);
  const totalCS = filteredHistory.reduce((s, g) => s + g.clean_sheets, 0);
  const totalBonus = filteredHistory.reduce((s, g) => s + g.bonus, 0);
  const totalStarts = filteredHistory.reduce((s, g) => s + (g.starts || 0), 0);
  const ptsPerGw = filteredHistory.length > 0 ? (totalPts / filteredHistory.length).toFixed(1) : '0';
  const ptsPer90 = totalMins > 0 ? (totalPts / totalMins * 90).toFixed(1) : '0';

  // Advanced stats from filtered range
  const fXg = filteredHistory.reduce((s, g) => s + (g.xg || 0), 0);
  const fXa = filteredHistory.reduce((s, g) => s + (g.xa || 0), 0);

  html += `<div class="player-section-title">Season Summary (${rangeLabel})</div>
  <div class="player-stats-grid">
    <div class="player-stat-card"><div class="stat-val">${totalPts}</div><div class="stat-label">Total Pts</div></div>
    <div class="player-stat-card"><div class="stat-val">${ptsPerGw}</div><div class="stat-label">Pts/GW</div></div>
    <div class="player-stat-card"><div class="stat-val">${ptsPer90}</div><div class="stat-label">Pts/90</div></div>
    <div class="player-stat-card"><div class="stat-val">${totalGoals}</div><div class="stat-label">Goals</div></div>
    <div class="player-stat-card"><div class="stat-val">${totalAssists}</div><div class="stat-label">Assists</div></div>
    <div class="player-stat-card"><div class="stat-val">${totalCS}</div><div class="stat-label">Clean Sheets</div></div>
    <div class="player-stat-card"><div class="stat-val">${totalBonus}</div><div class="stat-label">Bonus</div></div>
    <div class="player-stat-card"><div class="stat-val">${totalMins}</div><div class="stat-label">Minutes</div></div>
    <div class="player-stat-card"><div class="stat-val">${totalStarts}</div><div class="stat-label">Starts</div></div>
    <div class="player-stat-card"><div class="stat-val">${p.form}</div><div class="stat-label">Form</div></div>
    <div class="player-stat-card"><div class="stat-val">${fXg.toFixed(2)}</div><div class="stat-label">xG (Exp. Goals)</div></div>
    <div class="player-stat-card"><div class="stat-val">${fXa.toFixed(2)}</div><div class="stat-label">xA (Exp. Assists)</div></div>
  </div>`;

  // --- Predictions ---
  if (d.predictions && d.predictions.predicted_next_gw_points) {
    const pr = d.predictions;
    const hasComponents = pr.components && Object.keys(pr.components).length > 0;
    const hasPerGw = pr.per_gw && pr.per_gw.length > 0;

    html += `<div class="player-section-title"> Model Predictions</div>`;

    // --- Headline prediction cards ---
    const low = pr.prediction_low != null ? pr.prediction_low : '?';
    const high = pr.prediction_high != null ? pr.prediction_high : '?';
    const q80 = pr.q80 != null ? pr.q80 : null;
    const pts3 = pr.predicted_next_3gw_points != null ? pr.predicted_next_3gw_points : '?';
    // Predicted vs actual average
    const actualAvg = filteredHistory.length > 0 ? (totalPts / filteredHistory.length) : 0;
    const predVsActual = actualAvg > 0 ? ((pr.predicted_next_gw_points / actualAvg - 1) * 100).toFixed(0) : null;
    const trendIcon = predVsActual > 5 ? '' : predVsActual < -5 ? '' : '';
    const trendColor = predVsActual > 5 ? 'var(--accent)' : predVsActual < -5 ? 'var(--red)' : 'var(--text2)';

    html += `<div class="player-stats-grid">
      <div class="player-stat-card"><div class="stat-val" style="color:var(--accent);font-size:24px">${pr.predicted_next_gw_points}</div><div class="stat-label">Next GW Predicted</div></div>
      <div class="player-stat-card"><div class="stat-val">${low}  ${high}</div><div class="stat-label">Range (10th90th)</div></div>
      ${q80 ? `<div class="player-stat-card"><div class="stat-val">${q80}</div><div class="stat-label">Upside (Q80)</div></div>` : ''}
      <div class="player-stat-card"><div class="stat-val">${pts3}</div><div class="stat-label">Next 3 GWs Total</div></div>
      <div class="player-stat-card"><div class="stat-val">${pr.captain_score}</div><div class="stat-label">Captain Score</div></div>
      ${predVsActual !== null ? `<div class="player-stat-card"><div class="stat-val" style="color:${trendColor}">${trendIcon} ${Math.abs(predVsActual)}%</div><div class="stat-label">vs Season Avg (${actualAvg.toFixed(1)}/GW)</div></div>` : ''}
    </div>`;

    // --- Per-GW breakdown with fixtures ---
    if (hasPerGw) {
      html += `<div class="player-section-title">Per-Gameweek Forecast</div><div class="fixture-chips">`;
      pr.per_gw.forEach(g => {
        const fdr = g.fdr || 3;
        const ha = g.is_home === true ? 'H' : g.is_home === false ? 'A' : '';
        html += `<div class="fixture-chip fdr-${fdr}" style="min-width:80px">
          <span class="fc-gw">GW${g.gw}</span>
          <span class="fc-opp" style="font-size:11px">${g.opponent_short} ${ha}</span>
          <span style="font-size:18px;font-weight:700;margin-top:2px">${g.predicted_pts}</span>
          <span style="font-size:9px;opacity:0.7">pts</span>
        </div>`;
      });
      html += '</div>';
    }

    // --- Component breakdown ---
    if (hasComponents) {
      const c = pr.components;
      const compItems = [];
      // Map raw component values to human-readable labels
      if (c.sub_goals != null && c.sub_goals > 0.001) {
        const pct = (c.p_plays * c.sub_goals * 100).toFixed(0);
        compItems.push({label: 'Goal', prob: pct + '%', raw: c.sub_goals, pts: c.pts_goals});
      }
      if (c.sub_assists != null && c.sub_assists > 0.001) {
        const pct = (c.p_plays * c.sub_assists * 100).toFixed(0);
        compItems.push({label: 'Assist', prob: pct + '%', raw: c.sub_assists, pts: c.pts_assists});
      }
      if (c.sub_cs != null) {
        const pct = (c.p_60plus * c.sub_cs * 100).toFixed(0);
        compItems.push({label: 'Clean Sheet', prob: pct + '%', raw: c.sub_cs, pts: c.pts_cs});
      }
      if (c.sub_saves != null && c.sub_saves > 0.01) {
        compItems.push({label: 'Saves', prob: c.sub_saves.toFixed(1), raw: c.sub_saves, pts: c.pts_saves});
      }
      if (c.sub_bonus != null && c.sub_bonus > 0.01) {
        compItems.push({label: 'Bonus', prob: c.sub_bonus.toFixed(2), raw: c.sub_bonus, pts: c.pts_bonus});
      }
      if (c.pts_appearance != null) {
        compItems.push({label: 'Appearance', prob: (c.p_plays * 100).toFixed(0) + '%', raw: null, pts: c.pts_appearance});
      }
      if (c.sub_goals_conceded != null && c.pts_gc != null && c.pts_gc < -0.01) {
        compItems.push({label: 'Goals Conceded', prob: c.sub_goals_conceded.toFixed(2), raw: c.sub_goals_conceded, pts: c.pts_gc});
      }

      if (compItems.length > 0) {
        html += `<div class="player-section-title">Points Breakdown  Where Will Points Come From?</div>
        <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:8px;margin-bottom:16px">`;
        compItems.forEach(item => {
          const ptsColor = item.pts > 0 ? 'var(--accent)' : item.pts < 0 ? 'var(--red)' : 'var(--text2)';
          const barWidth = Math.min(100, Math.abs(item.pts) / 3 * 100);
          html += `<div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:10px 12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
              <span style="font-weight:600;font-size:13px">${item.label}</span>
              <span style="font-size:12px;color:var(--text2)">${item.prob}</span>
            </div>
            <div style="height:6px;background:var(--surface2);border-radius:3px;overflow:hidden">
              <div style="height:100%;width:${barWidth}%;background:${ptsColor};border-radius:3px"></div>
            </div>
            <div style="text-align:right;font-size:12px;margin-top:4px;color:${ptsColor};font-weight:600">${item.pts > 0 ? '+' : ''}${item.pts.toFixed(2)} pts</div>
          </div>`;
        });
        html += '</div>';
      }
    }

    // No predictions available message
  } else if (!d.predictions || !d.predictions.predicted_next_gw_points) {
    html += `<div class="player-section-title"> Model Predictions</div>
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:16px;margin-bottom:16px;color:var(--text2);font-size:13px">
      No predictions available. Get latest data and train models to see predictions here.
    </div>`;
  }

  // --- Points bar chart ---
  html += `<div class="player-section-title">Points per Gameweek (${rangeLabel})</div>
  <div style="width:100%;margin-bottom:16px"><canvas id="playerPtsChart"></canvas></div>`;

  // --- Price history chart ---
  if (d.price_history && d.price_history.length > 1) {
    html += `<div class="player-section-title">Price History</div>
    <div style="width:100%;margin-bottom:16px"><canvas id="playerPriceChart"></canvas></div>`;
  }

  // --- Upcoming fixtures ---
  if (d.upcoming_fixtures && d.upcoming_fixtures.length > 0) {
    html += `<div class="player-section-title">Upcoming Fixtures</div><div class="fixture-chips">`;
    d.upcoming_fixtures.forEach(f => {
      html += `<div class="fixture-chip fdr-${f.fdr}">
        <span class="fc-gw">GW${f.gw}</span>
        <span class="fc-opp">${f.opponent_short}</span>
        <span class="fc-ha">${f.is_home ? 'H' : 'A'}</span>
      </div>`;
    });
    html += '</div>';
  }

  // --- Advanced stats ---
  if (d.advanced_summary && Object.keys(d.advanced_summary).length > 0) {
    const as = d.advanced_summary;
    // Re-compute from filtered range
    const fKeys = ['xg','xa','xgot','total_shots','chances_created','touches_opposition_box','tackles_won','successful_dribbles','accurate_crosses','saves'];
    const fLabels = {'xg':'Exp. Goals (xG)','xa':'Exp. Assists (xA)','xgot':'xG on Target','total_shots':'Shots','chances_created':'Chances Created','touches_opposition_box':'Touches (Box)','tackles_won':'Tackles Won','successful_dribbles':'Dribbles','accurate_crosses':'Crosses','saves':'Saves'};
    let fTotals = {};
    let fMins = 0;
    filteredHistory.forEach(g => {
      fKeys.forEach(k => { fTotals[k] = (fTotals[k] || 0) + (g[k] || 0); });
      fMins += g.minutes || 0;
    });
    html += `<div class="player-section-title">Advanced Stats (${rangeLabel})</div><div class="player-stats-grid">`;
    fKeys.forEach(k => {
      const total = fTotals[k] || 0;
      const per90 = fMins > 0 ? (total / fMins * 90).toFixed(2) : '0';
      if (total > 0 || ['xg','xa','total_shots'].includes(k)) {
        html += `<div class="player-stat-card"><div class="stat-val">${total.toFixed(k === 'total_shots' || k === 'chances_created' || k === 'touches_opposition_box' || k === 'tackles_won' || k === 'successful_dribbles' || k === 'accurate_crosses' || k === 'saves' ? 0 : 2)}</div><div class="stat-label">${fLabels[k]} (${per90}/90)</div></div>`;
      }
    });
    html += '</div>';
  }

  // --- Per-GW table ---
  html += `<div class="player-section-title">Gameweek Breakdown (${rangeLabel})</div>
  <div style="max-height:400px;overflow-y:auto">
  <table class="player-gw-table" id="playerGwTable">
    <thead><tr>
      <th onclick="sortPlayerGwTable('gw')">GW</th>
      <th>Opp</th>
      <th onclick="sortPlayerGwTable('minutes')">Min</th>
      <th onclick="sortPlayerGwTable('event_points')">Pts</th>
      <th onclick="sortPlayerGwTable('goals_scored')">G</th>
      <th onclick="sortPlayerGwTable('assists')">A</th>
      <th onclick="sortPlayerGwTable('clean_sheets')">CS</th>
      <th onclick="sortPlayerGwTable('bonus')">Bon</th>
      <th onclick="sortPlayerGwTable('bps')">BPS</th>
      <th onclick="sortPlayerGwTable('xg')">xG</th>
      <th onclick="sortPlayerGwTable('xa')">xA</th>
      <th onclick="sortPlayerGwTable('total_shots')">Sh</th>
    </tr></thead><tbody>`;

  // Most recent first
  const tableData = [...filteredHistory].reverse();
  tableData.forEach(g => {
    const oppStr = g.opponent_short || '-';
    const haStr = g.is_home === true ? '(H)' : g.is_home === false ? '(A)' : '';
    const ptsCls = g.event_points >= 7 ? 'pts-high' : g.event_points <= 1 ? 'pts-low' : 'pts-mid';
    html += `<tr>
      <td>${g.gw}</td>
      <td>${oppStr} ${haStr}</td>
      <td>${g.minutes}</td>
      <td class="${ptsCls}">${g.event_points}</td>
      <td>${g.goals_scored || 0}</td>
      <td>${g.assists || 0}</td>
      <td>${g.clean_sheets || 0}</td>
      <td>${g.bonus || 0}</td>
      <td>${g.bps || 0}</td>
      <td>${(g.xg || 0).toFixed(2)}</td>
      <td>${(g.xa || 0).toFixed(2)}</td>
      <td>${g.total_shots || 0}</td>
    </tr>`;
  });
  html += '</tbody></table></div>';

  document.getElementById('playersContent').innerHTML = html;

  // Draw charts
  setTimeout(() => {
    if (filteredHistory.length > 0) {
      drawBarChart('playerPtsChart', filteredHistory, 'gw', 'event_points', {color: '#2dd4a0'});
    }
    if (d.price_history && d.price_history.length > 1) {
      drawLineChart('playerPriceChart', d.price_history, 'gw', 'price', {color: '#f59e0b', decimals: 1});
    }
  }, 50);
}

function updatePlayersBreadcrumb() {
  let html = '';
  if (playersView === 'teams') {
    html = '<span class="current">All Teams</span>';
  } else if (playersView === 'roster') {
    html = `<a onclick="showPlayersTeamGrid()">All Teams</a><span class="sep"></span>
            <span class="current">${playersSelectedTeam ? playersSelectedTeam.name : ''}</span>`;
  } else if (playersView === 'detail') {
    const teamName = playersSelectedTeam ? playersSelectedTeam.name : '';
    const cached = playersDetailCache[playersSelectedPlayer];
    const playerName = cached ? cached.player.web_name : '';
    html = `<a onclick="showPlayersTeamGrid()">All Teams</a><span class="sep"></span>`;
    if (playersSelectedTeam) {
      html += `<a onclick="showTeamRoster(${playersSelectedTeam.id})">${teamName}</a><span class="sep"></span>`;
    }
    html += `<span class="current">${playerName}</span>`;
  }
  document.getElementById('playersBreadcrumb').innerHTML = html;
}

let playerGwSortCol = null;
let playerGwSortAsc = false;

function sortPlayerGwTable(col) {
  if (!playersSelectedPlayer || !playersDetailCache[playersSelectedPlayer]) return;
  if (playerGwSortCol === col) {
    playerGwSortAsc = !playerGwSortAsc;
  } else {
    playerGwSortCol = col;
    playerGwSortAsc = false;
  }
  renderPlayerDetail(playersDetailCache[playersSelectedPlayer]);
}

function applyPlayersGwRange() {
  const from = parseInt(document.getElementById('playersGwFrom').value) || 1;
  const to = parseInt(document.getElementById('playersGwTo').value) || 38;
  playersGwFrom = Math.max(1, Math.min(from, 38));
  playersGwTo = Math.max(playersGwFrom, Math.min(to, 38));
  if (playersSelectedPlayer && playersDetailCache[playersSelectedPlayer]) {
    renderPlayerDetail(playersDetailCache[playersSelectedPlayer]);
  }
}

function resetPlayersGwRange() {
  if (playersSelectedPlayer && playersDetailCache[playersSelectedPlayer]) {
    const gws = playersDetailCache[playersSelectedPlayer].available_gws;
    if (gws && gws.length > 0) {
      playersGwTo = Math.max(...gws);
      playersGwFrom = 1;
    }
    renderPlayerDetail(playersDetailCache[playersSelectedPlayer]);
  }
}


// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
connectSSE();
loadPredictions();
loadModelInfo();

// Restore saved manager ID and auto-import squad
const savedManagerId = localStorage.getItem('fpl_manager_id');
if (savedManagerId) {
  document.getElementById('managerIdInput').value = savedManagerId;
  document.getElementById('seasonManagerId').value = savedManagerId;
  importMyTeam();
}
// --- Help Overlay ---
function openHelp() { document.getElementById('helpOverlay').style.display = 'flex'; }
function closeHelp() { document.getElementById('helpOverlay').style.display = 'none'; }

// ---------------------------------------------------------------------------
// Monsters Tab
// ---------------------------------------------------------------------------
let _monstersLoaded = false;

function loadMonsters() {
  if (_monstersLoaded) return;
  const container = document.getElementById('monstersContent');
  container.innerHTML = '<div class="empty-state"><h3>Loading Monsters...</h3></div>';

  fetch('/api/monsters').then(r => r.json()).then(d => {
    if (d.error) {
      container.innerHTML = friendlyError(d.error, 'No Monsters Yet');
      return;
    }
    _monstersLoaded = true;
    renderMonsters(d.categories);
  }).catch(err => {
    container.innerHTML = friendlyError(err.message, 'Monsters');
  });
}

function renderMonsters(categories) {
  const container = document.getElementById('monstersContent');
  let html = '<div class="monsters-grid">';

  categories.forEach(cat => {
    html += `<div class="monster-category">
      <div class="monster-category-header">
        <span class="cat-emoji">${cat.emoji}</span>
        <span class="cat-title">${cat.title}</span>
        <span class="cat-subtitle">${cat.subtitle}</span>
      </div>
      <div class="monster-podium">`;

    cat.players.forEach((p, i) => {
      const rank = i + 1;
      const photoUrl = p.photo_code
        ? `https://resources.premierleague.com/premierleague/photos/players/110x140/p${p.photo_code}.png`
        : '';
      const badgeUrl = p.team_code
        ? `https://resources.premierleague.com/premierleague/badges/25/t${p.team_code}.png`
        : '';

      // Format stat value
      let statDisplay = p.stat_value;
      if (typeof statDisplay === 'number') {
        statDisplay = Math.round(statDisplay);
      }

      html += `<div class="monster-card rank-${rank}">
        <div class="monster-rank-badge">${rank}</div>
        <img class="monster-photo" src="${photoUrl}"
             onerror="this.src=WALDO_DATA_URI"
             alt="${p.web_name}">
        <div class="monster-name">${p.web_name}</div>
        <div class="monster-team-row">
          ${badgeUrl ? `<img class="monster-team-badge" src="${badgeUrl}" alt="">` : ''}
          <span class="monster-team-name">${p.team_short} &middot; ${p.cost}m</span>
        </div>
        <span class="monster-pos-tag ${p.position}">${p.position}</span>
        <div class="monster-stat">
          <div class="monster-stat-value">${statDisplay}</div>
          <div class="monster-stat-label">${p.stat_label}</div>
        </div>
        <div class="monster-pts">${p.total_pts} pts</div>
      </div>`;
    });

    html += '</div></div>';
  });

  html += '</div>';
  container.innerHTML = html;
}

// ---------------------------------------------------------------------------
// Backtest
// ---------------------------------------------------------------------------
let backtestGWResults = [];
let backtestTotalGWs = 0;
let backtestStartGW = 0;

function runBacktest() {
  const startGW = parseInt(document.getElementById('btStartGW').value) || 9;
  const endGW = parseInt(document.getElementById('btEndGW').value) || 26;

  if (startGW >= endGW || startGW < 2 || endGW > 38) {
    alert('Invalid GW range. Start must be >= 2, End <= 38, and Start < End.');
    return;
  }

  backtestGWResults = [];
  backtestTotalGWs = endGW - startGW + 1;
  backtestStartGW = startGW;

  document.getElementById('btResults').style.display = 'block';
  document.getElementById('btExplainer').style.display = 'none';
  document.getElementById('btScoreboard').innerHTML = '<div class="empty-state"><p>Starting backtest...</p></div>';
  document.getElementById('btTimeline').innerHTML = '';
  document.getElementById('btTimelineHeader').style.display = 'flex';
  document.getElementById('btProgressFill').style.width = '0%';
  document.getElementById('btDeepDive').style.display = 'none';

  fetch('/api/backtest', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ start_gw: startGW, end_gw: endGW }),
  }).then(r => r.json()).then(d => {
    if (d.error) {
      document.getElementById('btScoreboard').innerHTML = friendlyError(d.error, 'Backtest');
      return;
    }
  }).catch(err => {
    document.getElementById('btScoreboard').innerHTML = friendlyError(err.message, 'Backtest');
  });
}

function handleBacktestGW(gwData) {
  backtestGWResults.push(gwData);
  const pct = Math.round((backtestGWResults.length / backtestTotalGWs) * 100);
  document.getElementById('btProgressFill').style.width = pct + '%';
  renderBTScoreboardLive();
  renderBTGWCard(gwData);
}

function handleBacktestDone() {
  fetch('/api/backtest-results').then(r => r.json()).then(d => {
    if (d.error) return;
    renderBTScoreboard(d.summary);
    renderBTDeepDive(d);
    document.getElementById('btExplainer').style.display = '';
  });
}

function renderBTScoreboardLive() {
  const results = backtestGWResults;
  const n = results.length;
  if (n === 0) return;

  const wins = results.filter(r => r.winner === 'MODEL').length;
  const losses = results.filter(r => r.winner === 'ep_next').length;
  const ties = results.filter(r => r.winner === 'TIE').length;
  const avgMAE = (results.reduce((s, r) => s + r.model_mae, 0) / n).toFixed(3);
  const avgEpMAE = (results.reduce((s, r) => s + r.ep_mae, 0) / n).toFixed(3);
  const avgSpearman = (results.reduce((s, r) => s + r.spearman_rho, 0) / n).toFixed(3);
  const avgTop11 = (results.reduce((s, r) => s + r.model_top11_pts, 0) / n).toFixed(1);
  const avgActual = (results.reduce((s, r) => s + r.actual_best_pts, 0) / n).toFixed(1);
  const capHits = results.filter(r => r.captain_in_top3).length;
  const capRate = Math.round((capHits / n) * 100);

  const maeClass = parseFloat(avgMAE) < parseFloat(avgEpMAE) ? 'good' : 'bad';
  const capture = avgActual > 0 ? ((avgTop11 / avgActual) * 100).toFixed(1) : '0';

  document.getElementById('btScoreboard').innerHTML = `
    <div class="bt-score-side">
      <div class="bt-score-team model">Gaffer AI</div>
      <div class="bt-score-record ${wins >= losses ? 'win' : 'lose'}">${wins}</div>
    </div>
    <div class="bt-score-vs">
      <div style="font-size:12px;color:var(--text2);margin-bottom:4px">${n} GWs tested</div>
      vs
      <div style="font-size:11px;color:var(--text2);margin-top:4px">${ties > 0 ? ties + ' tie' + (ties > 1 ? 's' : '') : ''}</div>
    </div>
    <div class="bt-score-side right">
      <div class="bt-score-team ep">FPL Predicted (ep)</div>
      <div class="bt-score-record ${losses > wins ? 'win' : 'lose'}">${losses}</div>
    </div>
    <div class="bt-score-stats">
      <div class="bt-stat-card">
        <div class="bt-stat-val ${maeClass}">${avgMAE}</div>
        <div class="bt-stat-label">MAE</div>
        <div class="bt-stat-sub">vs ${avgEpMAE} ep</div>
      </div>
      <div class="bt-stat-card">
        <div class="bt-stat-val ${parseFloat(avgSpearman) > 0.6 ? 'good' : 'neutral'}">${avgSpearman}</div>
        <div class="bt-stat-label">Ranking</div>
        <div class="bt-stat-sub">Spearman rho</div>
      </div>
      <div class="bt-stat-card">
        <div class="bt-stat-val neutral">${avgTop11}</div>
        <div class="bt-stat-label">Top-11 Pts</div>
        <div class="bt-stat-sub">${capture}% of best</div>
      </div>
      <div class="bt-stat-card">
        <div class="bt-stat-val ${capRate >= 30 ? 'good' : 'neutral'}">${capRate}%</div>
        <div class="bt-stat-label">Captain</div>
        <div class="bt-stat-sub">in actual top 3</div>
      </div>
    </div>
  `;
}

function renderBTGWCard(gw) {
  const timeline = document.getElementById('btTimeline');
  const winClass = gw.winner === 'MODEL' ? 'win' : gw.winner === 'ep_next' ? 'lose' : 'tie';
  const badgeText = gw.winner === 'MODEL' ? 'Win' : gw.winner === 'ep_next' ? 'Loss' : 'Tie';
  const capClass = gw.captain_in_top3 ? 'hit' : 'miss';

  const card = document.createElement('div');
  card.className = `bt-gw-card ${winClass}`;
  card.innerHTML = `
    <div class="bt-gw-header">
      <span class="bt-gw-num">GW ${gw.gw}</span>
      <span class="bt-gw-badge ${winClass}">${badgeText}</span>
    </div>
    <div class="bt-gw-row"><span>MAE</span><span class="val">${gw.model_mae.toFixed(3)} <span style="color:var(--text2);font-weight:400">vs ${gw.ep_mae.toFixed(3)}</span></span></div>
    <div class="bt-gw-row"><span>Ranking</span><span class="val">${gw.spearman_rho.toFixed(3)}</span></div>
    <div class="bt-gw-row"><span>Top-11</span><span class="val">${gw.model_top11_pts.toFixed(0)} / ${gw.actual_best_pts.toFixed(0)}</span></div>
    <div class="bt-gw-captain">
      <span>C: ${gw.captain_name}</span>
      <span class="captain-pts ${capClass}">${gw.captain_actual.toFixed(0)} pts</span>
    </div>
  `;
  timeline.appendChild(card);
}

function renderBTScoreboard(s) {
  const maeClass = s.model_avg_mae < s.ep_avg_mae ? 'good' : 'bad';
  const capture = s.model_capture_pct;
  const capRate = Math.round(s.captain_hit_rate * 100);
  const pval = s.mae_pvalue != null ? s.mae_pvalue : 1;
  const sigText = pval < 0.01 ? 'Highly significant (p<0.01)' : pval < 0.05 ? 'Significant (p<0.05)' : pval < 0.1 ? 'Marginally significant' : 'Not statistically significant';
  const sigClass = pval < 0.05 ? 'good' : 'neutral';

  let verdictClass, verdictText;
  if (s.model_wins > s.ep_wins && pval < 0.05) {
    verdictClass = 'positive';
    verdictText = `Gaffer AI outperforms FPL predictions with statistical significance. ${sigText} (p=${pval}).`;
  } else if (s.model_wins > s.ep_wins) {
    verdictClass = 'positive';
    verdictText = `Gaffer AI wins more gameweeks but the margin is not yet statistically conclusive. ${sigText}.`;
  } else if (s.model_wins < s.ep_wins) {
    verdictClass = 'negative';
    verdictText = `FPL predictions outperformed this run. Consider retraining or expanding the test range.`;
  } else {
    verdictClass = 'neutral';
    verdictText = `Dead even  neither model has a clear edge over this range.`;
  }

  document.getElementById('btScoreboard').innerHTML = `
    <div class="bt-score-side">
      <div class="bt-score-team model">Gaffer AI</div>
      <div class="bt-score-record ${s.model_wins >= s.ep_wins ? 'win' : 'lose'}">${s.model_wins}</div>
    </div>
    <div class="bt-score-vs">
      <div style="font-size:12px;color:var(--text2);margin-bottom:4px">${s.n_gameweeks} GWs tested</div>
      vs
      <div style="font-size:11px;color:var(--text2);margin-top:4px">${s.ties > 0 ? s.ties + ' tie' + (s.ties > 1 ? 's' : '') : ''}</div>
    </div>
    <div class="bt-score-side right">
      <div class="bt-score-team ep">FPL Predicted (ep)</div>
      <div class="bt-score-record ${s.ep_wins > s.model_wins ? 'win' : 'lose'}">${s.ep_wins}</div>
    </div>
    <div class="bt-score-stats">
      <div class="bt-stat-card">
        <div class="bt-stat-val ${maeClass}">${s.model_avg_mae}</div>
        <div class="bt-stat-label">MAE</div>
        <div class="bt-stat-sub">vs ${s.ep_avg_mae} ep</div>
      </div>
      <div class="bt-stat-card">
        <div class="bt-stat-val ${parseFloat(s.avg_spearman) > 0.6 ? 'good' : 'neutral'}">${s.avg_spearman}</div>
        <div class="bt-stat-label">Ranking</div>
        <div class="bt-stat-sub">vs ${s.avg_ep_spearman} ep</div>
      </div>
      <div class="bt-stat-card">
        <div class="bt-stat-val neutral">${s.model_avg_top11_pts}</div>
        <div class="bt-stat-label">Top-11 Pts/GW</div>
        <div class="bt-stat-sub">${capture}% of best</div>
      </div>
      <div class="bt-stat-card">
        <div class="bt-stat-val ${capRate >= 30 ? 'good' : 'neutral'}">${capRate}%</div>
        <div class="bt-stat-label">Captain</div>
        <div class="bt-stat-sub">in actual top 3</div>
      </div>
      <div class="bt-stat-card">
        <div class="bt-stat-val ${sigClass}">${pval != null ? 'p=' + pval : 'n/a'}</div>
        <div class="bt-stat-label">Significance</div>
        <div class="bt-stat-sub">Wilcoxon test</div>
      </div>
    </div>
    <div class="bt-verdict ${verdictClass}">${verdictText}</div>
    <div style="text-align:center;font-size:11px;color:var(--text2);margin-top:8px">The p-value comes from a Wilcoxon signed-rank test. The smaller the number, the less likely the result is down to luck.</div>
  `;
}

function renderBTDeepDive(data) {
  document.getElementById('btDeepDive').style.display = 'block';

  const pos = data.by_position || {};
  const posOrder = ['GKP', 'DEF', 'MID', 'FWD'];
  let posHtml = '<h3>Accuracy by Position</h3>';
  posHtml += '<p class="bt-section-subtitle">MAE (Mean Absolute Error) broken down by position  lower is better</p>';
  posHtml += '<table class="bt-pos-table"><thead><tr><th>Position</th><th>Model MAE</th><th>FPL ep MAE</th><th>Form MAE</th><th>Last 3 MAE</th><th>Avg Players</th><th>Verdict</th></tr></thead><tbody>';
  for (const p of posOrder) {
    if (!pos[p]) continue;
    const d = pos[p];
    const better = d.model_mae < d.ep_mae;
    const diff = (d.ep_mae - d.model_mae).toFixed(3);
    posHtml += `<tr>
      <td><span class="pos-tag ${p}">${p}</span></td>
      <td class="${better ? 'bt-better' : 'bt-worse'}">${d.model_mae}</td>
      <td>${d.ep_mae}</td>
      <td>${d.form_mae}</td>
      <td>${d.last3_mae}</td>
      <td style="color:var(--text2)">${d.avg_players}</td>
      <td class="${better ? 'bt-better' : 'bt-worse'}">${better ? '+' + diff + ' better' : diff + ' worse'}</td>
    </tr>`;
  }
  posHtml += '</tbody></table>';
  document.getElementById('btPositionBreakdown').innerHTML = posHtml;

  const cal = (data.diagnostics || {}).calibration || [];
  if (cal.length > 0) {
    const maxVal = Math.max(...cal.map(c => Math.max(c.predicted_avg, c.actual_avg)), 1);
    let calHtml = '<h3>Calibration</h3>';
    calHtml += '<p class="bt-section-subtitle">Does the model predict the right number of points? Predicted (purple) vs Actual (green) by prediction range</p>';
    for (const bucket of cal) {
      const predPct = (bucket.predicted_avg / maxVal) * 100;
      const actPct = (bucket.actual_avg / maxVal) * 100;
      const delta = (bucket.predicted_avg - bucket.actual_avg).toFixed(2);
      const dir = parseFloat(delta) > 0.1 ? 'over' : parseFloat(delta) < -0.1 ? 'under' : 'ok';
      const dirColor = dir === 'over' ? 'color:var(--red)' : dir === 'under' ? 'color:var(--yellow)' : 'color:var(--green)';
      calHtml += `<div class="bt-cal-row">
        <div class="bt-cal-label">${bucket.bin}</div>
        <div class="bt-cal-bars">
          <div class="bt-cal-bar predicted" style="width:${predPct}%"></div>
          <div class="bt-cal-bar actual" style="width:${actPct}%"></div>
        </div>
        <div class="bt-cal-values">pred ${bucket.predicted_avg.toFixed(2)} / actual ${bucket.actual_avg.toFixed(2)} <span style="${dirColor};font-weight:600">${dir === 'over' ? '' : dir === 'under' ? '' : ''}</span> (n=${bucket.count})</div>
      </div>`;
    }
    document.getElementById('btCalibration').innerHTML = calHtml;
  }

  const cap = (data.diagnostics || {}).captain_analysis || {};
  if (cap.avg_captain_pts != null) {
    let capHtml = '<h3>\u201cJust captain Haaland?\u201d</h3>';
    capHtml += '<p class="bt-section-subtitle">How good is the model at picking the right captain each week?</p>';
    capHtml += '<div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:16px">';
    capHtml += `<div class="bt-stat-card"><div class="bt-stat-val neutral">${cap.avg_captain_pts}</div><div class="bt-stat-label">Avg Captain Pts</div></div>`;
    capHtml += `<div class="bt-stat-card"><div class="bt-stat-val neutral">${cap.avg_best_captain_pts}</div><div class="bt-stat-label">Best Possible</div></div>`;
    capHtml += `<div class="bt-stat-card"><div class="bt-stat-val ${cap.captain_pts_lost <= 2 ? 'good' : 'bad'}">${cap.captain_pts_lost}</div><div class="bt-stat-label">Pts Lost / GW</div></div>`;
    if (cap.ep_avg_captain_pts != null) {
      capHtml += `<div class="bt-stat-card"><div class="bt-stat-val neutral">${cap.ep_avg_captain_pts}</div><div class="bt-stat-label">FPL ep Captain</div></div>`;
    }
    capHtml += `<div class="bt-stat-card"><div class="bt-stat-val ${cap.captain_in_top3_pct >= 30 ? 'good' : 'neutral'}">${cap.captain_in_top3_pct}%</div><div class="bt-stat-label">In Top 3</div></div>`;
    capHtml += `<div class="bt-stat-card"><div class="bt-stat-val neutral">${cap.captain_in_top10_pct}%</div><div class="bt-stat-label">In Top 10</div></div>`;
    capHtml += '</div>';

    if (cap.worst_captain_gws && cap.worst_captain_gws.length > 0) {
      capHtml += '<div style="font-size:13px;font-weight:600;margin-bottom:8px;color:var(--text2)">Biggest Captain Misses</div>';
      for (const w of cap.worst_captain_gws.slice(0, 5)) {
        const lost = (w.best_pts - w.pts).toFixed(0);
        capHtml += `<div class="bt-miss-item"><span><span class="bt-miss-name">${w.captain}</span><span class="bt-miss-gw">GW${w.gw}</span> scored ${w.pts} pts</span><span style="color:var(--red)">missed ${w.best} (${w.best_pts} pts, -${lost})</span></div>`;
      }
    }
    document.getElementById('btCaptainAnalysis').innerHTML = capHtml;
  }

  const misses = (data.diagnostics || {}).biggest_misses || {};
  const over = misses.overpredicted || [];
  const under = misses.underpredicted || [];
  if (over.length > 0 || under.length > 0) {
    let missHtml = '<h3>Oh the Joys of being an FPL Manager</h3>';
    missHtml += '<p class="bt-section-subtitle">The model\'s worst individual predictions  overpredicted (expected points that didn\'t arrive) and underpredicted (surprise hauls)</p>';
    missHtml += '<div class="bt-miss-grid">';

    missHtml += '<div class="bt-miss-col over"><h4>Overpredicted</h4>';
    for (const m of over.slice(0, 8)) {
      missHtml += `<div class="bt-miss-item"><span><span class="bt-miss-name">${m.web_name}</span><span class="bt-miss-gw">GW${m.gw}</span></span><span class="bt-miss-nums"><span class="bt-miss-pred">${m.predicted} pred</span><span class="bt-miss-actual">${m.actual} actual</span></span></div>`;
    }
    missHtml += '</div>';

    missHtml += '<div class="bt-miss-col under"><h4>Underpredicted</h4>';
    for (const m of under.slice(0, 8)) {
      missHtml += `<div class="bt-miss-item"><span><span class="bt-miss-name">${m.web_name}</span><span class="bt-miss-gw">GW${m.gw}</span></span><span class="bt-miss-nums"><span class="bt-miss-pred">${m.predicted} pred</span><span class="bt-miss-actual">${m.actual} actual</span></span></div>`;
    }
    missHtml += '</div></div>';
    document.getElementById('btBiggestMisses').innerHTML = missHtml;
  }

  const gw3 = data.backtest_3gw;
  if (gw3 && gw3.n_windows > 0) {
    let html3 = '<h3>3-Gameweek Rolling Backtest</h3>';
    html3 += '<p class="bt-section-subtitle">How accurately does the model predict over 3-week windows? Important for transfer planning and bench boost timing.</p>';
    html3 += '<div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:16px">';
    html3 += `<div class="bt-stat-card"><div class="bt-stat-val neutral">${gw3.avg_mae_3gw}</div><div class="bt-stat-label">3-GW MAE</div></div>`;
    html3 += `<div class="bt-stat-card"><div class="bt-stat-val ${gw3.avg_spearman_3gw > 0.7 ? 'good' : 'neutral'}">${gw3.avg_spearman_3gw}</div><div class="bt-stat-label">3-GW Ranking</div></div>`;
    html3 += `<div class="bt-stat-card"><div class="bt-stat-val neutral">${gw3.avg_model_top11_pts}</div><div class="bt-stat-label">Avg Top-11 Pts</div></div>`;
    html3 += `<div class="bt-stat-card"><div class="bt-stat-val neutral">${gw3.capture_pct_3gw}%</div><div class="bt-stat-label">Capture Rate</div></div>`;
    html3 += '</div>';
    document.getElementById('btThreeGW').innerHTML = html3;
  }
}
</script>

<!-- Help Overlay -->
<div id="helpOverlay" class="help-overlay" style="display:none" onclick="if(event.target===this)closeHelp()">
  <div class="help-content">
    <div class="help-header">
      <h2>How to Use FPL Gaffer - the brAIn</h2>
      <button class="help-close" onclick="closeHelp()">&times;</button>
    </div>
    <div class="help-body">
      <h3>Quick Start</h3>
      <ol>
        <li><strong>Train Models</strong> &mdash; Click "Train Models" in the action bar. This builds XGBoost models from historical data and generates player predictions. Takes a few minutes on first run.</li>
        <li><strong>Browse Predictions</strong> &mdash; The Predictions tab shows predicted points for every player. Filter by position and sort by any column.</li>
        <li><strong>Import Your Team</strong> &mdash; Go to My Team, enter your FPL Manager ID, and click "Import Squad" to import your actual squad.</li>
        <li><strong>Season Management</strong> &mdash; Go to the Season tab, enter your Manager ID, and click "Initialize Season" to start tracking your season with weekly recommendations.</li>
      </ol>

      <h3>Predictions Tab</h3>
      <p>Shows predicted points for every Premier League player. Use position filters (ALL / GKP / DEF / MID / FWD) to narrow the list. Key columns:</p>
      <ul>
        <li><strong>predicted_points</strong> &mdash; Expected points for the next gameweek</li>
        <li><strong>captain_score</strong> &mdash; Blend of mean prediction and upside (Q80). Higher = better captain pick</li>
        <li><strong>next_3gw_points</strong> &mdash; Predicted points over the next 3 gameweeks</li>
      </ul>

      <h3>Best Team Tab</h3>
      <p>Uses MILP optimization to pick the best possible 15-player squad from scratch within budget. Respects all FPL rules: 2 GKP, 5 DEF, 5 MID, 3 FWD, max 3 from any team. The result shows a pitch visualization with starters and bench.</p>

      <h3>GW Compare Tab</h3>
      <p>Compare your actual FPL team against the highest-scoring possible team for any past gameweek. Enter your Manager ID and a gameweek number, then click Compare to see:</p>
      <ul>
        <li><strong>Dual pitch view</strong> &mdash; Your actual team on the left, the hindsight-best team on the right</li>
        <li><strong>Overlap highlighting</strong> &mdash; Players in both teams are highlighted in yellow</li>
        <li><strong>Capture %</strong> &mdash; What percentage of the maximum possible points your team scored</li>
        <li><strong>Bench</strong> &mdash; Bench players shown for both sides</li>
      </ul>

      <h3>My Team Tab</h3>
      <p>Import your actual FPL squad to see how it compares to the optimal. Features:</p>
      <ul>
        <li><strong>Dual pitch view</strong> &mdash; Your actual team with predicted vs actual points</li>
        <li><strong>Transfer recommendations</strong> &mdash; The MILP solver suggests optimal transfers given your current squad, budget, and free transfers</li>
        <li><strong>Captain pick</strong> &mdash; Based on captain_score (mean + upside blend)</li>
      </ul>

      <h3>Season Management</h3>
      <p>The Season tab is the core feature. After initializing, the app automatically detects which phase the current gameweek is in:</p>
      <ul>
        <li><strong>Planning</strong> &mdash; Click "Start Planning" to refresh data, run predictions, and generate transfer/captain/chip recommendations</li>
        <li><strong>Ready</strong> &mdash; Review the recommended transfers, captain, and chip. Accept recommendations, make your own transfers, change the captain, or toggle a chip. Then execute on the FPL website.</li>
        <li><strong>Live</strong> &mdash; The deadline has passed. View your planned squad while matches are in progress.</li>
        <li><strong>Complete</strong> &mdash; GW is finished. Click "Record Results" to import actual picks and track accuracy.</li>
      </ul>
      <p>The view updates automatically as phases change. Transfer overrides let you make custom transfers by selecting players out and replacements in.</p>
    </div>
  </div>
</div>

</body>
</html>
